From 79ca403d73ebeb94af066ac85e0c87f92680d95f Mon Sep 17 00:00:00 2001
From: Hiroshi Shirosaki <h.shirosaki@gmail.com>
Date: Tue, 22 Jul 2014 14:58:19 +0900
Subject: [PATCH 19/20] msys.dll: add wchar functions from newlib 1.20 for gcc
 4.8

Add wchar function required for gcc 4.8 build.
---
 .../newlib/libc/include/machine/_default_types.h   |  121 ++
 msys/rt/src/newlib/libc/include/machine/_types.h   |    8 +
 msys/rt/src/newlib/libc/include/math.h             |    1 +
 msys/rt/src/newlib/libc/include/stdint.h           |  489 +++++
 msys/rt/src/newlib/libc/include/stdio.h            |    4 +
 msys/rt/src/newlib/libc/include/sys/errno.h        |    1 +
 msys/rt/src/newlib/libc/include/sys/lock.h         |   24 +
 msys/rt/src/newlib/libc/include/sys/reent.h        |    3 +
 msys/rt/src/newlib/libc/include/sys/syslimits.h    |   65 +
 msys/rt/src/newlib/libc/include/sys/types.h        |   16 +-
 msys/rt/src/newlib/libc/include/time.h             |   20 +
 msys/rt/src/newlib/libc/locale/Makefile.in         |    6 +-
 msys/rt/src/newlib/libc/locale/lctype.h            |   47 +
 msys/rt/src/newlib/libc/locale/ldpart.c            |  191 ++
 msys/rt/src/newlib/libc/locale/ldpart.h            |   35 +
 msys/rt/src/newlib/libc/locale/lmessages.h         |   57 +
 msys/rt/src/newlib/libc/locale/lmonetary.h         |   76 +
 msys/rt/src/newlib/libc/locale/lnumeric.h          |   54 +
 msys/rt/src/newlib/libc/locale/locale.c            |    2 +
 msys/rt/src/newlib/libc/locale/setlocale.h         |   37 +
 msys/rt/src/newlib/libc/locale/timelocal.c         |  188 ++
 msys/rt/src/newlib/libc/locale/timelocal.h         |   85 +
 msys/rt/src/newlib/libc/reent/readr.c              |    4 +-
 msys/rt/src/newlib/libc/reent/writer.c             |    4 +-
 msys/rt/src/newlib/libc/stdio/Makefile.am          |   44 +-
 msys/rt/src/newlib/libc/stdio/Makefile.in          |  103 +-
 msys/rt/src/newlib/libc/stdio/fgetwc.c             |  180 ++
 msys/rt/src/newlib/libc/stdio/fgetws.c             |  161 ++
 msys/rt/src/newlib/libc/stdio/fputwc.c             |  177 ++
 msys/rt/src/newlib/libc/stdio/fputws.c             |  122 ++
 msys/rt/src/newlib/libc/stdio/fwide.c              |   89 +
 msys/rt/src/newlib/libc/stdio/getwc.c              |   52 +
 msys/rt/src/newlib/libc/stdio/getwchar.c           |   93 +
 msys/rt/src/newlib/libc/stdio/local.h              |   31 +
 msys/rt/src/newlib/libc/stdio/putwc.c              |   53 +
 msys/rt/src/newlib/libc/stdio/putwchar.c           |   92 +
 msys/rt/src/newlib/libc/stdio/sniprintf.c          |  120 ++
 msys/rt/src/newlib/libc/stdio/swprintf.c           |  626 +++++++
 msys/rt/src/newlib/libc/stdio/ungetwc.c            |  115 ++
 msys/rt/src/newlib/libc/stdio/vfprintf.c           | 1953 ++++++++++++++++----
 msys/rt/src/newlib/libc/stdio/vfwprintf.c          | 1942 +++++++++++++++++++
 msys/rt/src/newlib/libc/stdlib/Makefile.in         |   11 +-
 msys/rt/src/newlib/libc/stdlib/btowc.c             |   32 +
 msys/rt/src/newlib/libc/string/Makefile.in         |    6 +-
 msys/rt/src/newlib/libc/string/wcslcpy.c           |  102 +
 msys/rt/src/newlib/libc/string/wcsxfrm.c           |   52 +
 msys/rt/src/newlib/libc/time/Makefile.in           |   12 +-
 msys/rt/src/newlib/libc/time/gettzinfo.c           |   15 +
 msys/rt/src/newlib/libc/time/local.h               |   36 +
 msys/rt/src/newlib/libc/time/strftime.c            | 1811 +++++++++++++++---
 msys/rt/src/newlib/libc/time/tzlock.c              |   56 +
 msys/rt/src/newlib/libc/time/wcsftime.c            |   68 +
 msys/rt/src/winsup/cygwin/cygwin.din               |   14 +
 53 files changed, 9045 insertions(+), 661 deletions(-)
 create mode 100644 msys/rt/src/newlib/libc/include/machine/_default_types.h
 create mode 100644 msys/rt/src/newlib/libc/include/machine/_types.h
 create mode 100644 msys/rt/src/newlib/libc/include/stdint.h
 create mode 100644 msys/rt/src/newlib/libc/include/sys/lock.h
 create mode 100644 msys/rt/src/newlib/libc/include/sys/syslimits.h
 create mode 100644 msys/rt/src/newlib/libc/locale/lctype.h
 create mode 100644 msys/rt/src/newlib/libc/locale/ldpart.c
 create mode 100644 msys/rt/src/newlib/libc/locale/ldpart.h
 create mode 100644 msys/rt/src/newlib/libc/locale/lmessages.h
 create mode 100644 msys/rt/src/newlib/libc/locale/lmonetary.h
 create mode 100644 msys/rt/src/newlib/libc/locale/lnumeric.h
 create mode 100644 msys/rt/src/newlib/libc/locale/setlocale.h
 create mode 100644 msys/rt/src/newlib/libc/locale/timelocal.c
 create mode 100644 msys/rt/src/newlib/libc/locale/timelocal.h
 create mode 100644 msys/rt/src/newlib/libc/stdio/fgetwc.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/fgetws.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/fputwc.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/fputws.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/fwide.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/getwc.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/getwchar.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/putwc.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/putwchar.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/sniprintf.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/swprintf.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/ungetwc.c
 create mode 100644 msys/rt/src/newlib/libc/stdio/vfwprintf.c
 create mode 100644 msys/rt/src/newlib/libc/stdlib/btowc.c
 create mode 100644 msys/rt/src/newlib/libc/string/wcslcpy.c
 create mode 100644 msys/rt/src/newlib/libc/string/wcsxfrm.c
 create mode 100644 msys/rt/src/newlib/libc/time/gettzinfo.c
 create mode 100644 msys/rt/src/newlib/libc/time/local.h
 create mode 100644 msys/rt/src/newlib/libc/time/tzlock.c
 create mode 100644 msys/rt/src/newlib/libc/time/wcsftime.c

diff --git a/msys/rt/src/newlib/libc/include/machine/_default_types.h b/msys/rt/src/newlib/libc/include/machine/_default_types.h
new file mode 100644
index 0000000..9a5fc8d
--- /dev/null
+++ b/msys/rt/src/newlib/libc/include/machine/_default_types.h
@@ -0,0 +1,121 @@
+/*
+ *  $Id: _default_types.h,v 1.2 2008/06/11 22:14:54 jjohnstn Exp $
+ */
+
+#ifndef _MACHINE__DEFAULT_TYPES_H
+#define _MACHINE__DEFAULT_TYPES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Guess on types by examining *_MIN / *_MAX defines.
+ */
+#if defined(__GNUC__) && ((__GNUC__ >= 4) || (__GNUC__ >= 3 ) \
+  && defined(__GNUC_MINOR__) && (__GNUC_MINOR__ > 2 ))
+/* GCC >= 3.3.0 has __<val>__ implicitly defined. */
+#define __EXP(x) __##x##__
+#else
+/* Fall back to POSIX versions from <limits.h> */
+#define __EXP(x) x
+#include <limits.h>
+#endif
+
+#if __EXP(SCHAR_MAX) == 0x7f
+typedef signed char __int8_t ;
+typedef unsigned char __uint8_t ;
+#define ___int8_t_defined 1
+#endif
+
+#if __EXP(INT_MAX) == 0x7fff
+typedef signed int __int16_t;
+typedef unsigned int __uint16_t;
+#define ___int16_t_defined 1
+#elif __EXP(SHRT_MAX) == 0x7fff
+typedef signed short __int16_t;
+typedef unsigned short __uint16_t;
+#define ___int16_t_defined 1
+#elif __EXP(SCHAR_MAX) == 0x7fff
+typedef signed char __int16_t;
+typedef unsigned char __uint16_t;
+#define ___int16_t_defined 1
+#endif
+
+#if ___int16_t_defined
+typedef __int16_t __int_least16_t;
+typedef __uint16_t __uint_least16_t;
+#define ___int_least16_t_defined 1
+
+#if !___int8_t_defined
+typedef __int16_t __int_least8_t;
+typedef __uint16_t __uint_least8_t;
+#define ___int_least8_t_defined 1
+#endif
+#endif
+
+#if __EXP(INT_MAX) == 0x7fffffffL
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+#define ___int32_t_defined 1
+#elif __EXP(LONG_MAX) == 0x7fffffffL
+typedef signed long __int32_t;
+typedef unsigned long __uint32_t;
+#define ___int32_t_defined 1
+#elif __EXP(SHRT_MAX) == 0x7fffffffL
+typedef signed short __int32_t;
+typedef unsigned short __uint32_t;
+#define ___int32_t_defined 1
+#elif __EXP(SCHAR_MAX) == 0x7fffffffL
+typedef signed char __int32_t;
+typedef unsigned char __uint32_t;
+#define ___int32_t_defined 1
+#endif
+
+#if ___int32_t_defined
+typedef __int32_t __int_least32_t;
+typedef __uint32_t __uint_least32_t;
+#define ___int_least32_t_defined 1
+
+#if !___int8_t_defined
+typedef __int32_t __int_least8_t;
+typedef __uint32_t __uint_least8_t;
+#define ___int_least8_t_defined 1
+#endif
+#if !___int16_t_defined
+typedef __int32_t __int_least16_t;
+typedef __uint32_t __uint_least16_t;
+#define ___int_least16_t_defined 1
+#endif
+#endif
+
+#if __EXP(LONG_MAX) > 0x7fffffff
+typedef signed long __int64_t;
+typedef unsigned long __uint64_t;
+#define ___int64_t_defined 1
+
+/* GCC has __LONG_LONG_MAX__ */
+#elif  defined(__LONG_LONG_MAX__) && (__LONG_LONG_MAX__ > 0x7fffffff)
+typedef signed long long __int64_t;
+typedef unsigned long long __uint64_t;
+#define ___int64_t_defined 1
+
+/* POSIX mandates LLONG_MAX in <limits.h> */
+#elif  defined(LLONG_MAX) && (LLONG_MAX > 0x7fffffff)
+typedef signed long long __int64_t;
+typedef unsigned long long __uint64_t;
+#define ___int64_t_defined 1
+
+#elif  __EXP(INT_MAX) > 0x7fffffff
+typedef signed int __int64_t;
+typedef unsigned int __uint64_t;
+#define ___int64_t_defined 1
+#endif
+
+#undef __EXP
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MACHINE__DEFAULT_TYPES_H */
diff --git a/msys/rt/src/newlib/libc/include/machine/_types.h b/msys/rt/src/newlib/libc/include/machine/_types.h
new file mode 100644
index 0000000..18f96d5
--- /dev/null
+++ b/msys/rt/src/newlib/libc/include/machine/_types.h
@@ -0,0 +1,8 @@
+/*
+ *  $Id: _types.h,v 1.3 2007/09/07 21:16:25 jjohnstn Exp $
+ */
+
+#ifndef _MACHINE__TYPES_H
+#define _MACHINE__TYPES_H
+#include <machine/_default_types.h>
+#endif
diff --git a/msys/rt/src/newlib/libc/include/math.h b/msys/rt/src/newlib/libc/include/math.h
index 255bf3b..26855c8 100644
--- a/msys/rt/src/newlib/libc/include/math.h
+++ b/msys/rt/src/newlib/libc/include/math.h
@@ -6,6 +6,7 @@ extern "C" {
 #endif
 #define  _MATH_H_
 
+#include <sys/types.h>
 #include <sys/reent.h>
 #include <machine/ieeefp.h>
 #include "_ansi.h"
diff --git a/msys/rt/src/newlib/libc/include/stdint.h b/msys/rt/src/newlib/libc/include/stdint.h
new file mode 100644
index 0000000..783d499
--- /dev/null
+++ b/msys/rt/src/newlib/libc/include/stdint.h
@@ -0,0 +1,489 @@
+/*
+ * Copyright (c) 2004, 2005 by
+ * Ralf Corsepius, Ulm/Germany. All rights reserved.
+ *
+ * Permission to use, copy, modify, and distribute this software
+ * is freely granted, provided that this notice is preserved.
+ */
+
+#ifndef _STDINT_H
+#define _STDINT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(__GNUC__) && \
+  ( (__GNUC__ >= 4) || \
+    ( (__GNUC__ >= 3) && defined(__GNUC_MINOR__) && (__GNUC_MINOR__ > 2) ) )
+/* gcc > 3.2 implicitly defines the values we are interested */
+#define __STDINT_EXP(x) __##x##__
+#else
+#define __STDINT_EXP(x) x
+#include <limits.h>
+#endif
+
+/* Check if "long long" is 64bit wide */
+/* Modern GCCs provide __LONG_LONG_MAX__, SUSv3 wants LLONG_MAX */
+#if ( defined(__LONG_LONG_MAX__) && (__LONG_LONG_MAX__ > 0x7fffffff) ) \
+  || ( defined(LLONG_MAX) && (LLONG_MAX > 0x7fffffff) )
+#define __have_longlong64 1
+#endif
+
+/* Check if "long" is 64bit or 32bit wide */
+#if __STDINT_EXP(LONG_MAX) > 0x7fffffff
+#define __have_long64 1
+#elif __STDINT_EXP(LONG_MAX) == 0x7fffffff && !defined(__SPU__)
+#define __have_long32 1
+#endif
+
+#if __STDINT_EXP(SCHAR_MAX) == 0x7f
+typedef char int8_t ;
+typedef unsigned char uint8_t ;
+#define __int8_t_defined 1
+#endif
+
+#if __int8_t_defined
+typedef signed char int_least8_t;
+typedef unsigned char uint_least8_t;
+#define __int_least8_t_defined 1
+#endif
+
+#if __STDINT_EXP(SHRT_MAX) == 0x7fff
+typedef signed short int16_t;
+typedef unsigned short uint16_t;
+#define __int16_t_defined 1
+#elif __STDINT_EXP(INT_MAX) == 0x7fff
+typedef signed int int16_t;
+typedef unsigned int uint16_t;
+#define __int16_t_defined 1
+#elif __STDINT_EXP(SCHAR_MAX) == 0x7fff
+typedef signed char int16_t;
+typedef unsigned char uint16_t;
+#define __int16_t_defined 1
+#endif
+
+#if __int16_t_defined
+typedef int16_t   	int_least16_t;
+typedef uint16_t 	uint_least16_t;
+#define __int_least16_t_defined 1
+
+#if !__int_least8_t_defined
+typedef int16_t	   	int_least8_t;
+typedef uint16_t  	uint_least8_t;
+#define __int_least8_t_defined 1
+#endif
+#endif
+
+#if __STDINT_EXP(INT_MAX) == 0x7fffffffL
+typedef signed int int32_t;
+typedef unsigned int uint32_t;
+#define __int32_t_defined 1
+#elif __STDINT_EXP(SHRT_MAX) == 0x7fffffffL
+typedef signed short int32_t;
+typedef unsigned short uint32_t;
+#define __int32_t_defined 1
+#elif __STDINT_EXP(SCHAR_MAX) == 0x7fffffffL
+typedef signed char int32_t;
+typedef unsigned char uint32_t;
+#define __int32_t_defined 1
+#endif
+
+#if __int32_t_defined
+typedef int32_t   	int_least32_t;
+typedef uint32_t 	uint_least32_t;
+#define __int_least32_t_defined 1
+
+#if !__int_least8_t_defined
+typedef int32_t	   	int_least8_t;
+typedef uint32_t  	uint_least8_t;
+#define __int_least8_t_defined 1
+#endif
+
+#if !__int_least16_t_defined
+typedef int32_t	   	int_least16_t;
+typedef uint32_t  	uint_least16_t;
+#define __int_least16_t_defined 1
+#endif
+#endif
+
+#if __have_long64
+typedef signed long int64_t;
+typedef unsigned long uint64_t;
+#define __int64_t_defined 1
+#elif __have_longlong64
+typedef signed long long int64_t;
+typedef unsigned long long uint64_t;
+#define __int64_t_defined 1
+#elif  __STDINT_EXP(INT_MAX) > 0x7fffffff
+typedef signed int int64_t;
+typedef unsigned int uint64_t;
+#define __int64_t_defined 1
+#endif
+
+#if __int64_t_defined
+typedef int64_t   	int_least64_t;
+typedef uint64_t 	uint_least64_t;
+#define __int_least64_t_defined 1
+
+#if !__int_least8_t_defined
+typedef int64_t	   	int_least8_t;
+typedef uint64_t  	uint_least8_t;
+#define __int_least8_t_defined 1
+#endif
+
+#if !__int_least16_t_defined
+typedef int64_t	   	int_least16_t;
+typedef uint64_t  	uint_least16_t;
+#define __int_least16_t_defined 1
+#endif
+
+#if !__int_least32_t_defined
+typedef int64_t	   	int_least32_t;
+typedef uint64_t  	uint_least32_t;
+#define __int_least32_t_defined 1
+#endif
+#endif
+
+/*
+ * Fastest minimum-width integer types
+ *
+ * Assume int to be the fastest type for all types with a width 
+ * less than __INT_MAX__ rsp. INT_MAX
+ */
+#if __STDINT_EXP(INT_MAX) >= 0x7f
+  typedef signed int int_fast8_t;
+  typedef unsigned int uint_fast8_t;
+#define __int_fast8_t_defined 1
+#endif
+
+#if __STDINT_EXP(INT_MAX) >= 0x7fff
+  typedef signed int int_fast16_t;
+  typedef unsigned int uint_fast16_t;
+#define __int_fast16_t_defined 1
+#endif
+
+#if __STDINT_EXP(INT_MAX) >= 0x7fffffff
+  typedef signed int int_fast32_t;
+  typedef unsigned int uint_fast32_t;
+#define __int_fast32_t_defined 1
+#endif
+
+#if __STDINT_EXP(INT_MAX) > 0x7fffffff
+  typedef signed int int_fast64_t;
+  typedef unsigned int uint_fast64_t;
+#define __int_fast64_t_defined 1
+#endif
+
+/*
+ * Fall back to [u]int_least<N>_t for [u]int_fast<N>_t types
+ * not having been defined, yet.
+ * Leave undefined, if [u]int_least<N>_t should not be available.
+ */
+#if !__int_fast8_t_defined
+#if __int_least8_t_defined
+  typedef int_least8_t int_fast8_t;
+  typedef uint_least8_t uint_fast8_t;
+#define __int_fast8_t_defined 1
+#endif
+#endif
+
+#if !__int_fast16_t_defined
+#if __int_least16_t_defined
+  typedef int_least16_t int_fast16_t;
+  typedef uint_least16_t uint_fast16_t;
+#define __int_fast16_t_defined 1
+#endif
+#endif
+
+#if !__int_fast32_t_defined
+#if __int_least32_t_defined
+  typedef int_least32_t int_fast32_t;
+  typedef uint_least32_t uint_fast32_t;
+#define __int_fast32_t_defined 1
+#endif
+#endif
+
+#if !__int_fast64_t_defined
+#if __int_least64_t_defined
+  typedef int_least64_t int_fast64_t;
+  typedef uint_least64_t uint_fast64_t;
+#define __int_fast64_t_defined 1
+#endif
+#endif
+
+/* Greatest-width integer types */
+/* Modern GCCs provide __INTMAX_TYPE__ */
+#if defined(__INTMAX_TYPE__)
+  typedef __INTMAX_TYPE__ intmax_t;
+#elif __have_longlong64
+  typedef signed long long intmax_t;
+#else
+  typedef signed long intmax_t;
+#endif
+
+/* Modern GCCs provide __UINTMAX_TYPE__ */
+#if defined(__UINTMAX_TYPE__)
+  typedef __UINTMAX_TYPE__ uintmax_t;
+#elif __have_longlong64
+  typedef unsigned long long uintmax_t;
+#else
+  typedef unsigned long uintmax_t;
+#endif
+
+/*
+ * GCC doesn't provide an appropriate macro for [u]intptr_t
+ * For now, use __PTRDIFF_TYPE__
+ */
+#if defined(__PTRDIFF_TYPE__)
+typedef signed __PTRDIFF_TYPE__ intptr_t;
+typedef unsigned __PTRDIFF_TYPE__ uintptr_t;
+#define INTPTR_MAX PTRDIFF_MAX
+#define INTPTR_MIN PTRDIFF_MIN
+#ifdef __UINTPTR_MAX__
+#define UINTPTR_MAX __UINTPTR_MAX__
+#else
+#define UINTPTR_MAX (2UL * PTRDIFF_MAX + 1)
+#endif
+#else
+/*
+ * Fallback to hardcoded values, 
+ * should be valid on cpu's with 32bit int/32bit void*
+ */
+typedef signed long intptr_t;
+typedef unsigned long uintptr_t;
+#define INTPTR_MAX __STDINT_EXP(LONG_MAX)
+#define INTPTR_MIN (-__STDINT_EXP(LONG_MAX) - 1)
+#define UINTPTR_MAX (__STDINT_EXP(LONG_MAX) * 2UL + 1)
+#endif
+
+/* Limits of Specified-Width Integer Types */
+
+#if __int8_t_defined
+#define INT8_MIN 	-128
+#define INT8_MAX 	 127
+#define UINT8_MAX 	 255
+#endif
+
+#if __int_least8_t_defined
+#define INT_LEAST8_MIN 	-128
+#define INT_LEAST8_MAX 	 127
+#define UINT_LEAST8_MAX	 255
+#else
+#error required type int_least8_t missing
+#endif
+
+#if __int16_t_defined
+#define INT16_MIN 	-32768
+#define INT16_MAX 	 32767
+#define UINT16_MAX 	 65535
+#endif
+
+#if __int_least16_t_defined
+#define INT_LEAST16_MIN	-32768
+#define INT_LEAST16_MAX	 32767
+#define UINT_LEAST16_MAX 65535
+#else
+#error required type int_least16_t missing
+#endif
+
+#if __int32_t_defined
+#if __have_long32
+#define INT32_MIN 	 (-2147483647L-1)
+#define INT32_MAX 	 2147483647L
+#define UINT32_MAX       4294967295UL
+#else
+#define INT32_MIN 	 (-2147483647-1)
+#define INT32_MAX 	 2147483647
+#define UINT32_MAX       4294967295U
+#endif
+#endif
+
+#if __int_least32_t_defined
+#if __have_long32
+#define INT_LEAST32_MIN  (-2147483647L-1)
+#define INT_LEAST32_MAX  2147483647L
+#define UINT_LEAST32_MAX 4294967295UL
+#else
+#define INT_LEAST32_MIN  (-2147483647-1)
+#define INT_LEAST32_MAX  2147483647
+#define UINT_LEAST32_MAX 4294967295U
+#endif
+#else
+#error required type int_least32_t missing
+#endif
+
+#if __int64_t_defined
+#if __have_long64
+#define INT64_MIN 	(-9223372036854775807L-1L)
+#define INT64_MAX 	 9223372036854775807L
+#define UINT64_MAX 	18446744073709551615U
+#elif __have_longlong64
+#define INT64_MIN 	(-9223372036854775807LL-1LL)
+#define INT64_MAX 	 9223372036854775807LL
+#define UINT64_MAX 	18446744073709551615ULL
+#endif
+#endif
+
+#if __int_least64_t_defined
+#if __have_long64
+#define INT_LEAST64_MIN  (-9223372036854775807L-1L)
+#define INT_LEAST64_MAX  9223372036854775807L
+#define UINT_LEAST64_MAX 18446744073709551615U
+#elif __have_longlong64
+#define INT_LEAST64_MIN  (-9223372036854775807LL-1LL)
+#define INT_LEAST64_MAX  9223372036854775807LL
+#define UINT_LEAST64_MAX 18446744073709551615ULL
+#endif
+#endif
+
+#if __int_fast8_t_defined
+#if __STDINT_EXP(INT_MAX) >= 0x7f
+#define INT_FAST8_MIN	(-__STDINT_EXP(INT_MAX)-1)
+#define INT_FAST8_MAX	__STDINT_EXP(INT_MAX)
+#define UINT_FAST8_MAX	(__STDINT_EXP(INT_MAX)*2U+1U)
+#else
+#define INT_FAST8_MIN	INT_LEAST8_MIN
+#define INT_FAST8_MAX	INT_LEAST8_MAX
+#define UINT_FAST8_MAX	UINT_LEAST8_MAX
+#endif
+#endif
+
+#if __int_fast16_t_defined
+#if __STDINT_EXP(INT_MAX) >= 0x7fff
+#define INT_FAST16_MIN	(-__STDINT_EXP(INT_MAX)-1)
+#define INT_FAST16_MAX	__STDINT_EXP(INT_MAX)
+#define UINT_FAST16_MAX	(__STDINT_EXP(INT_MAX)*2U+1U)
+#else
+#define INT_FAST16_MIN	INT_LEAST16_MIN
+#define INT_FAST16_MAX	INT_LEAST16_MAX
+#define UINT_FAST16_MAX	UINT_LEAST16_MAX
+#endif
+#endif
+
+#if __int_fast32_t_defined
+#if __STDINT_EXP(INT_MAX) >= 0x7fffffff
+#define INT_FAST32_MIN	(-__STDINT_EXP(INT_MAX)-1)
+#define INT_FAST32_MAX	__STDINT_EXP(INT_MAX)
+#define UINT_FAST32_MAX	(__STDINT_EXP(INT_MAX)*2U+1U)
+#else
+#define INT_FAST32_MIN	INT_LEAST32_MIN
+#define INT_FAST32_MAX	INT_LEAST32_MAX
+#define UINT_FAST32_MAX	UINT_LEAST32_MAX
+#endif
+#endif
+
+#if __int_fast64_t_defined
+#if __STDINT_EXP(INT_MAX) > 0x7fffffff
+#define INT_FAST64_MIN	(-__STDINT_EXP(INT_MAX)-1)
+#define INT_FAST64_MAX	__STDINT_EXP(INT_MAX)
+#define UINT_FAST64_MAX	(__STDINT_EXP(INT_MAX)*2U+1U)
+#else
+#define INT_FAST64_MIN	INT_LEAST64_MIN
+#define INT_FAST64_MAX	INT_LEAST64_MAX
+#define UINT_FAST64_MAX	UINT_LEAST64_MAX
+#endif
+#endif
+
+#ifdef __INTMAX_MAX__
+#define INTMAX_MAX __INTMAX_MAX__
+#define INTMAX_MIN (-INTMAX_MAX - 1)
+#elif defined(__INTMAX_TYPE__)
+/* All relevant GCC versions prefer long to long long for intmax_t.  */
+#define INTMAX_MAX INT64_MAX
+#define INTMAX_MIN INT64_MIN
+#endif
+
+#ifdef __UINTMAX_MAX__
+#define UINTMAX_MAX __UINTMAX_MAX__
+#elif defined(__UINTMAX_TYPE__)
+/* All relevant GCC versions prefer long to long long for intmax_t.  */
+#define UINTMAX_MAX UINT64_MAX
+#endif
+
+/* This must match size_t in stddef.h, currently long unsigned int */
+#ifdef __SIZE_MAX__
+#define SIZE_MAX __SIZE_MAX__
+#else
+#define SIZE_MAX (__STDINT_EXP(LONG_MAX) * 2UL + 1)
+#endif
+
+/* This must match sig_atomic_t in <signal.h> (currently int) */
+#define SIG_ATOMIC_MIN (-__STDINT_EXP(INT_MAX) - 1)
+#define SIG_ATOMIC_MAX __STDINT_EXP(INT_MAX)
+
+/* This must match ptrdiff_t  in <stddef.h> (currently long int) */
+#ifdef __PTRDIFF_MAX__
+#define PTRDIFF_MAX __PTRDIFF_MAX__
+#else
+#define PTRDIFF_MAX __STDINT_EXP(LONG_MAX)
+#endif
+#define PTRDIFF_MIN (-PTRDIFF_MAX - 1)
+
+#ifdef __WCHAR_MAX__
+#define WCHAR_MAX __WCHAR_MAX__
+#endif
+#ifdef __WCHAR_MIN__
+#define WCHAR_MIN __WCHAR_MIN__
+#endif
+
+/* wint_t is unsigned int on almost all GCC targets.  */
+#ifdef __WINT_MAX__
+#define WINT_MAX __WINT_MAX__
+#else
+#define WINT_MAX (__STDINT_EXP(INT_MAX) * 2U + 1U)
+#endif
+#ifdef __WINT_MIN__
+#define WINT_MIN __WINT_MIN__
+#else
+#define WINT_MIN 0U
+#endif
+
+/** Macros for minimum-width integer constant expressions */
+#define INT8_C(x)	x
+#if __STDINT_EXP(INT_MAX) > 0x7f
+#define UINT8_C(x)	x
+#else
+#define UINT8_C(x)	x##U
+#endif
+
+#define INT16_C(x)	x
+#if __STDINT_EXP(INT_MAX) > 0x7fff
+#define UINT16_C(x)	x
+#else
+#define UINT16_C(x)	x##U
+#endif
+
+#if __have_long32
+#define INT32_C(x)	x##L
+#define UINT32_C(x)	x##UL
+#else
+#define INT32_C(x)	x
+#define UINT32_C(x)	x##U
+#endif
+
+#if __int64_t_defined
+#if __have_long64
+#define INT64_C(x)	x##L
+#define UINT64_C(x)	x##UL
+#else
+#define INT64_C(x)	x##LL
+#define UINT64_C(x)	x##ULL
+#endif
+#endif
+
+/** Macros for greatest-width integer constant expression */
+#if __have_long64
+#define INTMAX_C(x)	x##L
+#define UINTMAX_C(x)	x##UL
+#else
+#define INTMAX_C(x)	x##LL
+#define UINTMAX_C(x)	x##ULL
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _STDINT_H */
diff --git a/msys/rt/src/newlib/libc/include/stdio.h b/msys/rt/src/newlib/libc/include/stdio.h
index 49087ca..5d5314b 100644
--- a/msys/rt/src/newlib/libc/include/stdio.h
+++ b/msys/rt/src/newlib/libc/include/stdio.h
@@ -66,10 +66,14 @@ typedef struct __sFILE FILE;
 #define	__SNPT	0x0800		/* do not do fseek() optimisation */
 #define	__SOFF	0x1000		/* set iff _offset is in fact correct */
 #define	__SMOD	0x2000		/* true => fgetline modified _p text */
+#define	__SORD	0x2000		/* true => stream orientation (byte/wide) decided */
 #if defined(__CYGWIN__) || defined(__MSYS__)
 #define __SCLE        0x4000          /* convert line endings CR/LF <-> NL */
 #endif
 
+/* _flags2 flags */
+#define __SWID  0x2000          /* true => stream orientation wide, false => byte, only valid if __SORD in _flags is true */
+
 /*
  * The following three definitions are for ANSI C, which took them
  * from System V, which stupidly took internal interface macros and
diff --git a/msys/rt/src/newlib/libc/include/sys/errno.h b/msys/rt/src/newlib/libc/include/sys/errno.h
index 5f7e532..0fee3e4 100644
--- a/msys/rt/src/newlib/libc/include/sys/errno.h
+++ b/msys/rt/src/newlib/libc/include/sys/errno.h
@@ -146,6 +146,7 @@ extern __IMPORT const int sys_nerr;
 #define ENOSHARE 136    /* No such host or network path */
 #define ECASECLASH 137  /* Filename exists with different case */
 #define EILSEQ 138
+#define EOVERFLOW 139	/* Value too large for defined data type */
 
 /* From cygwin32 and MSYS.  */
 #define EWOULDBLOCK EAGAIN	/* Operation would block */
diff --git a/msys/rt/src/newlib/libc/include/sys/lock.h b/msys/rt/src/newlib/libc/include/sys/lock.h
new file mode 100644
index 0000000..4afa1a0
--- /dev/null
+++ b/msys/rt/src/newlib/libc/include/sys/lock.h
@@ -0,0 +1,24 @@
+#ifndef __SYS_LOCK_H__
+#define __SYS_LOCK_H__
+
+/* dummy lock routines for single-threaded aps */
+
+typedef int _LOCK_T;
+typedef int _LOCK_RECURSIVE_T;
+
+#include <_ansi.h>
+
+#define __LOCK_INIT(class,lock) static int lock = 0;
+#define __LOCK_INIT_RECURSIVE(class,lock) static int lock = 0;
+#define __lock_init(lock) (_CAST_VOID 0)
+#define __lock_init_recursive(lock) (_CAST_VOID 0)
+#define __lock_close(lock) (_CAST_VOID 0)
+#define __lock_close_recursive(lock) (_CAST_VOID 0)
+#define __lock_acquire(lock) (_CAST_VOID 0)
+#define __lock_acquire_recursive(lock) (_CAST_VOID 0)
+#define __lock_try_acquire(lock) (_CAST_VOID 0)
+#define __lock_try_acquire_recursive(lock) (_CAST_VOID 0)
+#define __lock_release(lock) (_CAST_VOID 0)
+#define __lock_release_recursive(lock) (_CAST_VOID 0)
+
+#endif /* __SYS_LOCK_H__ */
diff --git a/msys/rt/src/newlib/libc/include/sys/reent.h b/msys/rt/src/newlib/libc/include/sys/reent.h
index a221385..3246d81 100644
--- a/msys/rt/src/newlib/libc/include/sys/reent.h
+++ b/msys/rt/src/newlib/libc/include/sys/reent.h
@@ -148,6 +148,9 @@ struct __sFILE {
   int	_offset;	/* current lseek offset */
 
   struct _reent *_data;
+
+  _mbstate_t _mbstate;  /* for wide char stdio functions. */
+  int   _flags2;        /* for future use */
 };
 
 typedef struct __sFILE   __FILE;
diff --git a/msys/rt/src/newlib/libc/include/sys/syslimits.h b/msys/rt/src/newlib/libc/include/sys/syslimits.h
new file mode 100644
index 0000000..ba9dbd6
--- /dev/null
+++ b/msys/rt/src/newlib/libc/include/sys/syslimits.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)syslimits.h	8.1 (Berkeley) 6/2/93
+ * $FreeBSD: src/sys/sys/syslimits.h,v 1.10 2001/06/18 20:24:54 wollman Exp $
+ */
+
+#ifndef _SYS_SYSLIMITS_H_
+#define _SYS_SYSLIMITS_H_
+
+#define	ARG_MAX			65536	/* max bytes for an exec function */
+#ifndef CHILD_MAX
+#define	CHILD_MAX		   40	/* max simultaneous processes */
+#endif
+#define	LINK_MAX		32767	/* max file link count */
+#define	MAX_CANON		  255	/* max bytes in term canon input line */
+#define	MAX_INPUT		  255	/* max bytes in terminal input */
+#define	NAME_MAX		  255	/* max bytes in a file name */
+#define	NGROUPS_MAX		   16	/* max supplemental group id's */
+#ifndef OPEN_MAX
+#define	OPEN_MAX		   64	/* max open files per process */
+#endif
+#define	PATH_MAX		 1024	/* max bytes in pathname */
+#define	PIPE_BUF		  512	/* max bytes for atomic pipe writes */
+#define	IOV_MAX			 1024	/* max elements in i/o vector */
+
+#define	BC_BASE_MAX		   99	/* max ibase/obase values in bc(1) */
+#define	BC_DIM_MAX		 2048	/* max array elements in bc(1) */
+#define	BC_SCALE_MAX		   99	/* max scale value in bc(1) */
+#define	BC_STRING_MAX		 1000	/* max const string length in bc(1) */
+#define	COLL_WEIGHTS_MAX	    0	/* max weights for order keyword */
+#define	EXPR_NEST_MAX		   32	/* max expressions nested in expr(1) */
+#define	LINE_MAX		 2048	/* max bytes in an input line */
+#define	RE_DUP_MAX		  255	/* max RE's in interval notation */
+
+#endif
diff --git a/msys/rt/src/newlib/libc/include/sys/types.h b/msys/rt/src/newlib/libc/include/sys/types.h
index 81a11c7..5ea0fdd 100644
--- a/msys/rt/src/newlib/libc/include/sys/types.h
+++ b/msys/rt/src/newlib/libc/include/sys/types.h
@@ -103,13 +103,21 @@ typedef unsigned long vm_size_t;
 
 #define __BIT_TYPES_DEFINED__
 
-typedef char int8_t;
+#ifndef  __int8_t_defined
+ typedef char int8_t;
+#endif
 typedef unsigned char u_int8_t;
-typedef short int16_t;
+#ifndef  __int16_t_defined
+ typedef short int16_t;
+#endif
 typedef unsigned short u_int16_t;
-typedef int int32_t;
+#ifndef  __int32_t_defined
+ typedef int int32_t;
+#endif
 typedef unsigned int u_int32_t;
-typedef long long int64_t;
+#ifndef __int64_t_defined
+ typedef long long int64_t;
+#endif
 typedef unsigned long long u_int64_t;
 typedef int32_t register_t;
 #endif /* __MS_types__ */
diff --git a/msys/rt/src/newlib/libc/include/time.h b/msys/rt/src/newlib/libc/include/time.h
index 999ddc2..5f34676 100644
--- a/msys/rt/src/newlib/libc/include/time.h
+++ b/msys/rt/src/newlib/libc/include/time.h
@@ -61,6 +61,26 @@ char	  *_EXFUN(ctime_r,	(const time_t *, char *));
 struct tm *_EXFUN(gmtime_r,	(const time_t *, struct tm *));
 struct tm *_EXFUN(localtime_r,	(const time_t *, struct tm *));
 
+typedef struct __tzrule_struct
+{
+  char ch;
+  int m;
+  int n;
+  int d;
+  int s;
+  time_t change;
+  long offset; /* Match type of _timezone. */
+} __tzrule_type;
+
+typedef struct __tzinfo_struct
+{
+  int __tznorth;
+  int __tzyear;
+  __tzrule_type __tzrule[2];
+} __tzinfo_type;
+
+__tzinfo_type *_EXFUN (__gettzinfo, (_VOID));
+
 #if defined(__CYGWIN__) || defined(__MSYS__)
 #ifndef __STRICT_ANSI__
 extern __IMPORT time_t _timezone;
diff --git a/msys/rt/src/newlib/libc/locale/Makefile.in b/msys/rt/src/newlib/libc/locale/Makefile.in
index 1d951a8..fe139e2 100644
--- a/msys/rt/src/newlib/libc/locale/Makefile.in
+++ b/msys/rt/src/newlib/libc/locale/Makefile.in
@@ -88,9 +88,9 @@ INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS)
 
 noinst_LIBRARIES = lib.a
 
-lib_a_SOURCES = locale.c
+lib_a_SOURCES = locale.c timelocal.c ldpart.c
 
-CHEWOUT_FILES = locale.def
+CHEWOUT_FILES = locale.def timelocal.def ldpart.def
 
 SUFFIXES = .def
 
@@ -109,7 +109,7 @@ CPPFLAGS = @CPPFLAGS@
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
 lib_a_LIBADD = 
-lib_a_OBJECTS =  locale.o
+lib_a_OBJECTS =  locale.o timelocal.o ldpart.o
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
diff --git a/msys/rt/src/newlib/libc/locale/lctype.h b/msys/rt/src/newlib/libc/locale/lctype.h
new file mode 100644
index 0000000..663074f
--- /dev/null
+++ b/msys/rt/src/newlib/libc/locale/lctype.h
@@ -0,0 +1,47 @@
+/*
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _LCTYPE_H_
+#define	_LCTYPE_H_
+
+#include <_ansi.h>
+#include <sys/cdefs.h>
+#include <wchar.h>
+
+__BEGIN_DECLS
+
+struct lc_ctype_T {
+	const char	*codeset;	 /* codeset for mbtowc conversion */
+	const char	*mb_cur_max;
+#ifdef __HAVE_LOCALE_INFO_EXTENDED__
+	const char	*outdigits[10];
+	const wchar_t	*woutdigits[10];
+#endif
+};
+
+struct lc_ctype_T *__get_current_ctype_locale(void);
+int	__ctype_load_locale(const char *, void *, const char *, int);
+
+__END_DECLS
+
+#endif /* !_LCTYPE_H_ */
diff --git a/msys/rt/src/newlib/libc/locale/ldpart.c b/msys/rt/src/newlib/libc/locale/ldpart.c
new file mode 100644
index 0000000..5955322
--- /dev/null
+++ b/msys/rt/src/newlib/libc/locale/ldpart.c
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2000, 2001 Alexey Zelkin <phantom@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/syslimits.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "setlocale.h"
+#include "ldpart.h"
+
+static int split_lines(char *, const char *);
+static void set_from_buf(const char *, int, const char **);
+
+int
+__part_load_locale(const char *name,
+		int *using_locale,
+		char *locale_buf,
+		const char *category_filename,
+		int locale_buf_size_max,
+		int locale_buf_size_min,
+		const char **dst_localebuf) {
+
+	static char		locale_buf_C[] = "C";
+	static int		num_lines;
+
+	int			 fd;
+	char			*lbuf;
+	char			*p;
+	const char 		*plim;
+	char                     filename[PATH_MAX];
+#ifdef __USE_INTERNAL_STAT64
+	struct stat64		 st;
+#else
+	struct stat		 st;
+#endif
+	size_t			 namesize;
+	size_t			 bufsize;
+	int                      save_using_locale;
+        char *nptr;
+
+	save_using_locale = *using_locale;
+	*using_locale = 0;
+
+	if (name == NULL)
+		goto no_locale;
+
+	if (!strcmp(name, "C") || !strcmp(name, "POSIX"))
+		return 0;
+
+	/*
+	 * If the locale name is the same as our cache, use the cache.
+	 */
+	lbuf = locale_buf;
+	if (lbuf != NULL && strcmp(name, lbuf) == 0) {
+		set_from_buf(lbuf, num_lines, dst_localebuf);
+		*using_locale = 1;
+		return 0;
+	}
+
+	/*
+	 * Slurp the locale file into the cache.
+	 */
+	namesize = strlen(name) + 1;
+
+	if (!_PathLocale)
+		goto no_locale;
+	/* Range checking not needed, 'name' size is limited */
+	strcpy(filename, _PathLocale);
+	strcat(filename, "/");
+	strcat(filename, name);
+	strcat(filename, "/");
+	strcat(filename, category_filename);
+	fd = open(filename, O_RDONLY);
+	if (fd < 0)
+		goto no_locale;
+#ifdef __USE_INTERNAL_STAT64
+	if (fstat64(fd, &st) != 0)
+#else
+	if (fstat(fd, &st) != 0)
+#endif
+		goto bad_locale;
+	if (st.st_size <= 0)
+		goto bad_locale;
+	bufsize = namesize + st.st_size;
+	locale_buf = NULL;
+
+        if (lbuf == NULL || lbuf == locale_buf_C)
+          {
+            lbuf = malloc(bufsize);
+          }
+        else
+          { 
+            nptr = realloc(lbuf, bufsize);
+            if (!nptr && lbuf)
+              free (lbuf);
+            lbuf = nptr;
+          }
+
+	if (lbuf == NULL)
+		goto bad_locale;
+	(void) strcpy(lbuf, name);
+	p = lbuf + namesize;
+	plim = p + st.st_size;
+	if (read(fd, p, (size_t) st.st_size) != st.st_size)
+		goto bad_lbuf;
+	if (close(fd) != 0)
+		goto bad_lbuf;
+	/*
+	 * Parse the locale file into localebuf.
+	 */
+	if (plim[-1] != '\n')
+		goto bad_lbuf;
+	num_lines = split_lines(p, plim);
+	if (num_lines >= locale_buf_size_max)
+		num_lines = locale_buf_size_max;
+	else if (num_lines >= locale_buf_size_min)
+		num_lines = locale_buf_size_min;
+	else
+		goto reset_locale;
+	set_from_buf(lbuf, num_lines, dst_localebuf);
+	/*
+	 * Record the successful parse in the cache.
+	 */
+	locale_buf = lbuf;
+
+	*using_locale = 1;
+	return 0;
+
+reset_locale:
+	locale_buf = locale_buf_C;
+	save_using_locale = 0;
+bad_lbuf:
+	free(lbuf);
+bad_locale:
+	(void)close(fd);
+no_locale:
+	*using_locale = save_using_locale;
+	return -1;
+}
+
+static int
+split_lines(char *p, const char *plim) {
+
+	int i;
+
+	for (i = 0; p < plim; i++) {
+		p = strchr(p, '\n');
+		*p++ = '\0';
+	}
+	return i;
+}
+
+static void
+set_from_buf(const char *p, int num_lines, const char **dst_localebuf) {
+
+	const char **ap;
+	int i;
+
+	for (ap = dst_localebuf, i = 0; i < num_lines; ++ap, ++i)
+		*ap = p += strlen(p) + 1;
+}
+
diff --git a/msys/rt/src/newlib/libc/locale/ldpart.h b/msys/rt/src/newlib/libc/locale/ldpart.h
new file mode 100644
index 0000000..86031fd
--- /dev/null
+++ b/msys/rt/src/newlib/libc/locale/ldpart.h
@@ -0,0 +1,35 @@
+/*-
+ * Copyright (c) 2000, 2001 Alexey Zelkin <phantom@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/libc/locale/ldpart.h,v 1.4 2001/12/20 18:28:52 phantom Exp $
+ */
+
+#ifndef _LDPART_H_
+#define	_LDPART_H_
+
+int	__part_load_locale(const char *, int*, char *, const char *,
+		    int, int, const char **);
+
+#endif /* !_LDPART_H_ */
diff --git a/msys/rt/src/newlib/libc/locale/lmessages.h b/msys/rt/src/newlib/libc/locale/lmessages.h
new file mode 100644
index 0000000..079895d
--- /dev/null
+++ b/msys/rt/src/newlib/libc/locale/lmessages.h
@@ -0,0 +1,57 @@
+/*-
+ * Copyright (c) 2000, 2001 Alexey Zelkin <phantom@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/libc/locale/lmessages.h,v 1.3 2001/12/20 18:28:52 phantom Exp $
+ */
+
+#ifndef _LMESSAGES_H_
+#define	_LMESSAGES_H_
+
+#include <_ansi.h>
+#include <sys/cdefs.h>
+#include <wchar.h>
+
+__BEGIN_DECLS
+
+struct	lc_messages_T {
+	const char	*yesexpr;
+	const char	*noexpr;
+	const char	*yesstr;
+	const char	*nostr;
+#ifdef __HAVE_LOCALE_INFO_EXTENDED__
+	const char	*codeset;	 /* codeset for mbtowc conversion */
+	const wchar_t	*wyesexpr;
+	const wchar_t	*wnoexpr;
+	const wchar_t	*wyesstr;
+	const wchar_t	*wnostr;
+#endif
+};
+
+struct lc_messages_T *__get_current_messages_locale(void);
+int __messages_load_locale(const char *, void *, const char *);
+
+__END_DECLS
+
+#endif /* !_LMESSAGES_H_ */
diff --git a/msys/rt/src/newlib/libc/locale/lmonetary.h b/msys/rt/src/newlib/libc/locale/lmonetary.h
new file mode 100644
index 0000000..7aa21e2
--- /dev/null
+++ b/msys/rt/src/newlib/libc/locale/lmonetary.h
@@ -0,0 +1,76 @@
+/*-
+ * Copyright (c) 2000, 2001 Alexey Zelkin <phantom@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/libc/locale/lmonetary.h,v 1.3 2001/12/20 18:28:52 phantom Exp $
+ */
+
+#ifndef _LMONETARY_H_
+#define	_LMONETARY_H_
+
+#include <_ansi.h>
+#include <sys/cdefs.h>
+#include <wchar.h>
+
+__BEGIN_DECLS
+
+struct lc_monetary_T {
+	const char	*int_curr_symbol;
+	const char	*currency_symbol;
+	const char	*mon_decimal_point;
+	const char	*mon_thousands_sep;
+	const char	*mon_grouping;
+	const char	*positive_sign;
+	const char	*negative_sign;
+	const char	*int_frac_digits;
+	const char	*frac_digits;
+	const char	*p_cs_precedes;
+	const char	*p_sep_by_space;
+	const char	*n_cs_precedes;
+	const char	*n_sep_by_space;
+	const char	*p_sign_posn;
+	const char	*n_sign_posn;
+#ifdef __HAVE_LOCALE_INFO_EXTENDED__
+	const char	*int_p_cs_precedes;
+	const char	*int_p_sep_by_space;
+	const char	*int_n_cs_precedes;
+	const char	*int_n_sep_by_space;
+	const char	*int_p_sign_posn;
+	const char	*int_n_sign_posn;
+	const char	*codeset;	 /* codeset for mbtowc conversion */
+	const wchar_t	*wint_curr_symbol;
+	const wchar_t	*wcurrency_symbol;
+	const wchar_t	*wmon_decimal_point;
+	const wchar_t	*wmon_thousands_sep;
+	const wchar_t	*wpositive_sign;
+	const wchar_t	*wnegative_sign;
+#endif
+};
+
+struct lc_monetary_T *__get_current_monetary_locale(void);
+int	__monetary_load_locale(const char *, void *, const char *);
+
+__END_DECLS
+
+#endif /* !_LMONETARY_H_ */
diff --git a/msys/rt/src/newlib/libc/locale/lnumeric.h b/msys/rt/src/newlib/libc/locale/lnumeric.h
new file mode 100644
index 0000000..2bd7d97
--- /dev/null
+++ b/msys/rt/src/newlib/libc/locale/lnumeric.h
@@ -0,0 +1,54 @@
+/*-
+ * Copyright (c) 2000, 2001 Alexey Zelkin <phantom@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/libc/locale/lnumeric.h,v 1.3 2001/12/20 18:28:52 phantom Exp $
+ */
+
+#ifndef _LNUMERIC_H_
+#define	_LNUMERIC_H_
+
+#include <_ansi.h>
+#include <sys/cdefs.h>
+#include <wchar.h>
+
+__BEGIN_DECLS
+
+struct lc_numeric_T {
+	const char	*decimal_point;
+	const char	*thousands_sep;
+	const char	*grouping;
+#ifdef __HAVE_LOCALE_INFO_EXTENDED__
+	const char	*codeset;	 /* codeset for mbtowc conversion */
+	const wchar_t	*wdecimal_point;
+	const wchar_t	*wthousands_sep;
+#endif
+};
+
+struct lc_numeric_T *__get_current_numeric_locale(void);
+int	__numeric_load_locale(const char *, void *, const char *);
+
+__END_DECLS
+
+#endif /* !_LNUMERIC_H_ */
diff --git a/msys/rt/src/newlib/libc/locale/locale.c b/msys/rt/src/newlib/libc/locale/locale.c
index 7464517..644b5d7 100644
--- a/msys/rt/src/newlib/libc/locale/locale.c
+++ b/msys/rt/src/newlib/libc/locale/locale.c
@@ -98,6 +98,8 @@ int __declspec(dllexport) __mb_cur_max = MB_UTF8_MAX;
 int __mb_cur_max = MB_UTF8_MAX;
 #endif
 
+char *_PathLocale = NULL;
+
 static _CONST struct lconv lconv = 
 {
   ".", "", "", "", "", "", "", "", "", "",
diff --git a/msys/rt/src/newlib/libc/locale/setlocale.h b/msys/rt/src/newlib/libc/locale/setlocale.h
new file mode 100644
index 0000000..3eb7698
--- /dev/null
+++ b/msys/rt/src/newlib/libc/locale/setlocale.h
@@ -0,0 +1,37 @@
+/*-
+ * Copyright (C) 1997 by Andrey A. Chernov, Moscow, Russia.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/libc/locale/setlocale.h,v 1.4 2001/12/20 18:28:52 phantom Exp $
+ */
+
+#ifndef _SETLOCALE_H_
+#define	_SETLOCALE_H_
+
+#define ENCODING_LEN 31
+#define CATEGORY_LEN 11
+
+extern char *_PathLocale;
+
+#endif /* !_SETLOCALE_H_ */
diff --git a/msys/rt/src/newlib/libc/locale/timelocal.c b/msys/rt/src/newlib/libc/locale/timelocal.c
new file mode 100644
index 0000000..4dcaa34
--- /dev/null
+++ b/msys/rt/src/newlib/libc/locale/timelocal.c
@@ -0,0 +1,188 @@
+/*-
+ * Copyright (c) 2001 Alexey Zelkin <phantom@FreeBSD.org>
+ * Copyright (c) 1997 FreeBSD Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+
+#include <stddef.h>
+
+#include "ldpart.h"
+#include "timelocal.h"
+
+static struct lc_time_T _time_locale;
+static int _time_using_locale;
+static char *time_locale_buf;
+
+#define LCTIME_SIZE (sizeof(struct lc_time_T) / sizeof(char *))
+
+static const struct lc_time_T	_C_time_locale = {
+	{
+		"Jan", "Feb", "Mar", "Apr", "May", "Jun",
+		"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+	}, {
+		"January", "February", "March", "April", "May", "June",
+		"July", "August", "September", "October", "November", "December"
+	}, {
+		"Sun", "Mon", "Tue", "Wed",
+		"Thu", "Fri", "Sat"
+	}, {
+		"Sunday", "Monday", "Tuesday", "Wednesday",
+		"Thursday", "Friday", "Saturday"
+	},
+
+	/* X_fmt */
+	"%H:%M:%S",
+
+	/*
+	 * x_fmt
+	 * Since the C language standard calls for
+	 * "date, using locale's date format," anything goes.
+	 * Using just numbers (as here) makes Quakers happier;
+	 * it's also compatible with SVR4.
+	 */
+	"%m/%d/%y",
+
+	/*
+	 * c_fmt
+	 */
+	"%a %b %e %H:%M:%S %Y",
+
+	/* am pm */
+	{ "AM", "PM" },
+
+	/* date_fmt */
+	"%a %b %e %H:%M:%S %Z %Y",
+	
+	/* alt_month
+	 * Standalone months forms for %OB
+	 */
+	{
+		"January", "February", "March", "April", "May", "June",
+		"July", "August", "September", "October", "November", "December"
+	},
+
+	/* md_order
+	 * Month / day order in dates
+	 */
+	"md",
+
+	/* ampm_fmt
+	 * To determine 12-hour clock format time (empty, if N/A)
+	 */
+	"%I:%M:%S %p",
+
+	/* era
+	 * Era.  This and the following entries are used if the alternative
+	 * date format is specified in strftime
+	 */
+	"",
+
+	/* era_d_fmt
+	 * Era date format used with the %Ex
+	 */
+	"",
+
+	/* era_d_t_fmt
+	 * Era date/time format (%Ec)
+	 */
+	"",
+
+	/* era_t_fmt
+	 * Era time format (%EX)
+	 */
+	"",
+
+	/* alt_digits
+	 * Alternate digits used if %O format prefix is specified
+	 */
+	""
+#ifdef __HAVE_LOCALE_INFO_EXTENDED__
+	, "ASCII",	/* codeset */
+	{
+		L"Jan", L"Feb", L"Mar", L"Apr", L"May", L"Jun",
+		L"Jul", L"Aug", L"Sep", L"Oct", L"Nov", L"Dec"
+	}, {
+		L"January", L"February", L"March", L"April", L"May", L"June",
+		L"July", L"August", L"September", L"October", L"November",
+		L"December"
+	}, {
+		L"Sun", L"Mon", L"Tue", L"Wed",
+		L"Thu", L"Fri", L"Sat"
+	}, {
+		L"Sunday", L"Monday", L"Tuesday", L"Wednesday",
+		L"Thursday", L"Friday", L"Saturday"
+	},
+	L"%H:%M:%S",
+	L"%m/%d/%y",
+	L"%a %b %e %H:%M:%S %Y",
+	{ L"AM", L"PM" },
+	L"%a %b %e %H:%M:%S %Z %Y",
+	L"%I:%M:%S %p",
+	L"",
+	L"",
+	L"",
+	L"",
+	L""
+#endif
+};
+
+struct lc_time_T *
+__get_current_time_locale(void) {
+	return (_time_using_locale
+		? &_time_locale
+		: (struct lc_time_T *)&_C_time_locale);
+}
+
+int
+__time_load_locale(const char *name, void *f_wctomb, const char *charset) {
+
+	int	ret;
+
+#if defined __CYGWIN__ && !defined __MSYS__
+	extern int __set_lc_time_from_win (const char *,
+					   const struct lc_time_T *,
+					   struct lc_time_T *,
+					   char **, void *, const char *);
+	int old_time_using_locale = _time_using_locale;
+	_time_using_locale = 0;
+	ret = __set_lc_time_from_win (name, &_C_time_locale, &_time_locale,
+				      &time_locale_buf, f_wctomb, charset);
+	/* ret == -1: error, ret == 0: C/POSIX, ret > 0: valid */
+	if (ret < 0)
+	  _time_using_locale = old_time_using_locale;
+	else
+	  {
+	    _time_using_locale = ret;
+	    ret = 0;
+	  }
+#else
+	ret = __part_load_locale(name, &_time_using_locale,
+			time_locale_buf, "LC_TIME",
+			LCTIME_SIZE, LCTIME_SIZE,
+			(const char **)&_time_locale);
+#endif
+	return (ret);
+}
diff --git a/msys/rt/src/newlib/libc/locale/timelocal.h b/msys/rt/src/newlib/libc/locale/timelocal.h
new file mode 100644
index 0000000..a0c1ef7
--- /dev/null
+++ b/msys/rt/src/newlib/libc/locale/timelocal.h
@@ -0,0 +1,85 @@
+/*-
+ * Copyright (c) 1997-2002 FreeBSD Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/libc/stdtime/timelocal.h,v 1.11 2002/01/24 15:07:44 phantom Exp $
+ */
+
+#ifndef _TIMELOCAL_H_
+#define	_TIMELOCAL_H_
+
+#include <_ansi.h>
+#include <sys/cdefs.h>
+#include <wchar.h>
+
+__BEGIN_DECLS
+
+/*
+ * Private header file for the strftime and strptime localization
+ * stuff.
+ */
+struct lc_time_T {
+	const char	*mon[12];
+	const char	*month[12];
+	const char	*wday[7];
+	const char	*weekday[7];
+	const char	*X_fmt;
+	const char	*x_fmt;
+	const char	*c_fmt;
+	const char	*am_pm[2];
+	const char	*date_fmt;
+	const char	*alt_month[12];	/* unused */
+	const char	*md_order;
+	const char	*ampm_fmt;
+	const char	*era;
+	const char	*era_d_fmt;
+	const char	*era_d_t_fmt;
+	const char	*era_t_fmt;
+	const char	*alt_digits;
+#ifdef __HAVE_LOCALE_INFO_EXTENDED__
+	const char	*codeset;	 /* codeset for mbtowc conversion */
+	const wchar_t	*wmon[12];
+	const wchar_t	*wmonth[12];
+	const wchar_t	*wwday[7];
+	const wchar_t	*wweekday[7];
+	const wchar_t	*wX_fmt;
+	const wchar_t	*wx_fmt;
+	const wchar_t	*wc_fmt;
+	const wchar_t	*wam_pm[2];
+	const wchar_t	*wdate_fmt;
+	const wchar_t	*wampm_fmt;
+	const wchar_t	*wera;
+	const wchar_t	*wera_d_fmt;
+	const wchar_t	*wera_d_t_fmt;
+	const wchar_t	*wera_t_fmt;
+	const wchar_t	*walt_digits;
+#endif
+};
+
+struct lc_time_T *__get_current_time_locale(void);
+int	__time_load_locale(const char *, void *, const char *);
+
+__END_DECLS
+
+#endif /* !_TIMELOCAL_H_ */
diff --git a/msys/rt/src/newlib/libc/reent/readr.c b/msys/rt/src/newlib/libc/reent/readr.c
index e3deca9..5b38a9d 100644
--- a/msys/rt/src/newlib/libc/reent/readr.c
+++ b/msys/rt/src/newlib/libc/reent/readr.c
@@ -45,14 +45,14 @@ DESCRIPTION
 	<<errno>>.
 */
 
-long
+_ssize_t
 _read_r (ptr, fd, buf, cnt)
      struct _reent *ptr;
      int fd;
      _PTR buf;
      size_t cnt;
 {
-  long ret;
+  _ssize_t ret;
 
   errno = 0;
   if ((ret = _read (fd, buf, cnt)) == -1 && errno != 0)
diff --git a/msys/rt/src/newlib/libc/reent/writer.c b/msys/rt/src/newlib/libc/reent/writer.c
index ac10286..9b0cd8a 100644
--- a/msys/rt/src/newlib/libc/reent/writer.c
+++ b/msys/rt/src/newlib/libc/reent/writer.c
@@ -45,14 +45,14 @@ DESCRIPTION
 	<<errno>>.
 */
 
-long
+_ssize_t
 _write_r (ptr, fd, buf, cnt)
      struct _reent *ptr;
      int fd;
      _CONST _PTR buf;
      size_t cnt;
 {
-  long ret;
+  _ssize_t ret;
 
   errno = 0;
   if ((ret = _write (fd, buf, cnt)) == -1 && errno != 0)
diff --git a/msys/rt/src/newlib/libc/stdio/Makefile.am b/msys/rt/src/newlib/libc/stdio/Makefile.am
index fd7a586..d69fbb9 100644
--- a/msys/rt/src/newlib/libc/stdio/Makefile.am
+++ b/msys/rt/src/newlib/libc/stdio/Makefile.am
@@ -70,7 +70,21 @@ lib_a_SOURCES = \
 	vsprintf.c 			\
 	vsscanf.c			\
 	wbuf.c 				\
-	wsetup.c 
+	wsetup.c			\
+	fgetwc.c			\
+	fgetws.c			\
+	fputwc.c			\
+	fputws.c			\
+	fwide.c				\
+	getwc.c				\
+	getwchar.c			\
+	putwc.c				\
+	putwchar.c			\
+	ungetwc.c			\
+	swprintf.c			\
+	sniprintf.c			\
+	vfwprintf.c
+
 
 lib_a_LIBADD = vfiprintf.o
 
@@ -120,7 +134,20 @@ CHEWOUT_FILES = \
 	tmpfile.def		\
 	tmpnam.def		\
 	vfprintf.def		\
-	vfscanf.def
+	vfscanf.def             \
+	fgetwc.def		\
+	fgetws.def		\
+	fputwc.def		\
+	fputws.def		\
+	fwide.def		\
+	getwc.def		\
+	getwchar.def	\
+	putwc.def		\
+	putwchar.def	\
+	ungetwc.def		\
+	swprintf.def	\
+	sniprintf.def	\
+	vfwprintf.def
 
 SUFFIXES = .def
 
@@ -168,3 +195,16 @@ vscanf.o: local.h
 vsscanf.o: local.h
 wbuf.o: local.h fvwrite.h
 wsetup.o: local.h
+fgetwc.o: local.h
+fgetws.o: local.h
+fputwc.o: local.h
+fputws.o: local.h fvwrite.h
+fwide.o: local.h
+getwc.o: local.h
+getwchar.o: local.h
+putwc.o: local.h
+putwchar.o: local.h
+ungetwc.o: local.h
+swprintf.o: local.h
+sniprintf.o: local.h
+vfwprint.o: local.h
diff --git a/msys/rt/src/newlib/libc/stdio/Makefile.in b/msys/rt/src/newlib/libc/stdio/Makefile.in
index f034323..75c63af 100644
--- a/msys/rt/src/newlib/libc/stdio/Makefile.in
+++ b/msys/rt/src/newlib/libc/stdio/Makefile.in
@@ -152,10 +152,23 @@ lib_a_SOURCES = \
 	vsprintf.c 			\
 	vsscanf.c			\
 	wbuf.c 				\
-	wsetup.c 
-
-
-lib_a_LIBADD = vfiprintf.o
+	wsetup.c			\
+	fgetwc.c			\
+	fgetws.c			\
+	fputwc.c			\
+	fputws.c			\
+	fwide.c				\
+	getwc.c				\
+	getwchar.c			\
+	putwc.c				\
+	putwchar.c			\
+	ungetwc.c			\
+	swprintf.c			\
+	sniprintf.c			\
+	vfwprintf.c
+
+
+lib_a_LIBADD = vfiprintf.o svfprintf.o svfiprintf.o vfiwprintf.o svfwprintf.o svfiwprintf.o
 
 CHEWOUT_FILES = \
 	clearerr.def		\
@@ -199,8 +212,22 @@ CHEWOUT_FILES = \
 	sscanf.def		\
 	tmpfile.def		\
 	tmpnam.def		\
-	vfprintf.def		\
-	vfscanf.def
+	vfprintf.def	\
+	vfscanf.def		\
+	fgetwc.def		\
+	fgetws.def		\
+	fputwc.def		\
+	fputws.def		\
+	fwide.def		\
+	getwc.def		\
+	getwchar.def	\
+	putwc.def		\
+	putwchar.def	\
+	ungetwc.def		\
+	swprintf.def	\
+	sniprintf.def	\
+	vfwprintf.def
+
 
 
 SUFFIXES = .def
@@ -219,7 +246,8 @@ DEFS = @DEFS@ -I. -I$(srcdir)
 CPPFLAGS = @CPPFLAGS@
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
-lib_a_DEPENDENCIES =  vfiprintf.o
+lib_a_DEPENDENCIES =  vfiprintf.o svfprintf.o svfiprintf.o vfiwprintf.o \
+svfwprintf.o svfiwprintf.o
 lib_a_OBJECTS =  clearerr.o fclose.o fdopen.o feof.o ferror.o fflush.o \
 fgetc.o fgetpos.o fgets.o fileno.o findfp.o fiprintf.o flags.o fopen.o \
 fprintf.o fputc.o fputs.o fread.o freopen.o fscanf.o fseek.o fsetpos.o \
@@ -228,7 +256,9 @@ iprintf.o makebuf.o mktemp.o perror.o printf.o putc.o putchar.o puts.o \
 putw.o refill.o remove.o rename.o rewind.o rget.o scanf.o setbuf.o \
 setvbuf.o siprintf.o snprintf.o sprintf.o sscanf.o stdio.o tmpfile.o \
 tmpnam.o ungetc.o vfprintf.o vfscanf.o vprintf.o vscanf.o vsnprintf.o \
-vsprintf.o vsscanf.o wbuf.o wsetup.o
+vsprintf.o vsscanf.o wbuf.o wsetup.o fgetwc.o fgetws.o fputwc.o \
+fputws.o fwide.o getwc.o getwchar.o putwc.o putwchar.o ungetwc.o \
+swprintf.o sniprintf.o vfwprintf.o
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
@@ -404,9 +434,46 @@ mostlyclean-generic distclean-generic clean-generic \
 maintainer-clean-generic clean mostlyclean distclean maintainer-clean
 
 
+.c.def:
+	$(CHEW) < $< > $*.def 2> $*.ref
+	touch stmp-def
+
+doc: $(CHEWOUT_FILES)
+	cat $(srcdir)/stdio.tex >> $(TARGETDOC)
+
+fclose.o: local.h
+fdopen.o: local.h
+fflush.o: local.h
+findfp.o: local.h
+fopen.o: local.h
+fputs.o: fvwrite.h
+fread.o: local.h
+freopen.o: local.h
+fseek.o: local.h
+ftell.o: local.h
+fvwrite.o: local.h fvwrite.h
+fwalk.o: local.h
+
+
 vfiprintf.o: vfprintf.c
 	$(COMPILE) -DINTEGER_ONLY -c $(srcdir)/vfprintf.c -o $@
 
+svfprintf.o: vfprintf.c
+	$(COMPILE) -DSTRING_ONLY -c $(srcdir)/vfprintf.c -o $@
+
+svfiprintf.o: vfprintf.c
+	$(COMPILE) -DINTEGER_ONLY -DSTRING_ONLY -c $(srcdir)/vfprintf.c -o $@
+
+vfiwprintf.o: vfprintf.c
+	$(COMPILE) -DINTEGER_ONLY -c $(srcdir)/vfwprintf.c -o $@
+
+svfwprintf.o: vfprintf.c
+	$(COMPILE) -DSTRING_ONLY -c $(srcdir)/vfwprintf.c -o $@
+
+svfiwprintf.o: vfprintf.c
+	$(COMPILE) -DINTEGER_ONLY -DSTRING_ONLY -c $(srcdir)/vfwprintf.c -o $@
+
+
 .c.def:
 	$(CHEW) < $< > $*.def 2> $*.ref
 	touch stmp-def
@@ -439,12 +506,32 @@ sscanf.o: local.h
 stdio.o: local.h
 ungetc.o: local.h
 vfiprintf.o: local.h
+svfprintf.o: local.h
+svfiprintf.o: local.h
+vfiwprintf.o: local.h
+svfwprintf.o: local.h
+svfiwprintf.o: local.h
 vfprintf.o: local.h
 vfscanf.o: local.h floatio.h
 vscanf.o: local.h
 vsscanf.o: local.h
 wbuf.o: local.h fvwrite.h
 wsetup.o: local.h
+fgetwc.o: local.h
+fgetws.o: local.h
+fputwc.o: local.h
+fputws.o: local.h fvwrite.h
+fwide.o: local.h
+getwc.o: local.h
+getwchar.o: local.h
+putwc.o: local.h
+putwchar.o: local.h
+ungetwc.o: local.h
+swprintf.o: local.h
+sniprintf.o: local.h
+vfwprint.o: local.h
+
+
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff --git a/msys/rt/src/newlib/libc/stdio/fgetwc.c b/msys/rt/src/newlib/libc/stdio/fgetwc.c
new file mode 100644
index 0000000..3a3884f
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/fgetwc.c
@@ -0,0 +1,180 @@
+/*-
+ * Copyright (c) 2002-2004 Tim J. Robbins.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+FUNCTION
+<<fgetwc>>, <<getwc>>---get a wide character from a file or stream
+
+INDEX
+	fgetwc
+INDEX
+	_fgetwc_r
+INDEX
+	getwc
+INDEX
+	_getwc_r
+
+ANSI_SYNOPSIS
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t fgetwc(FILE *<[fp]>);
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t _fgetwc_r(struct _reent *<[ptr]>, FILE *<[fp]>);
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t getwc(FILE *<[fp]>);
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t _getwc_r(struct _reent *<[ptr]>, FILE *<[fp]>);
+
+TRAD_SYNOPSIS
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t fgetwc(<[fp]>)
+	FILE *<[fp]>;
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t _fgetwc_r(<[ptr]>, <[fp]>)
+	struct _reent *<[ptr]>;
+	FILE *<[fp]>;
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t getwc(<[fp]>)
+	FILE *<[fp]>;
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t _getwc_r(<[ptr]>, <[fp]>)
+	struct _reent *<[ptr]>;
+	FILE *<[fp]>;
+
+DESCRIPTION
+Use <<fgetwc>> to get the next wide character from the file or stream
+identified by <[fp]>.  As a side effect, <<fgetwc>> advances the file's
+current position indicator.
+
+The  <<getwc>>  function  or macro functions identically to <<fgetwc>>.  It
+may be implemented as a macro, and may evaluate its argument more  than
+once. There is no reason ever to use it.
+
+<<_fgetwc_r>> and <<_getwc_r>> are simply reentrant versions of
+<<fgetwc>> and <<getwc>> that are passed the additional reentrant
+structure pointer argument: <[ptr]>.
+
+RETURNS
+The next wide character cast to <<wint_t>>), unless there is no more data,
+or the host system reports a read error; in either of these situations,
+<<fgetwc>> and <<getwc>> return <<WEOF>>.
+
+You can distinguish the two situations that cause an <<EOF>> result by
+using the <<ferror>> and <<feof>> functions.
+
+PORTABILITY
+C99, POSIX.1-2001
+*/
+
+#include <_ansi.h>
+#include <reent.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <wchar.h>
+#include "local.h"
+
+static wint_t
+_DEFUN(__fgetwc, (ptr, fp),
+	struct _reent *ptr _AND
+	register FILE *fp)
+{
+  wchar_t wc;
+  size_t nconv;
+
+  if (fp->_r <= 0 && __srefill_r (ptr, fp))
+    return (WEOF);
+  if (MB_CUR_MAX == 1)
+    {
+      /* Fast path for single-byte encodings. */
+      wc = *fp->_p++;
+      fp->_r--;
+      return (wc);
+    }
+  do
+    {
+      nconv = _mbrtowc_r (ptr, &wc, (char *) fp->_p, fp->_r, &fp->_mbstate);
+      if (nconv == (size_t)-1)
+	break;
+      else if (nconv == (size_t)-2)
+	continue;
+      else if (nconv == 0)
+	{
+	  /*
+	   * Assume that the only valid representation of
+	   * the null wide character is a single null byte.
+	   */
+	  fp->_p++;
+	  fp->_r--;
+	  return (L'\0');
+	}
+      else
+        {
+	  fp->_p += nconv;
+	  fp->_r -= nconv;
+	  return (wc);
+	}
+    }
+  while (__srefill_r(ptr, fp) == 0);
+  fp->_flags |= __SERR;
+  errno = EILSEQ;
+  return (WEOF);
+}
+
+wint_t
+_DEFUN(_fgetwc_r, (ptr, fp),
+	struct _reent *ptr _AND
+	register FILE *fp)
+{
+  wint_t r;
+
+  _flockfile (fp);
+  ORIENT(fp, 1);
+  r = __fgetwc (ptr, fp);
+  _funlockfile (fp);
+  return r;
+}
+
+wint_t
+_DEFUN(fgetwc, (fp),
+	FILE *fp)
+{
+  CHECK_INIT(fp);
+  return _fgetwc_r (_REENT, fp);
+}
diff --git a/msys/rt/src/newlib/libc/stdio/fgetws.c b/msys/rt/src/newlib/libc/stdio/fgetws.c
new file mode 100644
index 0000000..a70a4cd
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/fgetws.c
@@ -0,0 +1,161 @@
+/*-
+ * Copyright (c) 2002-2004 Tim J. Robbins.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+FUNCTION
+<<fgetws>>---get wide character string from a file or stream
+
+INDEX
+	fgetws
+INDEX
+	_fgetws_r
+
+ANSI_SYNOPSIS
+	#include <wchar.h>
+	wchar_t *fgetws(wchar_t *<[ws]>, int <[n]>, FILE *<[fp]>);
+
+	#include <wchar.h>
+	wchar_t *_fgetws_r(struct _reent *<[ptr]>, wchar_t *<[ws]>, int <[n]>, FILE *<[fp]>);
+
+TRAD_SYNOPSIS
+	#include <wchar.h>
+	wchar_t *fgetws(<[ws]>,<[n]>,<[fp]>)
+	wchar_t *<[ws]>;
+	int <[n]>;
+	FILE *<[fp]>;
+
+	#include <wchar.h>
+	wchar_t *_fgetws_r(<[ptr]>, <[ws]>,<[n]>,<[fp]>)
+	struct _reent *<[ptr]>;
+	wchar_t *<[ws]>;
+	int <[n]>;
+	FILE *<[fp]>;
+
+DESCRIPTION
+Reads at most <[n-1]> wide characters from <[fp]> until a newline
+is found. The wide characters including to the newline are stored
+in <[ws]>. The buffer is terminated with a 0.
+
+The <<_fgetws_r>> function is simply the reentrant version of
+<<fgetws>> and is passed an additional reentrancy structure
+pointer: <[ptr]>.
+
+RETURNS
+<<fgetws>> returns the buffer passed to it, with the data
+filled in. If end of file occurs with some data already
+accumulated, the data is returned with no other indication. If
+no data are read, NULL is returned instead.
+
+PORTABILITY
+C99, POSIX.1-2001
+*/
+
+#include <_ansi.h>
+#include <reent.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <wchar.h>
+#include "local.h"
+
+wchar_t *
+_DEFUN(_fgetws_r, (ptr, ws, n, fp),
+	struct _reent *ptr _AND
+	wchar_t * ws _AND
+	int n _AND
+	FILE * fp)
+{
+  wchar_t *wsp;
+  size_t nconv;
+  const char *src;
+  unsigned char *nl;
+
+  _flockfile (fp);
+  ORIENT (fp, 1);
+
+  if (n <= 0)
+    {
+      errno = EINVAL;
+      goto error;
+    }
+
+  if (fp->_r <= 0 && __srefill_r (ptr, fp))
+    /* EOF */
+    goto error;
+  wsp = ws;
+  do
+    {
+      src = (char *) fp->_p;
+      nl = memchr (fp->_p, '\n', fp->_r);
+      nconv = _mbsrtowcs_r (ptr, wsp, &src,
+			    nl != NULL ? (nl - fp->_p + 1) : fp->_r,
+			    &fp->_mbstate);
+      if (nconv == (size_t) -1)
+	/* Conversion error */
+	goto error;
+      if (src == NULL)
+	{
+	  /*
+	   * We hit a null byte. Increment the character count,
+	   * since mbsnrtowcs()'s return value doesn't include
+	   * the terminating null, then resume conversion
+	   * after the null.
+	   */
+	  nconv++;
+	  src = memchr (fp->_p, '\0', fp->_r);
+	  src++;
+	}
+      fp->_r -= (unsigned char *) src - fp->_p;
+      fp->_p = (unsigned char *) src;
+      n -= nconv;
+      wsp += nconv;
+    }
+  while (wsp[-1] != L'\n' && n > 1 && (fp->_r > 0
+	 || __srefill_r (ptr, fp) == 0));
+  if (wsp == ws)
+    /* EOF */
+    goto error;
+  if (!mbsinit (&fp->_mbstate))
+    /* Incomplete character */
+    goto error;
+  *wsp++ = L'\0';
+  _funlockfile (fp);
+  return ws;
+
+error:
+  _funlockfile (fp);
+  return NULL;
+}
+
+wchar_t *
+_DEFUN(fgetws, (ws, n, fp),
+	wchar_t *ws _AND
+	int n _AND
+	FILE *fp)
+{
+  CHECK_INIT (fp);
+  return _fgetws_r (_REENT, ws, n, fp);
+}
diff --git a/msys/rt/src/newlib/libc/stdio/fputwc.c b/msys/rt/src/newlib/libc/stdio/fputwc.c
new file mode 100644
index 0000000..138f521
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/fputwc.c
@@ -0,0 +1,177 @@
+/*-
+ * Copyright (c) 2002-2004 Tim J. Robbins.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+FUNCTION
+<<fputwc>>, <<putwc>>---write a wide character on a stream or file
+
+INDEX
+	fputwc
+INDEX
+	_fputwc_r
+INDEX
+	putwc
+INDEX
+	_putwc_r
+
+ANSI_SYNOPSIS
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t fputwc(wchar_t <[wc]>, FILE *<[fp]>);
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t _fputwc_r(struct _reent *<[ptr]>, wchar_t <[wc]>, FILE *<[fp]>);
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t putwc(wchar_t <[wc]>, FILE *<[fp]>);
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t _putwc_r(struct _reent *<[ptr]>, wchar_t <[wc]>, FILE *<[fp]>);
+
+TRAD_SYNOPSIS
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t fputwc(<[wc]>, <[fp]>)
+	wchar_t <[wc]>;
+	FILE *<[fp]>;
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t _fputwc_r(<[ptr]>, <[wc]>, <[fp]>)
+	struct _reent *<[ptr]>;
+	wchar_t <[wc]>;
+	FILE *<[fp]>;
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t putwc(<[wc]>, <[fp]>)
+	wchar_t <[wc]>;
+	FILE *<[fp]>;
+
+	#include <stdio.h>
+	#include <wchar.h>
+	wint_t _putwc_r(<[ptr]>, <[wc]>, <[fp]>)
+	struct _reent *<[ptr]>;
+	wchar_t <[wc]>;
+	FILE *<[fp]>;
+
+DESCRIPTION
+<<fputwc>> writes the wide character argument <[wc]> to the file or
+stream identified by <[fp]>.
+
+If the file was opened with append mode (or if the stream cannot
+support positioning), then the new wide character goes at the end of the
+file or stream.  Otherwise, the new wide character is written at the
+current value of the position indicator, and the position indicator
+oadvances by one.
+
+The <<putwc>> function or macro functions identically to <<fputwc>>.  It
+may be implemented as a macro, and may evaluate its argument more than
+once. There is no reason ever to use it.
+
+The <<_fputwc_r>> and <<_putwc_r>> functions are simply reentrant versions
+of <<fputwc>> and <<putwc>> that take an additional reentrant structure
+argument: <[ptr]>.
+
+RETURNS
+If successful, <<fputwc>> and <<putwc>> return their argument <[wc]>.
+If an error intervenes, the result is <<EOF>>.  You can use
+`<<ferror(<[fp]>)>>' to query for errors.
+
+PORTABILITY
+C99, POSIX.1-2001
+*/
+
+#include <_ansi.h>
+#include <reent.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <wchar.h>
+#include "local.h"
+
+static wint_t
+_DEFUN(__fputwc, (ptr, wc, fp),
+	struct _reent *ptr _AND
+	wchar_t wc _AND
+	FILE *fp)
+{
+  char buf[MB_LEN_MAX];
+  size_t i, len;
+
+  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
+    {
+      /*
+       * Assume single-byte locale with no special encoding.
+       * A more careful test would be to check
+       * _CurrentRuneLocale->encoding.
+       */
+      *buf = (unsigned char)wc;
+      len = 1;
+    }
+  else
+    {
+      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
+	{
+	  fp->_flags |= __SERR;
+	  return WEOF;
+	}
+    }
+
+  for (i = 0; i < len; i++)
+    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
+      return WEOF;
+
+  return (wint_t) wc;
+}
+
+wint_t
+_DEFUN(_fputwc_r, (ptr, wc, fp),
+	struct _reent *ptr _AND
+	wchar_t wc _AND
+	FILE *fp)
+{
+  wint_t r;
+
+  _flockfile (fp);
+  ORIENT(fp, 1);
+  r = __fputwc(ptr, wc, fp);
+  _funlockfile (fp);
+  return r;
+}
+
+wint_t
+_DEFUN(fputwc, (wc, fp),
+	wchar_t wc _AND
+	FILE *fp)
+{
+  CHECK_INIT(fp);
+  return _fputwc_r (_REENT, wc, fp);
+}
diff --git a/msys/rt/src/newlib/libc/stdio/fputws.c b/msys/rt/src/newlib/libc/stdio/fputws.c
new file mode 100644
index 0000000..6b9f3ff
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/fputws.c
@@ -0,0 +1,122 @@
+/*-
+ * Copyright (c) 2002-2004 Tim J. Robbins.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+FUNCTION        
+<<fputws>>---write a wide character string in a file or stream
+
+INDEX
+	fputws   
+INDEX
+	_fputws_r
+
+ANSI_SYNOPSIS
+	#include <wchar.h>
+	int fputws(const wchar_t *<[ws]>, FILE *<[fp]>);
+
+	#include <wchar.h>
+	int _fputws_r(struct _reent *<[ptr]>, const wchar_t *<[ws]>, FILE *<[fp]>);
+
+TRAD_SYNOPSIS   
+	#include <wchar.h>
+	int fputws(<[ws]>, <[fp]>)
+	wchar_t *<[ws]>;
+	FILE *<[fp]>;
+
+	#include <wchar.h>
+	int _fputws_r(<[ptr]>, <[ws]>, <[fp]>)
+	struct _reent *<[ptr]>;
+	wchar_t *<[ws]>;
+	FILE *<[fp]>;
+
+DESCRIPTION
+<<fputws>> writes the wide character string at <[ws]> (but without the
+trailing null) to the file or stream identified by <[fp]>.
+
+<<_fputws_r>> is simply the reentrant version of <<fputws>> that takes
+an additional reentrant struct pointer argument: <[ptr]>.
+
+RETURNS
+If successful, the result is a non-negative integer; otherwise, the result
+is <<-1>> to indicate an error.
+
+PORTABILITY
+C99, POSIX.1-2001
+*/
+
+#include <_ansi.h>
+#include <reent.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdio.h>
+#include <wchar.h>
+#include "fvwrite.h"
+#include "local.h"
+
+int
+_DEFUN(_fputws_r, (ptr, ws, fp),
+	struct _reent *ptr _AND
+	const wchar_t *ws _AND
+	FILE *fp)
+{
+  size_t nbytes;
+  char buf[BUFSIZ];
+  struct __suio uio;
+  struct __siov iov;
+
+  _flockfile (fp);
+  ORIENT (fp, 1);
+  if (cantwrite (fp) != 0)
+    goto error;
+  uio.uio_iov = &iov;
+  uio.uio_iovcnt = 1;
+  iov.iov_base = buf;
+  do
+    {
+      nbytes = _wcsrtombs_r(ptr, buf, &ws, sizeof (buf), &fp->_mbstate);
+      if (nbytes == (size_t) -1)
+	goto error;
+      iov.iov_len = uio.uio_resid = nbytes;
+      if (__sfvwrite_r(ptr, fp, &uio) != 0)
+	goto error;
+    }
+  while (ws != NULL);
+  _funlockfile (fp);
+  return (0);
+
+error:
+  _funlockfile(fp);
+  return (-1);
+}
+
+int
+_DEFUN(fputws, (ws, fp),
+	const wchar_t *ws _AND
+	FILE *fp)
+{
+  CHECK_INIT (fp);
+  return _fputws_r (_REENT, ws, fp);
+}
diff --git a/msys/rt/src/newlib/libc/stdio/fwide.c b/msys/rt/src/newlib/libc/stdio/fwide.c
new file mode 100644
index 0000000..e1bcc51
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/fwide.c
@@ -0,0 +1,89 @@
+/*
+FUNCTION
+<<fwide>>---set and determine the orientation of a FILE stream
+
+INDEX
+	fwide
+INDEX
+	_fwide_r
+
+ANSI_SYNOPSIS
+	#include <wchar.h>
+	int fwide(FILE *<[fp]>, int <[mode]>)
+
+	int _fwide_r(struct _reent *<[ptr]>, FILE *<[fp]>, int <[mode]>)
+
+TRAD_SYNOPSIS
+	#include <wchar.h>
+	int fwide(<[fp]>, <[mode]>)
+	FILE *<[fp]>;
+	int <[mode]>;
+
+	int _fwide_r(<[ptr]>, <[fp]>, <[mode]>)
+	struct _reent *<[ptr]>;
+	FILE *<[fp]>;
+	int <[mode]>;
+
+DESCRIPTION
+When <[mode]> is zero, the <<fwide>> function determines the current
+orientation of <[fp]>. It returns a value > 0 if <[fp]> is
+wide-character oriented, i.e. if wide character I/O is permitted but
+char I/O is disallowed. It returns a value < 0 if <[fp]> is byte
+oriented, i.e. if char I/O is permitted but wide character I/O is
+disallowed. It returns zero if <[fp]> has no orientation yet; in
+this case the next I/O operation might change the orientation (to byte
+oriented if it is a char I/O operation, or to wide-character oriented
+if it is a wide character I/O operation).
+
+Once a stream has an orientation, it cannot be changed and persists
+until the stream is closed, unless the stream is re-opened with freopen,
+which removes the orientation of the stream.
+
+When <[mode]> is non-zero, the <<fwide>> function first attempts to set
+<[fp]>'s orientation (to wide-character oriented if <[mode]> > 0, or to
+byte oriented if <[mode]> < 0). It then returns a value denoting the
+current orientation, as above.
+
+RETURNS
+The <<fwide>> function returns <[fp]>'s orientation, after possibly
+changing it. A return value > 0 means wide-character oriented. A return
+value < 0 means byte oriented. A return value of zero means undecided.
+
+PORTABILITY
+C99, POSIX.1-2001.
+
+*/
+
+#include <_ansi.h>
+#include <wchar.h>
+#include "local.h"
+
+int
+_DEFUN(_fwide_r, (ptr, fp, mode),
+	struct _reent *ptr _AND
+	FILE *fp _AND
+	int mode)
+{
+  int ret;
+
+  CHECK_INIT(fp);
+
+  _flockfile (fp);
+  if (mode != 0) {
+    ORIENT (fp, mode);
+  }
+  if (!(fp->_flags & __SORD))
+    ret = 0;
+  else
+    ret = (fp->_flags2 & __SWID) ? 1 : -1;
+  _funlockfile (fp);
+  return ret;
+}
+
+int
+_DEFUN(fwide, (fp, mode),
+	FILE *fp _AND
+	int mode)
+{
+  return _fwide_r (_REENT, fp, mode);
+}
diff --git a/msys/rt/src/newlib/libc/stdio/getwc.c b/msys/rt/src/newlib/libc/stdio/getwc.c
new file mode 100644
index 0000000..6d88fa8
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/getwc.c
@@ -0,0 +1,52 @@
+/*-
+ * Copyright (c) 2002 Tim J. Robbins.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <_ansi.h>
+#include <reent.h>
+#include <stdio.h>
+#include <wchar.h>
+#include "local.h"
+
+#undef getwc
+
+wint_t
+_DEFUN(_getwc_r, (ptr, fp),
+	struct _reent *ptr _AND
+	FILE *fp)
+{
+  return _fgetwc_r (ptr, fp);
+}
+
+/*
+ * Synonym for fgetwc(). The only difference is that getwc(), if it is a
+ * macro, may evaluate `fp' more than once.
+ */
+wint_t
+_DEFUN(getwc, (fp),
+	FILE *fp)
+{
+  return fgetwc(fp);
+}
diff --git a/msys/rt/src/newlib/libc/stdio/getwchar.c b/msys/rt/src/newlib/libc/stdio/getwchar.c
new file mode 100644
index 0000000..f559c76
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/getwchar.c
@@ -0,0 +1,93 @@
+/*-
+ * Copyright (c) 2002 Tim J. Robbins.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+FUNCTION
+<<getwchar>>---read a wide character from standard input
+
+INDEX
+	getwchar
+INDEX
+	_getwchar_r
+
+ANSI_SYNOPSIS
+	#include <wchar.h>
+	wint_t getwchar(void);
+
+	wint_t _getwchar_r(struct _reent *<[reent]>);
+
+TRAD_SYNOPSIS
+	#include <wchar.h>
+	wint_t getwchar();
+
+	wint_t _getwchar_r(<[reent]>)
+	char * <[reent]>;
+
+DESCRIPTION
+<<getwchar>> function or macro is the wide character equivalent of
+the <<getchar>> function.  You can use <<getwchar>> to get the next
+wide character from the standard input stream.  As a side effect,
+<<getwchar>> advances the standard input's current position indicator.
+
+The alternate function <<_getwchar_r>> is a reentrant version.  The
+extra argument <[reent]> is a pointer to a reentrancy structure.
+
+RETURNS
+The next wide character cast to <<wint_t>>, unless there is no more
+data, or the host system reports a read error; in either of these
+situations, <<getwchar>> returns <<WEOF>>.
+
+You can distinguish the two situations that cause an <<WEOF>> result by
+using `<<ferror(stdin)>>' and `<<feof(stdin)>>'.
+
+PORTABILITY
+C99
+*/
+
+#include <_ansi.h>
+#include <reent.h>
+#include <stdio.h>
+#include <wchar.h>
+#include "local.h"
+
+#undef getwchar
+
+wint_t
+_DEFUN (_getwchar_r, (ptr),
+	struct _reent *ptr)
+{
+  return _fgetwc_r (ptr, stdin);
+}
+
+/*
+ * Synonym for fgetwc(stdin).
+ */
+wint_t
+_DEFUN_VOID (getwchar)
+{
+  _REENT_SMALL_CHECK_INIT (_REENT);
+  return fgetwc (stdin);
+}
diff --git a/msys/rt/src/newlib/libc/stdio/local.h b/msys/rt/src/newlib/libc/stdio/local.h
index 8b55503..1e42c99 100644
--- a/msys/rt/src/newlib/libc/stdio/local.h
+++ b/msys/rt/src/newlib/libc/stdio/local.h
@@ -26,6 +26,7 @@
 #include <stdarg.h>
 #include <reent.h>
 #include <unistd.h>
+#include <stdio.h>
 
 extern int    _EXFUN(__svfscanf_r,(struct _reent *,FILE *, _CONST char *,va_list));
 extern FILE  *_EXFUN(__sfp,(struct _reent *));
@@ -89,3 +90,33 @@ char *_EXFUN(_llicvt,(char *, long long, char));
 #define CVT_BUF_SIZE 128
 
 #define	NDYNAMIC 4	/* add four more whenever necessary */
+
+
+#define _flockfile(fp)
+#define _funlockfile(fp)
+
+/*
+ * Set the orientation for a stream. If o > 0, the stream has wide-
+ * orientation. If o < 0, the stream has byte-orientation.
+ */
+#define ORIENT(fp,ori)						\
+  do								\
+    {								\
+      if (!((fp)->_flags & __SORD))				\
+	{							\
+	  (fp)->_flags |= __SORD;				\
+	  if (ori > 0)						\
+	    (fp)->_flags2 |= __SWID;				\
+	  else							\
+	    (fp)->_flags2 &= ~__SWID;				\
+	}							\
+    }								\
+  while (0)
+
+#define _REENT_SMALL_CHECK_INIT(ptr) /* nothing */
+
+#define _ungetc_r(ptr, c, fp) ungetc(c, fp)
+#define __sputc_r(ptr, c, fp)  putc(c, fp)
+#define __srefill_r(ptr, fp)  __srefill(fp)
+#define __sfvwrite_r(ptr, fp, uio) __sfvwrite(fp, uio)
+#define _fflush_r(ptr, fp) fflush(fp)
diff --git a/msys/rt/src/newlib/libc/stdio/putwc.c b/msys/rt/src/newlib/libc/stdio/putwc.c
new file mode 100644
index 0000000..9a84f35
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/putwc.c
@@ -0,0 +1,53 @@
+/*-
+ * Copyright (c) 2002 Tim J. Robbins.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <_ansi.h>
+#include <reent.h>
+#include <stdio.h>
+#include <wchar.h>
+#include "local.h"
+
+#undef putwc
+
+wint_t
+_DEFUN(_putwc_r, (ptr, wc, fp),
+	struct _reent *ptr _AND
+	wchar_t wc _AND
+	FILE *fp)
+{
+  return _fputwc_r (ptr, wc, fp);
+}
+/*
+ * Synonym for fputwc(). The only difference is that putwc(), if it is a
+ * macro, may evaluate `fp' more than once.
+ */
+wint_t
+_DEFUN(putwc, (wc, fp),
+	wchar_t wc _AND
+	FILE *fp)
+{
+  return fputwc (wc, fp);
+}
diff --git a/msys/rt/src/newlib/libc/stdio/putwchar.c b/msys/rt/src/newlib/libc/stdio/putwchar.c
new file mode 100644
index 0000000..fcb0a7d
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/putwchar.c
@@ -0,0 +1,92 @@
+/*-
+ * Copyright (c) 2002 Tim J. Robbins.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+FUNCTION
+<<putwchar>>---write a wide character to standard output
+
+INDEX
+	putwchar
+INDEX
+	_putwchar_r
+
+ANSI_SYNOPSIS
+	#include <wchar.h>
+	wint_t putwchar(wchar_t <[wc]>);
+
+	wint_t _putwchar_r(struct _reent *<[reent]>, wchar_t <[wc]>);
+
+TRAD_SYNOPSIS
+	#include <wchar.h>
+	wint_t putwchar(<[wc]>)
+	wchar_t <[wc]>;
+
+	wint_t _putwchar_r(<[reent]>, <[wc]>)
+	struct _reent *<[reent]>;
+	wchar_t <[wc]>;
+
+DESCRIPTION
+The <<putwchar>> function or macro is the wide-character equivalent of
+the <<putchar>> function. It writes the wide character wc to stdout.
+
+The alternate function <<_putwchar_r>> is a reentrant version.  The
+extra argument <[reent]> is a pointer to a reentrancy structure.
+
+RETURNS
+If successful, <<putwchar>> returns its argument <[wc]>.  If an error
+intervenes, the result is <<EOF>>.  You can use `<<ferror(stdin)>>' to
+query for errors.
+
+PORTABILITY
+C99
+*/
+
+#include <_ansi.h>
+#include <reent.h>
+#include <stdio.h>
+#include <wchar.h>
+#include "local.h"
+
+#undef putwchar
+
+wint_t
+_DEFUN(_putwchar_r, (ptr, wc),
+	struct _reent *ptr _AND
+	wchar_t wc)
+{
+  return _fputwc_r (ptr, wc, stdout);
+}
+
+/*
+ * Synonym for fputwc(wc, stdout).
+ */
+wint_t
+_DEFUN(putwchar, (wc),
+	wchar_t wc)
+{
+  _REENT_SMALL_CHECK_INIT (_REENT);
+  return fputwc (wc, stdout);
+}
diff --git a/msys/rt/src/newlib/libc/stdio/sniprintf.c b/msys/rt/src/newlib/libc/stdio/sniprintf.c
new file mode 100644
index 0000000..98a2c25
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/sniprintf.c
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 1990, 2007 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by the University of California, Berkeley.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/* This code created by modifying snprintf.c so copyright inherited. */
+/* doc in siprintf.c */
+
+#include <_ansi.h>
+#include <reent.h>
+#include <stdio.h>
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+#include <limits.h>
+#include <errno.h>
+#include "local.h"
+
+int
+#ifdef _HAVE_STDC
+_DEFUN (_sniprintf_r, (ptr, str, size, fmt),
+	struct _reent *ptr _AND
+	char *str _AND
+	size_t size _AND
+	_CONST char *fmt _DOTS)
+#else
+_sniprintf_r (ptr, str, size, fmt, va_alist)
+     struct _reent *ptr;
+     char *str;
+     size_t size;
+     _CONST char *fmt;
+     va_dcl
+#endif
+{
+  int ret;
+  va_list ap;
+  FILE f;
+
+  if (size > INT_MAX)
+    {
+      ptr->_errno = EOVERFLOW;
+      return EOF;
+    }
+  f._flags = __SWR | __SSTR;
+  f._bf._base = f._p = (unsigned char *) str;
+  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
+  f._file = -1;  /* No file. */
+#ifdef _HAVE_STDC
+  va_start (ap, fmt);
+#else
+  va_start (ap);
+#endif
+  ret = _svfiprintf_r (ptr, &f, fmt, ap);
+  va_end (ap);
+  if (ret < EOF)
+    ptr->_errno = EOVERFLOW;
+  if (size > 0)
+    *f._p = 0;
+  return (ret);
+}
+
+#ifndef _REENT_ONLY
+
+int
+#ifdef _HAVE_STDC
+_DEFUN (sniprintf, (str, size, fmt),
+	char *str _AND
+	size_t size _AND
+	_CONST char *fmt _DOTS)
+#else
+sniprintf (str, size, fmt, va_alist)
+     char *str;
+     size_t size;
+     _CONST char *fmt;
+     va_dcl
+#endif
+{
+  int ret;
+  va_list ap;
+  FILE f;
+  struct _reent *ptr = _REENT;
+
+  if (size > INT_MAX)
+    {
+      ptr->_errno = EOVERFLOW;
+      return EOF;
+    }
+  f._flags = __SWR | __SSTR;
+  f._bf._base = f._p = (unsigned char *) str;
+  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
+  f._file = -1;  /* No file. */
+#ifdef _HAVE_STDC
+  va_start (ap, fmt);
+#else
+  va_start (ap);
+#endif
+  ret = _svfiprintf_r (ptr, &f, fmt, ap);
+  va_end (ap);
+  if (ret < EOF)
+    ptr->_errno = EOVERFLOW;
+  if (size > 0)
+    *f._p = 0;
+  return (ret);
+}
+
+#endif
diff --git a/msys/rt/src/newlib/libc/stdio/swprintf.c b/msys/rt/src/newlib/libc/stdio/swprintf.c
new file mode 100644
index 0000000..6348017
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/swprintf.c
@@ -0,0 +1,626 @@
+/*
+ * Copyright (c) 1990, 2007 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by the University of California, Berkeley.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+FUNCTION
+<<swprintf>>, <<fwprintf>>, <<wprintf>>---wide character format output
+
+INDEX
+	fwprintf
+INDEX
+	_fwprintf_r
+INDEX
+	wprintf
+INDEX
+	_wprintf_r
+INDEX
+	swprintf
+INDEX
+	_swprintf_r
+
+ANSI_SYNOPSIS
+        #include <wchar.h>
+
+        int wprintf(const wchar_t *<[format]>, ...);
+        int fwprintf(FILE *<[fd]>, const wchar_t *<[format]>, ...);
+        int swprintf(wchar_t *<[str]>, size_t <[size]>,
+			const wchar_t *<[format]>, ...);
+
+        int _wprintf_r(struct _reent *<[ptr]>, const wchar_t *<[format]>, ...);
+        int _fwprintf_r(struct _reent *<[ptr]>, FILE *<[fd]>,
+			const wchar_t *<[format]>, ...);
+        int _swprintf_r(struct _reent *<[ptr]>, wchar_t *<[str]>,
+			size_t <[size]>, const wchar_t *<[format]>, ...);
+
+DESCRIPTION
+        <<wprintf>> accepts a series of arguments, applies to each a
+        format specifier from <<*<[format]>>>, and writes the
+        formatted data to <<stdout>>, without a terminating NUL
+        wide character.  The behavior of <<wprintf>> is undefined if there
+        are not enough arguments for the format or if any argument is not the
+	right type for the corresponding conversion specifier.  <<wprintf>>
+	returns when it reaches the end of the format string.  If there are
+        more arguments than the format requires, excess arguments are
+        ignored.
+
+        <<fwprintf>> is like <<wprintf>>, except that output is directed
+        to the stream <[fd]> rather than <<stdout>>.
+
+        <<swprintf>> is like <<wprintf>>, except that output is directed
+        to the buffer <[str]> with a terminating wide <<NUL>>, and the
+	resulting string length is limited to at most <[size]> wide characters,
+	including the terminating <<NUL>>.  It is considered an error if the
+	output (including the terminating wide-<<NULL>>) does not fit into
+	<[size]> wide characters.  (This error behavior is not the same as for
+	<<snprintf>>, which <<swprintf>> is otherwise completely analogous to.
+	While <<snprintf>> allows the needed size to be known simply by giving
+	<[size]>=0, <<swprintf>> does not, giving an error instead.)
+
+        For <<swprintf>> the behavior is undefined if the output
+	<<*<[str]>>> overlaps with one of the arguments.  Behavior is also
+	undefined if the argument for <<%n>> within <<*<[format]>>>
+	overlaps another argument.
+
+        <[format]> is a pointer to a wide character string containing two
+	types of objects: ordinary characters (other than <<%>>),
+	which are copied unchanged to the output, and conversion
+	specifications, each of which is introduced by <<%>>. (To
+	include <<%>> in the output, use <<%%>> in the format string.)
+	A conversion specification has the following form:
+
+.       %[<[pos]>][<[flags]>][<[width]>][.<[prec]>][<[size]>]<[type]>
+
+        The fields of the conversion specification have the following
+        meanings:
+
+        O+
+	o <[pos]>
+
+        Conversions normally consume arguments in the order that they
+        are presented.  However, it is possible to consume arguments
+        out of order, and reuse an argument for more than one
+        conversion specification (although the behavior is undefined
+        if the same argument is requested with different types), by
+        specifying <[pos]>, which is a decimal integer followed by
+        '$'.  The integer must be between 1 and <NL_ARGMAX> from
+        limits.h, and if argument <<%n$>> is requested, all earlier
+        arguments must be requested somewhere within <[format]>.  If
+        positional parameters are used, then all conversion
+        specifications except for <<%%>> must specify a position.
+	This positional parameters method is a POSIX extension to the C
+	standard definition for the functions.
+
+	o <[flags]>
+
+	<[flags]> is an optional sequence of characters which control
+	output justification, numeric signs, decimal points, trailing
+	zeros, and octal and hex prefixes.  The flag characters are
+	minus (<<->>), plus (<<+>>), space ( ), zero (<<0>>), sharp
+	(<<#>>), and quote (<<'>>).  They can appear in any
+	combination, although not all flags can be used for all
+	conversion specification types.
+
+		o+
+		o '
+			A POSIX extension to the C standard.  However, this
+			implementation presently treats it as a no-op, which
+			is the default behavior for the C locale, anyway.  (If
+			it did what it is supposed to, when <[type]> were <<i>>,
+			<<d>>, <<u>>, <<f>>, <<F>>, <<g>>, or <<G>>, the
+			integer portion of the conversion would be formatted
+			with thousands' grouping wide characters.)
+
+		o -
+			The result of the conversion is left
+			justified, and the right is padded with
+			blanks.  If you do not use this flag, the
+			result is right justified, and padded on the
+			left.
+
+	        o +
+			The result of a signed conversion (as
+			determined by <[type]> of <<d>>, <<i>>, <<a>>,
+			<<A>>, <<e>>, <<E>>, <<f>>, <<F>>, <<g>>, or
+			<<G>>) will always begin with a plus or minus
+			sign.  (If you do not use this flag, positive
+			values do not begin with a plus sign.)
+
+		o " " (space)
+			If the first character of a signed conversion
+		        specification is not a sign, or if a signed
+		        conversion results in no characters, the
+		        result will begin with a space.  If the space
+		        ( ) flag and the plus (<<+>>) flag both
+		        appear, the space flag is ignored.
+
+	        o 0
+			If the <[type]> character is <<d>>, <<i>>,
+			<<o>>, <<u>>, <<x>>, <<X>>, <<a>>, <<A>>,
+			<<e>>, <<E>>, <<f>>, <<F>>, <<g>>, or <<G>>:  leading
+			zeros are used to pad the field width
+			(following any indication of sign or base); no
+			spaces are used for padding.  If the zero
+			(<<0>>) and minus (<<->>) flags both appear,
+			the zero (<<0>>) flag will be ignored.  For
+			<<d>>, <<i>>, <<o>>, <<u>>, <<x>>, and <<X>>
+			conversions, if a precision <[prec]> is
+			specified, the zero (<<0>>) flag is ignored.
+
+			Note that <<0>> is interpreted as a flag, not
+		        as the beginning of a field width.
+
+	        o #
+			The result is to be converted to an
+			alternative form, according to the <[type]>
+			character:
+
+			o+
+			o o
+				Increases precision to force the first
+				digit of the result to be a zero.
+
+			o x
+				A non-zero result will have a <<0x>>
+				prefix.
+
+			o X
+				A non-zero result will have a <<0X>>
+				prefix.
+
+			o a, A, e, E, f, or F
+				The result will always contain a
+			        decimal point even if no digits follow
+			        the point.  (Normally, a decimal point
+			        appears only if a digit follows it.)
+			        Trailing zeros are removed.
+
+			o g or G
+				The result will always contain a
+			        decimal point even if no digits follow
+			        the point.  Trailing zeros are not
+			        removed.
+
+			o all others
+				Undefined.
+
+			o-
+		o-
+
+	o <[width]>
+
+		<[width]> is an optional minimum field width.  You can
+		either specify it directly as a decimal integer, or
+		indirectly by using instead an asterisk (<<*>>), in
+		which case an <<int>> argument is used as the field
+		width.  If positional arguments are used, then the
+		width must also be specified positionally as <<*m$>>,
+		with m as a decimal integer.  Negative field widths
+		are treated as specifying the minus (<<->>) flag for
+		left justfication, along with a positive field width.
+		The resulting format may be wider than the specified
+		width.
+
+	o <[prec]>
+
+		<[prec]> is an optional field; if present, it is
+		introduced with `<<.>>' (a period). You can specify
+		the precision either directly as a decimal integer or
+		indirectly by using an asterisk (<<*>>), in which case
+		an <<int>> argument is used as the precision.  If
+		positional arguments are used, then the precision must
+		also be specified positionally as <<*m$>>, with m as a
+		decimal integer.  Supplying a negative precision is
+		equivalent to omitting the precision.  If only a
+		period is specified the precision is zero. The effect
+		depends on the conversion <[type]>.
+
+		o+
+		o d, i, o, u, x, or X
+			Minimum number of digits to appear.  If no
+			precision is given, defaults to 1.
+
+		o a or A
+			Number of digits to appear after the decimal
+			point.  If no precision is given, the
+			precision defaults to the minimum needed for
+			an exact representation.
+
+		o e, E, f or F
+			Number of digits to appear after the decimal
+			point.  If no precision is given, the
+			precision defaults to 6.
+
+		o g or G
+			Maximum number of significant digits.  A
+			precision of 0 is treated the same as a
+			precision of 1.  If no precision is given, the
+			precision defaults to 6.
+
+		o s or S
+			Maximum number of characters to print from the
+			string.  If no precision is given, the entire
+			string is printed.
+
+		o all others
+			undefined.
+
+		o-
+
+	o <[size]>
+
+		<[size]> is an optional modifier that changes the data
+		type that the corresponding argument has.  Behavior is
+		unspecified if a size is given that does not match the
+		<[type]>.
+
+		o+
+		o hh
+			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
+			<<X>>, specifies that the argument should be
+			converted to a <<signed char>> or <<unsigned
+			char>> before printing.
+
+			With <<n>>, specifies that the argument is a
+			pointer to a <<signed char>>.
+
+		o h
+			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
+			<<X>>, specifies that the argument should be
+			converted to a <<short>> or <<unsigned short>>
+			before printing.
+
+			With <<n>>, specifies that the argument is a
+			pointer to a <<short>>.
+
+		o l
+			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
+			<<X>>, specifies that the argument is a
+			<<long>> or <<unsigned long>>.
+
+			With <<c>>, specifies that the argument has
+			type <<wint_t>>.
+
+			With <<s>>, specifies that the argument is a
+			pointer to <<wchar_t>>.
+
+			With <<n>>, specifies that the argument is a
+			pointer to a <<long>>.
+
+			With <<a>>, <<A>>, <<e>>, <<E>>, <<f>>, <<F>>,
+			<<g>>, or <<G>>, has no effect (because of
+			vararg promotion rules, there is no need to
+			distinguish between <<float>> and <<double>>).
+
+		o ll
+			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
+			<<X>>, specifies that the argument is a
+			<<long long>> or <<unsigned long long>>.
+
+			With <<n>>, specifies that the argument is a
+			pointer to a <<long long>>.
+
+		o j
+			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
+			<<X>>, specifies that the argument is an
+			<<intmax_t>> or <<uintmax_t>>.
+
+			With <<n>>, specifies that the argument is a
+			pointer to an <<intmax_t>>.
+
+		o z
+			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
+			<<X>>, specifies that the argument is a <<size_t>>.
+
+			With <<n>>, specifies that the argument is a
+			pointer to a <<size_t>>.
+
+		o t
+			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
+			<<X>>, specifies that the argument is a
+			<<ptrdiff_t>>.
+
+			With <<n>>, specifies that the argument is a
+			pointer to a <<ptrdiff_t>>.
+
+		o L
+			With <<a>>, <<A>>, <<e>>, <<E>>, <<f>>, <<F>>,
+			<<g>>, or <<G>>, specifies that the argument
+			is a <<long double>>.
+
+		o-
+
+	o   <[type]>
+
+		<[type]> specifies what kind of conversion <<wprintf>>
+		performs.  Here is a table of these:
+
+		o+
+		o %
+			Prints the percent character (<<%>>).
+
+		o c
+			If no <<l>> qualifier is present, the int argument shall
+			be converted to a wide character as if by calling
+			the btowc() function and the resulting wide character
+			shall be written.  Otherwise, the wint_t argument
+			shall be converted to wchar_t, and written.
+
+		o C
+			Short for <<%lc>>.  A POSIX extension to the C standard.
+
+		o s
+			If no <<l>> qualifier is present, the application
+			shall ensure that the argument is a pointer to a
+			character array containing a character sequence
+			beginning in the initial shift state.  Characters
+			from the array shall be converted as if by repeated
+			calls to the mbrtowc() function, with the conversion
+			state described by an mbstate_t object initialized to
+			zero before the first character is converted, and
+			written up to (but not including) the terminating
+			null wide character. If the precision is specified,
+			no more than that many wide characters shall be
+			written.  If the precision is not specified, or is
+			greater than the size of the array, the application
+			shall ensure that the array contains a null wide
+			character.
+
+			If an <<l>> qualifier is present, the application
+			shall ensure that the argument is a pointer to an
+			array of type wchar_t. Wide characters from the array
+			shall be written up to (but not including) a
+			terminating null wide character. If no precision is
+			specified, or is greater than the size of the array,
+			the application shall ensure that the array contains
+			a null wide character. If a precision is specified,
+			no more than that many wide characters shall be
+			written.
+
+		o S
+			Short for <<%ls>>.  A POSIX extension to the C standard.
+
+		o d or i
+			Prints a signed decimal integer; takes an
+			<<int>>.  Leading zeros are inserted as
+			necessary to reach the precision.  A value of 0 with
+			a precision of 0 produces an empty string.
+
+		o o
+			Prints an unsigned octal integer; takes an
+			<<unsigned>>.  Leading zeros are inserted as
+			necessary to reach the precision.  A value of 0 with
+			a precision of 0 produces an empty string.
+
+		o u
+			Prints an unsigned decimal integer; takes an
+			<<unsigned>>.  Leading zeros are inserted as
+			necessary to reach the precision.  A value of 0 with
+			a precision of 0 produces an empty string.
+
+		o x
+			Prints an unsigned hexadecimal integer (using
+			<<abcdef>> as digits beyond <<9>>); takes an
+			<<unsigned>>.  Leading zeros are inserted as
+			necessary to reach the precision.  A value of 0 with
+			a precision of 0 produces an empty string.
+
+		o X
+			Like <<x>>, but uses <<ABCDEF>> as digits
+			beyond <<9>>.
+
+		o f
+			Prints a signed value of the form
+			<<[-]9999.9999>>, with the precision
+			determining how many digits follow the decimal
+			point; takes a <<double>> (remember that
+			<<float>> promotes to <<double>> as a vararg).
+			The low order digit is rounded to even.  If
+			the precision results in at most DECIMAL_DIG
+			digits, the result is rounded correctly; if
+			more than DECIMAL_DIG digits are printed, the
+			result is only guaranteed to round back to the
+			original value.
+
+			If the value is infinite, the result is
+			<<inf>>, and no zero padding is performed.  If
+			the value is not a number, the result is
+			<<nan>>, and no zero padding is performed.
+
+		o F
+			Like <<f>>, but uses <<INF>> and <<NAN>> for
+			non-finite numbers.
+
+		o e
+			Prints a signed value of the form
+			<<[-]9.9999e[+|-]999>>; takes a <<double>>.
+			The digit before the decimal point is non-zero
+			if the value is non-zero.  The precision
+			determines how many digits appear between
+			<<.>> and <<e>>, and the exponent always
+			contains at least two digits.  The value zero
+			has an exponent of zero.  If the value is not
+			finite, it is printed like <<f>>.
+
+		o E
+			Like <<e>>, but using <<E>> to introduce the
+			exponent, and like <<F>> for non-finite
+			values.
+
+		o g
+			Prints a signed value in either <<f>> or <<e>>
+			form, based on the given value and
+			precision---an exponent less than -4 or
+			greater than the precision selects the <<e>>
+			form.  Trailing zeros and the decimal point
+			are printed only if necessary; takes a
+			<<double>>.
+
+		o G
+			Like <<g>>, except use <<F>> or <<E>> form.
+
+		o a
+			Prints a signed value of the form
+			<<[-]0x1.ffffp[+|-]9>>; takes a <<double>>.
+			The letters <<abcdef>> are used for digits
+			beyond <<9>>.  The precision determines how
+			many digits appear after the decimal point.
+			The exponent contains at least one digit, and
+			is a decimal value representing the power of
+			2; a value of 0 has an exponent of 0.
+			Non-finite values are printed like <<f>>.
+
+		o A
+			Like <<a>>, except uses <<X>>, <<P>>, and
+			<<ABCDEF>> instead of lower case.
+
+		o n
+			Takes a pointer to <<int>>, and stores a count
+			of the number of bytes written so far.  No
+			output is created.
+
+		o p
+			Takes a pointer to <<void>>, and prints it in
+			an implementation-defined format.  This
+			implementation is similar to <<%#tx>>), except
+			that <<0x>> appears even for the NULL pointer.
+
+		o-
+	O-
+
+        <<_wprintf_r>>, <<_fwprintf_r>>, <<_swprintf_r>>, are simply
+        reentrant versions of the functions above.
+
+RETURNS
+On success, <<swprintf>> return the number of wide characters in
+the output string, except the concluding <<NUL>> is not counted.
+<<wprintf>> and <<fwprintf>> return the number of characters transmitted.
+
+If an error occurs, the result of <<wprintf>>, <<fwprintf>>, and
+<<swprintf>> is a negative value.  For <<wprintf>> and <<fwprintf>>,
+<<errno>> may be set according to <<fputwc>>.  For <<swprintf>>, <<errno>>
+may be set to EOVERFLOW if <[size]> is greater than INT_MAX / sizeof (wchar_t),
+or when the output does not fit into <[size]> wide characters (including the
+terminating wide <<NULL>>).
+
+BUGS
+The ``''' (quote) flag does not work when locale's thousands_sep is not empty.
+
+PORTABILITY
+POSIX-1.2008 with extensions; C99 (compliant except for POSIX extensions).
+
+Depending on how newlib was configured, not all format specifiers are
+supported.
+
+Supporting OS subroutines required: <<close>>, <<fstat>>, <<isatty>>,
+<<lseek>>, <<read>>, <<sbrk>>, <<write>>.
+*/
+
+
+#include <_ansi.h>
+#include <reent.h>
+#include <stdio.h>
+#include <wchar.h>
+#include <stdarg.h>
+#include <limits.h>
+#include <errno.h>
+#include "local.h"
+
+/* NOTE:  _swprintf_r() should be identical to swprintf() except for the
+ * former having ptr as a parameter and the latter needing to declare it as
+ * a variable set to _REENT.  */
+
+int
+_DEFUN(_swprintf_r, (ptr, str, size, fmt),
+       struct _reent *ptr _AND
+       wchar_t *str          _AND
+       size_t size        _AND
+       _CONST wchar_t *fmt _DOTS)
+{
+  int ret;
+  va_list ap;
+  FILE f;
+
+  if (size > INT_MAX / sizeof (wchar_t))
+    {
+      ptr->_errno = EOVERFLOW;	/* POSIX extension */
+      return EOF;
+    }
+  f._flags = __SWR | __SSTR;
+  f._bf._base = f._p = (unsigned char *) str;
+  f._bf._size = f._w = (size > 0 ? (size - 1) * sizeof (wchar_t) : 0);
+  f._file = -1;  /* No file. */
+  va_start (ap, fmt);
+  ret = _svfwprintf_r (ptr, &f, fmt, ap);
+  va_end (ap);
+  /* _svfwprintf_r() does not put in a terminating NUL, so add one if
+   * appropriate, which is whenever size is > 0.  _svfwprintf_r() stops
+   * after n-1, so always just put at the end.  */
+  if (size > 0)  {
+    *(wchar_t *)f._p = L'\0';	/* terminate the string */
+  }
+  if(ret >= size)  {
+    /* _svfwprintf_r() returns how many wide characters it would have printed
+     * if there were enough space.  Return an error if too big to fit in str,
+     * unlike snprintf, which returns the size needed.  */
+    ptr->_errno = EOVERFLOW;	/* POSIX extension */
+    ret = -1;
+  }
+  return (ret);
+}
+
+#ifndef _REENT_ONLY
+
+int
+_DEFUN(swprintf, (str, size, fmt),
+       wchar_t *str   _AND
+       size_t size _AND
+       _CONST wchar_t *fmt _DOTS)
+{
+  int ret;
+  va_list ap;
+  FILE f;
+  struct _reent *ptr = _REENT;
+
+  if (size > INT_MAX / sizeof (wchar_t))
+    {
+      ptr->_errno = EOVERFLOW;	/* POSIX extension */
+      return EOF;
+    }
+  f._flags = __SWR | __SSTR;
+  f._bf._base = f._p = (unsigned char *) str;
+  f._bf._size = f._w = (size > 0 ? (size - 1) * sizeof (wchar_t) : 0);
+  f._file = -1;  /* No file. */
+  va_start (ap, fmt);
+  ret = _svfwprintf_r (ptr, &f, fmt, ap);
+  va_end (ap);
+  /* _svfwprintf_r() does not put in a terminating NUL, so add one if
+   * appropriate, which is whenever size is > 0.  _svfwprintf_r() stops
+   * after n-1, so always just put at the end.  */
+  if (size > 0)  {
+    *(wchar_t *)f._p = L'\0';	/* terminate the string */
+  }
+  if(ret >= size)  {
+    /* _svfwprintf_r() returns how many wide characters it would have printed
+     * if there were enough space.  Return an error if too big to fit in str,
+     * unlike snprintf, which returns the size needed.  */
+    ptr->_errno = EOVERFLOW;	/* POSIX extension */
+    ret = -1;
+  }
+  return (ret);
+}
+
+#endif
diff --git a/msys/rt/src/newlib/libc/stdio/ungetwc.c b/msys/rt/src/newlib/libc/stdio/ungetwc.c
new file mode 100644
index 0000000..7f3e3fe
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/ungetwc.c
@@ -0,0 +1,115 @@
+/*-
+ * Copyright (c) 2002-2004 Tim J. Robbins.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+FUNCTION
+<<ungetwc>>---push wide character data back into a stream
+
+INDEX
+        ungetwc
+INDEX
+        _ungetwc_r
+
+ANSI_SYNOPSIS
+        #include <stdio.h>
+        #include <wchar.h>
+        wint_t ungetwc(wint_t <[wc]>, FILE *<[stream]>);
+
+        wint_t _ungetwc_r(struct _reent *<[reent]>, wint_t <[wc]>, FILE *<[stream]>);
+
+DESCRIPTION
+<<ungetwc>> is used to return wide characters back to <[stream]> to be
+read again.  If <[wc]> is WEOF, the stream is unchanged.  Otherwise, the
+wide character <[wc]> is put back on the stream, and subsequent reads will see
+the wide chars pushed back in reverse order.  Pushed wide chars are lost if the
+stream is repositioned, such as by <<fseek>>, <<fsetpos>>, or
+<<rewind>>.
+
+The underlying file is not changed, but it is possible to push back
+something different than what was originally read.  Ungetting a
+character will clear the end-of-stream marker, and decrement the file
+position indicator.  Pushing back beyond the beginning of a file gives
+unspecified behavior.
+
+The alternate function <<_ungetwc_r>> is a reentrant version.  The
+extra argument <[reent]> is a pointer to a reentrancy structure.
+
+RETURNS
+The wide character pushed back, or <<WEOF>> on error.
+
+PORTABILITY
+C99
+*/
+
+#include <_ansi.h>
+#include <reent.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <wchar.h>
+#include "local.h"
+
+wint_t
+_DEFUN(_ungetwc_r, (ptr, wc, fp),
+	struct _reent *ptr _AND
+	wint_t wc _AND
+	register FILE *fp)
+{
+  char buf[MB_LEN_MAX];
+  size_t len;
+
+  _flockfile (fp);
+  ORIENT (fp, 1);
+  if (wc == WEOF)
+    wc = WEOF;
+  else if ((len = _wcrtomb_r(ptr, buf, wc, &fp->_mbstate)) == (size_t)-1)
+    {
+      fp->_flags |= __SERR;
+      wc = WEOF;
+    }
+  else
+    while (len-- != 0)
+      if (_ungetc_r(ptr, (unsigned char)buf[len], fp) == EOF)
+	{
+	  wc = WEOF;
+	  break;
+	}
+  _funlockfile (fp);
+  return wc;
+}
+
+/*
+ * MT-safe version.
+ */
+wint_t
+_DEFUN(ungetwc, (wint_t wc, FILE *fp),
+	wint_t wc _AND
+	FILE *fp)
+{
+  CHECK_INIT (fp);
+  return _ungetwc_r (_REENT, wc, fp);
+}
diff --git a/msys/rt/src/newlib/libc/stdio/vfprintf.c b/msys/rt/src/newlib/libc/stdio/vfprintf.c
index df3e47d..15e1a62 100644
--- a/msys/rt/src/newlib/libc/stdio/vfprintf.c
+++ b/msys/rt/src/newlib/libc/stdio/vfprintf.c
@@ -1,103 +1,4 @@
 /*
-FUNCTION
-<<vprintf>>, <<vfprintf>>, <<vsprintf>>---format argument list
-
-INDEX
-	vprintf
-INDEX
-	vfprintf
-INDEX
-	vsprintf
-INDEX
-	vsnprintf
-
-ANSI_SYNOPSIS
-	#include <stdio.h>
-	#include <stdarg.h>
-	int vprintf(const char *<[fmt]>, va_list <[list]>);
-	int vfprintf(FILE *<[fp]>, const char *<[fmt]>, va_list <[list]>);
-	int vsprintf(char *<[str]>, const char *<[fmt]>, va_list <[list]>);
-	int vsnprintf(char *<[str]>, size_t <[size]>, const char *<[fmt]>, va_list <[list]>);
-
-	int _vprintf_r(void *<[reent]>, const char *<[fmt]>,
-                        va_list <[list]>);
-	int _vfprintf_r(void *<[reent]>, FILE *<[fp]>, const char *<[fmt]>,
-                        va_list <[list]>);
-	int _vsprintf_r(void *<[reent]>, char *<[str]>, const char *<[fmt]>,
-                        va_list <[list]>);
-	int _vsnprintf_r(void *<[reent]>, char *<[str]>, size_t <[size]>, const char *<[fmt]>,
-                        va_list <[list]>);
-
-TRAD_SYNOPSIS
-	#include <stdio.h>
-	#include <varargs.h>
-	int vprintf( <[fmt]>, <[list]>)
-	char *<[fmt]>;
-	va_list <[list]>;
-
-	int vfprintf(<[fp]>, <[fmt]>, <[list]>)
-	FILE *<[fp]>;
-	char *<[fmt]>;
-	va_list <[list]>;
-
-	int vsprintf(<[str]>, <[fmt]>, <[list]>)
-	char *<[str]>;
-	char *<[fmt]>;
-	va_list <[list]>;
-
-	int vsnprintf(<[str]>, <[size]>, <[fmt]>, <[list]>)
-	char *<[str]>;
-        size_t <[size]>;
-	char *<[fmt]>;
-	va_list <[list]>;
-
-	int _vprintf_r(<[reent]>, <[fmt]>, <[list]>)
-	char *<[reent]>;
-	char *<[fmt]>;
-	va_list <[list]>;
-
-	int _vfprintf_r(<[reent]>, <[fp]>, <[fmt]>, <[list]>)
-	char *<[reent]>;
-	FILE *<[fp]>;
-	char *<[fmt]>;
-	va_list <[list]>;
-
-	int _vsprintf_r(<[reent]>, <[str]>, <[fmt]>, <[list]>)
-	char *<[reent]>;
-	char *<[str]>;
-	char *<[fmt]>;
-	va_list <[list]>;
-
-	int _vsnprintf_r(<[reent]>, <[str]>, <[size]>, <[fmt]>, <[list]>)
-	char *<[reent]>;
-	char *<[str]>;
-        size_t <[size]>;
-	char *<[fmt]>;
-	va_list <[list]>;
-
-DESCRIPTION
-<<vprintf>>, <<vfprintf>>, <<vsprintf>> and <<vsnprintf>> are (respectively)
-variants of <<printf>>, <<fprintf>>, <<sprintf>> and <<snprintf>>.  They differ
-only in allowing their caller to pass the variable argument list as a
-<<va_list>> object (initialized by <<va_start>>) rather than directly
-accepting a variable number of arguments.
-
-RETURNS
-The return values are consistent with the corresponding functions:
-<<vsprintf>> returns the number of bytes in the output string,
-save that the concluding <<NULL>> is not counted.
-<<vprintf>> and <<vfprintf>> return the number of characters transmitted.
-If an error occurs, <<vprintf>> and <<vfprintf>> return <<EOF>>. No
-error returns occur for <<vsprintf>>.
-
-PORTABILITY
-ANSI C requires all three functions.
-
-Supporting OS subroutines required: <<close>>, <<fstat>>, <<isatty>>,
-<<lseek>>, <<read>>, <<sbrk>>, <<write>>.
-*/
-
-/*-
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
  *
@@ -133,9 +34,87 @@ Supporting OS subroutines required: <<close>>, <<fstat>>, <<isatty>>,
  * SUCH DAMAGE.
  */
 
+/*
+FUNCTION
+<<vfprintf>>, <<vprintf>>, <<vsprintf>>, <<vsnprintf>>, <<vasprintf>>, <<vasnprintf>>---format argument list
+
+INDEX
+	vfprintf
+INDEX
+	_vfprintf_r
+INDEX
+	vprintf
+INDEX
+	_vprintf_r
+INDEX
+	vsprintf
+INDEX
+	_vsprintf_r
+INDEX
+	vsnprintf
+INDEX
+	_vsnprintf_r
+INDEX
+	vasprintf
+INDEX
+	_vasprintf_r
+INDEX
+	vasnprintf
+INDEX
+	_vasnprintf_r
+
+ANSI_SYNOPSIS
+	#include <stdio.h>
+	#include <stdarg.h>
+	int vprintf(const char *<[fmt]>, va_list <[list]>);
+	int vfprintf(FILE *<[fp]>, const char *<[fmt]>, va_list <[list]>);
+	int vsprintf(char *<[str]>, const char *<[fmt]>, va_list <[list]>);
+	int vsnprintf(char *<[str]>, size_t <[size]>, const char *<[fmt]>,
+                      va_list <[list]>);
+	int vasprintf(char **<[strp]>, const char *<[fmt]>, va_list <[list]>);
+	char *vasnprintf(char *<[str]>, size_t *<[size]>, const char *<[fmt]>,
+                         va_list <[list]>);
+
+	int _vprintf_r(struct _reent *<[reent]>, const char *<[fmt]>,
+                        va_list <[list]>);
+	int _vfprintf_r(struct _reent *<[reent]>, FILE *<[fp]>,
+                        const char *<[fmt]>, va_list <[list]>);
+	int _vsprintf_r(struct _reent *<[reent]>, char *<[str]>,
+                        const char *<[fmt]>, va_list <[list]>);
+	int _vasprintf_r(struct _reent *<[reent]>, char **<[str]>,
+                         const char *<[fmt]>, va_list <[list]>);
+	int _vsnprintf_r(struct _reent *<[reent]>, char *<[str]>,
+                         size_t <[size]>, const char *<[fmt]>, va_list <[list]>);
+	char *_vasnprintf_r(struct _reent *<[reent]>, char *<[str]>,
+                            size_t *<[size]>, const char *<[fmt]>, va_list <[list]>);
+
+DESCRIPTION
+<<vprintf>>, <<vfprintf>>, <<vasprintf>>, <<vsprintf>>, <<vsnprintf>>,
+and <<vasnprintf>> are (respectively) variants of <<printf>>,
+<<fprintf>>, <<asprintf>>, <<sprintf>>, <<snprintf>>, and
+<<asnprintf>>.  They differ only in allowing their caller to pass the
+variable argument list as a <<va_list>> object (initialized by
+<<va_start>>) rather than directly accepting a variable number of
+arguments.  The caller is responsible for calling <<va_end>>.
+
+<<_vprintf_r>>, <<_vfprintf_r>>, <<_vasprintf_r>>, <<_vsprintf_r>>,
+<<_vsnprintf_r>>, and <<_vasnprintf_r>> are reentrant versions of the
+above.
+
+RETURNS
+The return values are consistent with the corresponding functions.
+
+PORTABILITY
+ANSI C requires <<vprintf>>, <<vfprintf>>, <<vsprintf>>, and
+<<vsnprintf>>.  The remaining functions are newlib extensions.
+
+Supporting OS subroutines required: <<close>>, <<fstat>>, <<isatty>>,
+<<lseek>>, <<read>>, <<sbrk>>, <<write>>.
+*/
+
 #if defined(LIBC_SCCS) && !defined(lint)
 /*static char *sccsid = "from: @(#)vfprintf.c	5.50 (Berkeley) 12/16/92";*/
-static char *rcsid = "$Id: vfprintf.c,v 1.34 2000/12/08 00:28:25 jjohnstn Exp $";
+static char *rcsid = "$Id: vfprintf.c,v 1.43 2002/08/13 02:40:06 fitzsim Exp $";
 #endif /* LIBC_SCCS and not lint */
 
 /*
@@ -143,34 +122,44 @@ static char *rcsid = "$Id: vfprintf.c,v 1.34 2000/12/08 00:28:25 jjohnstn Exp $"
  *
  * This code is large and complicated...
  */
+#include <newlib.h>
 
 #ifdef INTEGER_ONLY
-#define VFPRINTF vfiprintf
-#define _VFPRINTF_R _vfiprintf_r
+# define VFPRINTF vfiprintf
+# ifdef STRING_ONLY
+#   define _VFPRINTF_R _svfiprintf_r
+# else
+#   define _VFPRINTF_R _vfiprintf_r
+# endif
 #else
-#define VFPRINTF vfprintf
-#define _VFPRINTF_R _vfprintf_r
-#define FLOATING_POINT
+# define VFPRINTF vfprintf
+# ifdef STRING_ONLY
+#   define _VFPRINTF_R _svfprintf_r
+# else
+#   define _VFPRINTF_R _vfprintf_r
+# endif
+# ifndef NO_FLOATING_POINT
+#  define FLOATING_POINT
+# endif
 #endif
 
-#define _NO_LONGLONG
-#if defined WANT_PRINTF_LONG_LONG && defined __GNUC__
-# undef _NO_LONGLONG
+#define _NO_POS_ARGS
+#ifdef _WANT_IO_POS_ARGS
+# undef _NO_POS_ARGS
 #endif
 
 #include <_ansi.h>
+#include <reent.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <reent.h>
-
-#ifdef _HAVE_STDC
+#include <limits.h>
+#include <stdint.h>
+#include <wchar.h>
+#include <sys/lock.h>
 #include <stdarg.h>
-#else
-#include <varargs.h>
-#endif
-
 #include "local.h"
+#include "../stdlib/local.h"
 #include "fvwrite.h"
 #include "vfieeefp.h"
 
@@ -178,30 +167,167 @@ static char *rcsid = "$Id: vfprintf.c,v 1.34 2000/12/08 00:28:25 jjohnstn Exp $"
    This could be changed in the future should the _ldtoa_r code be
    preferred over _dtoa_r.  */
 #define _NO_LONGDBL
-#if defined WANT_IO_LONG_DBL && (LDBL_MANT_DIG > DBL_MANT_DIG)
+#if defined _WANT_IO_LONG_DOUBLE && (LDBL_MANT_DIG > DBL_MANT_DIG)
 #undef _NO_LONGDBL
 #endif
 
+#define _NO_LONGLONG
+#if defined _WANT_IO_LONG_LONG \
+	&& (defined __GNUC__ || __STDC_VERSION__ >= 199901L)
+# undef _NO_LONGLONG
+#endif
+
+#ifdef STRING_ONLY
+#define __SPRINT __ssprint_r
+#else
+#define __SPRINT __sprint_r
+#endif
+
+/* The __sprint_r/__ssprint_r functions are shared between all versions of
+   vfprintf and vfwprintf.  They must only be defined once, which we do in
+   the INTEGER_ONLY versions here. */
+#ifdef STRING_ONLY
+#ifdef INTEGER_ONLY
+int
+_DEFUN(__ssprint_r, (ptr, fp, uio),
+       struct _reent *ptr _AND
+       FILE *fp _AND
+       register struct __suio *uio)
+{
+	register size_t len;
+	register int w;
+	register struct __siov *iov;
+	register _CONST char *p = NULL;
+
+	iov = uio->uio_iov;
+	len = 0;
+
+	if (uio->uio_resid == 0) {
+		uio->uio_iovcnt = 0;
+		return (0);
+	}
+
+        do {
+		while (len == 0) {
+			p = iov->iov_base;
+			len = iov->iov_len;
+			iov++;
+		}
+		w = fp->_w;
+		if (len >= w && fp->_flags & (__SMBF | __SOPT)) {
+			/* must be asprintf family */
+			unsigned char *str;
+			int curpos = (fp->_p - fp->_bf._base);
+			/* Choose a geometric growth factor to avoid
+		 	 * quadratic realloc behavior, but use a rate less
+			 * than (1+sqrt(5))/2 to accomodate malloc
+		 	 * overhead. asprintf EXPECTS us to overallocate, so
+		 	 * that it can add a trailing \0 without
+		 	 * reallocating.  The new allocation should thus be
+		 	 * max(prev_size*1.5, curpos+len+1). */
+			int newsize = fp->_bf._size * 3 / 2;
+			if (newsize < curpos + len + 1)
+				newsize = curpos + len + 1;
+			if (fp->_flags & __SOPT)
+			{
+				/* asnprintf leaves original buffer alone.  */
+				str = (unsigned char *)_malloc_r (ptr, newsize);
+				if (!str)
+				{
+					ptr->_errno = ENOMEM;
+					goto err;
+				}
+				memcpy (str, fp->_bf._base, curpos);
+				fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
+			}
+			else
+			{
+				str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
+						newsize);
+				if (!str) {
+					/* Free unneeded buffer.  */
+					_free_r (ptr, fp->_bf._base);
+					/* Ensure correct errno, even if free
+					 * changed it.  */
+					ptr->_errno = ENOMEM;
+					goto err;
+				}
+			}
+			fp->_bf._base = str;
+			fp->_p = str + curpos;
+			fp->_bf._size = newsize;
+			w = len;
+			fp->_w = newsize - curpos;
+		}
+		if (len < w)
+			w = len;
+		(void)memmove ((_PTR) fp->_p, (_PTR) p, (size_t) (w));
+		fp->_w -= w;
+		fp->_p += w;
+		w = len;          /* pretend we copied all */
+		p += w;
+		len -= w;
+        } while ((uio->uio_resid -= w) != 0);
+
+	uio->uio_resid = 0;
+	uio->uio_iovcnt = 0;
+	return 0;
+
+err:
+  fp->_flags |= __SERR;
+  uio->uio_resid = 0;
+  uio->uio_iovcnt = 0;
+  return EOF;
+}
+#else /* !INTEGER_ONLY */
+int __ssprint_r (struct _reent *, FILE *, register struct __suio *);
+#endif /* !INTEGER_ONLY */
+
+#else /* !STRING_ONLY */
+#ifdef INTEGER_ONLY
 /*
  * Flush out all the vectors defined by the given uio,
  * then reset it so that it can be reused.
  */
-static int
-__sprint(fp, uio)
-	FILE *fp;
-	register struct __suio *uio;
+int
+_DEFUN(__sprint_r, (ptr, fp, uio),
+       struct _reent *ptr _AND
+       FILE *fp _AND
+       register struct __suio *uio)
 {
-	register int err;
+	register int err = 0;
 
 	if (uio->uio_resid == 0) {
 		uio->uio_iovcnt = 0;
 		return (0);
 	}
-	err = __sfvwrite(fp, uio);
+	if (fp->_flags2 & __SWID) {
+		struct __siov *iov;
+		wchar_t *p;
+		int i, len;
+
+		iov = uio->uio_iov;
+		for (; uio->uio_resid != 0;
+		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
+			p = (wchar_t *) iov->iov_base;
+			len = iov->iov_len / sizeof (wchar_t);
+			for (i = 0; i < len; i++) {
+				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
+					err = -1;
+					goto out;
+				}
+			}
+		}
+	} else
+		err = __sfvwrite_r(ptr, fp, uio);
+out:
 	uio->uio_resid = 0;
 	uio->uio_iovcnt = 0;
 	return (err);
 }
+#else /* !INTEGER_ONLY */
+int __sprint_r (struct _reent *, FILE *, register struct __suio *);
+#endif /* !INTEGER_ONLY */
 
 /*
  * Helper function for `fprintf to unbuffered unix file': creates a
@@ -209,66 +335,164 @@ __sprint(fp, uio)
  * worries about ungetc buffers and so forth.
  */
 static int
-__sbprintf(fp, fmt, ap)
-	register FILE *fp;
-	const char *fmt;
-	va_list ap;
+_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
+       struct _reent *rptr _AND
+       register FILE *fp   _AND
+       _CONST char *fmt  _AND
+       va_list ap)
 {
 	int ret;
 	FILE fake;
 	unsigned char buf[BUFSIZ];
 
 	/* copy the important variables */
-	fake._data = fp->_data;
 	fake._flags = fp->_flags & ~__SNBF;
+	fake._flags2 = fp->_flags2;
 	fake._file = fp->_file;
 	fake._cookie = fp->_cookie;
 	fake._write = fp->_write;
 
 	/* set up the buffer */
 	fake._bf._base = fake._p = buf;
-	fake._bf._size = fake._w = sizeof(buf);
+	fake._bf._size = fake._w = sizeof (buf);
 	fake._lbfsize = 0;	/* not actually used, but Just In Case */
+#ifndef __SINGLE_THREAD__
+	__lock_init_recursive (fake._lock);
+#endif
 
 	/* do the work, then copy any error status */
-	ret = VFPRINTF(&fake, fmt, ap);
-	if (ret >= 0 && fflush(&fake))
+	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
+	if (ret >= 0 && _fflush_r (rptr, &fake))
 		ret = EOF;
 	if (fake._flags & __SERR)
 		fp->_flags |= __SERR;
+
+#ifndef __SINGLE_THREAD__
+	__lock_close_recursive (fake._lock);
+#endif
 	return (ret);
 }
+#endif /* !STRING_ONLY */
 
 
+#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
+# include <locale.h>
+#endif
 #ifdef FLOATING_POINT
-#include <locale.h>
-#include <math.h>
-#include "floatio.h"
+# include <math.h>
 
-#define	BUF		(MAXEXP+MAXFRACT+1)	/* + decimal point */
-#define	DEFPREC		6
+/* For %La, an exponent of 15 bits occupies the exponent character, a
+   sign, and up to 5 digits.  */
+# define MAXEXPLEN		7
+# define DEFPREC		6
 
-#ifdef _NO_LONGDBL
-static char *cvt _PARAMS((struct _reent *, double, int, int, char *, int *, int, int *));
-#else
-static char *cvt _PARAMS((struct _reent *, _LONG_DOUBLE, int, int, char *, int *, int, int *));
-extern int  _ldcheck _PARAMS((_LONG_DOUBLE *));
-#endif
+# ifdef _NO_LONGDBL
 
-static int exponent _PARAMS((char *, int, int));
+extern char *_dtoa_r _PARAMS((struct _reent *, double, int,
+			      int, int *, int *, char **));
 
-#else /* no FLOATING_POINT */
+#  define _PRINTF_FLOAT_TYPE double
+#  define _DTOA_R _dtoa_r
+#  define FREXP frexp
 
-#define	BUF		40
+# else /* !_NO_LONGDBL */
+
+extern char *_ldtoa_r _PARAMS((struct _reent *, _LONG_DOUBLE, int,
+			      int, int *, int *, char **));
+
+extern int _EXFUN(_ldcheck,(_LONG_DOUBLE *));
+
+#  define _PRINTF_FLOAT_TYPE _LONG_DOUBLE
+#  define _DTOA_R _ldtoa_r
+/* FIXME - frexpl is not yet supported; and cvt infloops if (double)f
+   converts a finite value into infinity.  */
+/* #  define FREXP frexpl */
+#  define FREXP(f,e) ((_LONG_DOUBLE) frexp ((double)f, e))
+# endif /* !_NO_LONGDBL */
+
+static char *cvt(struct _reent *, _PRINTF_FLOAT_TYPE, int, int, char *, int *,
+                 int, int *, char *);
+
+static int exponent(char *, int, int);
 
 #endif /* FLOATING_POINT */
 
+/* BUF must be big enough for the maximum %#llo (assuming long long is
+   at most 64 bits, this would be 23 characters), the maximum
+   multibyte character %C, and the maximum default precision of %La
+   (assuming long double is at most 128 bits with 113 bits of
+   mantissa, this would be 29 characters).  %e, %f, and %g use
+   reentrant storage shared with mprec.  All other formats that use
+   buf get by with fewer characters.  Making BUF slightly bigger
+   reduces the need for malloc in %.*a and %S, when large precision or
+   long strings are processed.
+   The bigger size of 100 bytes is used on systems which allow number
+   strings using the locale's grouping character.  Since that's a multibyte
+   value, we should use a conservative value.
+   */
+#ifdef _WANT_IO_C99_FORMATS
+#define	BUF		100
+#else
+#define	BUF		40
+#endif
+#if defined _MB_CAPABLE && MB_LEN_MAX > BUF
+# undef BUF
+# define BUF MB_LEN_MAX
+#endif
+
+#ifndef _NO_LONGLONG
+# define quad_t long long
+# define u_quad_t unsigned long long
+#else
+# define quad_t long
+# define u_quad_t unsigned long
+#endif
+
+typedef quad_t * quad_ptr_t;
+typedef _PTR     void_ptr_t;
+typedef char *   char_ptr_t;
+typedef long *   long_ptr_t;
+typedef int  *   int_ptr_t;
+typedef short *  short_ptr_t;
+
+#ifndef _NO_POS_ARGS
+# ifdef NL_ARGMAX
+#  define MAX_POS_ARGS NL_ARGMAX
+# else
+#  define MAX_POS_ARGS 32
+# endif
+
+union arg_val
+{
+  int val_int;
+  u_int val_u_int;
+  long val_long;
+  u_long val_u_long;
+  float val_float;
+  double val_double;
+  _LONG_DOUBLE val__LONG_DOUBLE;
+  int_ptr_t val_int_ptr_t;
+  short_ptr_t val_short_ptr_t;
+  long_ptr_t val_long_ptr_t;
+  char_ptr_t val_char_ptr_t;
+  quad_ptr_t val_quad_ptr_t;
+  void_ptr_t val_void_ptr_t;
+  quad_t val_quad_t;
+  u_quad_t val_u_quad_t;
+  wint_t val_wint_t;
+};
+
+static union arg_val *
+_EXFUN(get_arg, (struct _reent *data, int n, char *fmt,
+                 va_list *ap, int *numargs, union arg_val *args,
+                 int *arg_type, char **last_fmt));
+#endif /* !_NO_POS_ARGS */
 
 /*
  * Macros for converting digits to letters and vice versa
  */
 #define	to_digit(c)	((c) - '0')
-#define is_digit(c)	((unsigned)to_digit(c) <= 9)
+#define is_digit(c)	((unsigned)to_digit (c) <= 9)
 #define	to_char(n)	((n) + '0')
 
 /*
@@ -280,32 +504,45 @@ static int exponent _PARAMS((char *, int, int));
 #define	LONGDBL		0x008		/* long double */
 #define	LONGINT		0x010		/* long integer */
 #ifndef _NO_LONGLONG
-#define	QUADINT		0x020		/* quad integer */
+# define QUADINT	0x020		/* quad integer */
 #else /* ifdef _NO_LONGLONG, make QUADINT equivalent to LONGINT, so
 	 that %lld behaves the same as %ld, not as %d, as expected if:
 	 sizeof (long long) = sizeof long > sizeof int  */
-#define	QUADINT		LONGINT
+# define QUADINT	LONGINT
 #endif
 #define	SHORTINT	0x040		/* short integer */
 #define	ZEROPAD		0x080		/* zero (as opposed to blank) pad */
 #define FPT		0x100		/* Floating point number */
+#ifdef _WANT_IO_C99_FORMATS
+# define CHARINT	0x200		/* char as integer */
+#else /* define as 0, to make SARG and UARG occupy fewer instructions  */
+# define CHARINT	0
+#endif
+#ifdef _WANT_IO_C99_FORMATS
+# define GROUPING	0x400		/* use grouping ("'" flag) */
+#endif
+
+int _EXFUN(_VFPRINTF_R, (struct _reent *, FILE *, _CONST char *, va_list));
 
-int 
-_DEFUN (VFPRINTF, (fp, fmt0, ap),
-	FILE * fp _AND
-	_CONST char *fmt0 _AND
-	va_list ap)
+#ifndef STRING_ONLY
+int
+_DEFUN(VFPRINTF, (fp, fmt0, ap),
+       FILE * fp         _AND
+       _CONST char *fmt0 _AND
+       va_list ap)
 {
-  CHECK_INIT (fp);
-  return _VFPRINTF_R (fp->_data, fp, fmt0, ap);
+  int result;
+  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
+  return result;
 }
-
-int 
-_DEFUN (_VFPRINTF_R, (data, fp, fmt0, ap),
-	struct _reent *data _AND
-	FILE * fp _AND
-	_CONST char *fmt0 _AND
-	va_list ap)
+#endif /* STRING_ONLY */
+
+int
+_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
+       struct _reent *data _AND
+       FILE * fp           _AND
+       _CONST char *fmt0   _AND
+       va_list ap)
 {
 	register char *fmt;	/* format string */
 	register int ch;	/* character from fmt */
@@ -313,38 +550,46 @@ _DEFUN (_VFPRINTF_R, (data, fp, fmt0, ap),
 	register char *cp;	/* handy char pointer (short term usage) */
 	register struct __siov *iovp;/* for PRINT macro */
 	register int flags;	/* flags as above */
+	char *fmt_anchor;       /* current format spec being processed */
+#ifndef _NO_POS_ARGS
+	int N;                  /* arg number */
+	int arg_index;          /* index into args processed directly */
+	int numargs;            /* number of varargs read */
+	char *saved_fmt;        /* saved fmt pointer */
+	union arg_val args[MAX_POS_ARGS];
+	int arg_type[MAX_POS_ARGS];
+	int is_pos_arg;         /* is current format positional? */
+	int old_is_pos_arg;     /* is current format positional? */
+#endif
 	int ret;		/* return value accumulator */
 	int width;		/* width from format (%8d), or 0 */
 	int prec;		/* precision from format (%.3d), or -1 */
 	char sign;		/* sign prefix (' ', '+', '-', or \0) */
-	wchar_t wc;
+#ifdef _WANT_IO_C99_FORMATS
+				/* locale specific numeric grouping */
+	char *thousands_sep;
+	size_t thsnd_len;
+	const char *grouping;
+#endif
 #ifdef FLOATING_POINT
-	char *decimal_point = localeconv()->decimal_point;
+	char *decimal_point = _localeconv_r (data)->decimal_point;
+	size_t decp_len = strlen (decimal_point);
 	char softsign;		/* temporary negative sign for floats */
-#ifdef _NO_LONGDBL
-	union { int i; double d; } _double_ = {0};
-	#define _fpvalue (_double_.d)
-#else
-	union { int i; _LONG_DOUBLE ld; } _long_double_ = {0};
-	#define _fpvalue (_long_double_.ld)
-	int tmp;  
-#endif
+	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
+# define _fpvalue (_double_.fp)
 	int expt;		/* integer value of exponent */
 	int expsize = 0;	/* character count for expstr */
-	int ndig;		/* actual number of digits returned by cvt */
-	char expstr[7];		/* buffer for exponent string */
+	char expstr[MAXEXPLEN];	/* buffer for exponent string */
+	int lead;		/* sig figs before decimal or group sep */
+#endif /* FLOATING_POINT */
+#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
+	int ndig = 0;		/* actual number of digits returned by cvt */
 #endif
-
-#ifndef _NO_LONGLONG
-#define	quad_t	  long long
-#define	u_quad_t  unsigned long long
+#ifdef _WANT_IO_C99_FORMATS
+	int nseps;		/* number of group separators with ' */
+	int nrepeats;		/* number of repeats of the last group */
 #endif
-
-#ifndef _NO_LONGLONG
 	u_quad_t _uquad;	/* integer arguments %[diouxX] */
-#else
-	u_long _uquad;
-#endif
 	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
 	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
 	int realsz;		/* field size expanded by dprec */
@@ -353,9 +598,13 @@ _DEFUN (_VFPRINTF_R, (data, fp, fmt0, ap),
 #define NIOV 8
 	struct __suio uio;	/* output information: summary */
 	struct __siov iov[NIOV];/* ... and individual io vectors */
-	char buf[BUF];		/* space for %c, %[diouxX], %[eEfgG] */
+	char buf[BUF];		/* space for %c, %S, %[diouxX], %[aA] */
 	char ox[2];		/* space for 0x hex-prefix */
-        int state = 0;          /* mbtowc calls from library must not change state */
+#ifdef _MB_CAPABLE
+	wchar_t wc;
+	mbstate_t state;        /* mbtowc calls from library must not change state */
+#endif
+	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
 
 	/*
 	 * Choose PADSIZE to trade efficiency vs. size.  If larger printf
@@ -368,6 +617,9 @@ _DEFUN (_VFPRINTF_R, (data, fp, fmt0, ap),
 	static _CONST char zeroes[PADSIZE] =
 	 {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'};
 
+#ifdef _MB_CAPABLE
+	memset (&state, '\0', sizeof (state));
+#endif
 	/*
 	 * BEWARE, these `goto error' on error, and PAD uses `n'.
 	 */
@@ -377,7 +629,7 @@ _DEFUN (_VFPRINTF_R, (data, fp, fmt0, ap),
 	uio.uio_resid += (len); \
 	iovp++; \
 	if (++uio.uio_iovcnt >= NIOV) { \
-		if (__sprint(fp, &uio)) \
+		if (__SPRINT(data, fp, &uio)) \
 			goto error; \
 		iovp = iov; \
 	} \
@@ -385,78 +637,153 @@ _DEFUN (_VFPRINTF_R, (data, fp, fmt0, ap),
 #define	PAD(howmany, with) { \
 	if ((n = (howmany)) > 0) { \
 		while (n > PADSIZE) { \
-			PRINT(with, PADSIZE); \
+			PRINT (with, PADSIZE); \
 			n -= PADSIZE; \
 		} \
-		PRINT(with, n); \
+		PRINT (with, n); \
 	} \
 }
+#define PRINTANDPAD(p, ep, len, with) { \
+	int n = (ep) - (p); \
+	if (n > (len)) \
+		n = (len); \
+	if (n > 0) \
+		PRINT((p), n); \
+	PAD((len) - (n > 0 ? n : 0), (with)); \
+}
 #define	FLUSH() { \
-	if (uio.uio_resid && __sprint(fp, &uio)) \
+	if (uio.uio_resid && __SPRINT(data, fp, &uio)) \
 		goto error; \
 	uio.uio_iovcnt = 0; \
 	iovp = iov; \
 }
 
+	/* Macros to support positional arguments */
+#ifndef _NO_POS_ARGS
+# define GET_ARG(n, ap, type)						\
+	(is_pos_arg							\
+	 ? (n < numargs							\
+	    ? args[n].val_##type					\
+	    : get_arg (data, n, fmt_anchor, &ap, &numargs, args,	\
+		       arg_type, &saved_fmt)->val_##type)		\
+	 : (arg_index++ < numargs					\
+	    ? args[n].val_##type					\
+	    : (numargs < MAX_POS_ARGS					\
+	       ? args[numargs++].val_##type = va_arg (ap, type)		\
+	       : va_arg (ap, type))))
+#else
+# define GET_ARG(n, ap, type) (va_arg (ap, type))
+#endif
+
 	/*
 	 * To extend shorts properly, we need both signed and unsigned
 	 * argument extraction methods.
 	 */
 #ifndef _NO_LONGLONG
 #define	SARG() \
-	(flags&QUADINT ? va_arg(ap, quad_t) : \
-	    flags&LONGINT ? va_arg(ap, long) : \
-	    flags&SHORTINT ? (long)(short)va_arg(ap, int) : \
-	    (long)va_arg(ap, int))
+	(flags&QUADINT ? GET_ARG (N, ap, quad_t) : \
+	    flags&LONGINT ? GET_ARG (N, ap, long) : \
+	    flags&SHORTINT ? (long)(short)GET_ARG (N, ap, int) : \
+	    flags&CHARINT ? (long)(signed char)GET_ARG (N, ap, int) : \
+	    (long)GET_ARG (N, ap, int))
 #define	UARG() \
-	(flags&QUADINT ? va_arg(ap, u_quad_t) : \
-	    flags&LONGINT ? va_arg(ap, u_long) : \
-	    flags&SHORTINT ? (u_long)(u_short)va_arg(ap, int) : \
-	    (u_long)va_arg(ap, u_int))
+	(flags&QUADINT ? GET_ARG (N, ap, u_quad_t) : \
+	    flags&LONGINT ? GET_ARG (N, ap, u_long) : \
+	    flags&SHORTINT ? (u_long)(u_short)GET_ARG (N, ap, int) : \
+	    flags&CHARINT ? (u_long)(unsigned char)GET_ARG (N, ap, int) : \
+	    (u_long)GET_ARG (N, ap, u_int))
 #else
 #define	SARG() \
-	(flags&LONGINT ? va_arg(ap, long) : \
-	    flags&SHORTINT ? (long)(short)va_arg(ap, int) : \
-	    (long)va_arg(ap, int))
+	(flags&LONGINT ? GET_ARG (N, ap, long) : \
+	    flags&SHORTINT ? (long)(short)GET_ARG (N, ap, int) : \
+	    flags&CHARINT ? (long)(signed char)GET_ARG (N, ap, int) : \
+	    (long)GET_ARG (N, ap, int))
 #define	UARG() \
-	(flags&LONGINT ? va_arg(ap, u_long) : \
-	    flags&SHORTINT ? (u_long)(u_short)va_arg(ap, int) : \
-	    (u_long)va_arg(ap, u_int))
+	(flags&LONGINT ? GET_ARG (N, ap, u_long) : \
+	    flags&SHORTINT ? (u_long)(u_short)GET_ARG (N, ap, int) : \
+	    flags&CHARINT ? (u_long)(unsigned char)GET_ARG (N, ap, int) : \
+	    (u_long)GET_ARG (N, ap, u_int))
 #endif
 
+#ifndef STRING_ONLY
+	/* Initialize std streams if not dealing with sprintf family.  */
+	CHECK_INIT (fp);
+	_flockfile (fp);
+
+	ORIENT(fp, -1);
+
 	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
-	if (cantwrite(fp))
+	if (cantwrite (fp)) {
+		_funlockfile (fp);
 		return (EOF);
+	}
 
 	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
 	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
-	    fp->_file >= 0)
-		return (__sbprintf(fp, fmt0, ap));
+	    fp->_file >= 0) {
+		_funlockfile (fp);
+		return (__sbprintf (data, fp, fmt0, ap));
+	}
+#else /* STRING_ONLY */
+        /* Create initial buffer if we are called by asprintf family.  */
+        if (fp->_flags & __SMBF && !fp->_bf._base)
+        {
+		fp->_bf._base = fp->_p = _malloc_r (data, 64);
+		if (!fp->_p)
+		{
+			data->_errno = ENOMEM;
+			return EOF;
+		}
+		fp->_bf._size = 64;
+        }
+#endif /* STRING_ONLY */
 
 	fmt = (char *)fmt0;
 	uio.uio_iov = iovp = iov;
 	uio.uio_resid = 0;
 	uio.uio_iovcnt = 0;
 	ret = 0;
+#ifndef _NO_POS_ARGS
+	arg_index = 0;
+	saved_fmt = NULL;
+	arg_type[0] = -1;
+	numargs = 0;
+	is_pos_arg = 0;
+#endif
 
 	/*
 	 * Scan the format for conversions (`%' character).
 	 */
 	for (;;) {
 	        cp = fmt;
-	        while ((n = _mbtowc_r(_REENT, &wc, fmt, MB_CUR_MAX, &state)) > 0) {
-			fmt += n;
-			if (wc == '%') {
-				fmt--;
-				break;
-			}
+#ifdef _MB_CAPABLE
+	        while ((n = __mbtowc (data, &wc, fmt, MB_CUR_MAX,
+				      __locale_charset (), &state)) != 0) {
+		    if (n < 0) {
+			/* Wave invalid chars through. */
+			memset (&state, 0, sizeof state);
+			n = 1;
+		    }
+                    else if (wc == '%')
+                        break;
+                    fmt += n;
 		}
+#else
+                while (*fmt != '\0' && *fmt != '%')
+                    fmt += 1;
+#endif
 		if ((m = fmt - cp) != 0) {
-			PRINT(cp, m);
+			PRINT (cp, m);
 			ret += m;
 		}
+#ifdef _MB_CAPABLE
 		if (n <= 0)
-			goto done;
+                    goto done;
+#else
+                if (*fmt == '\0')
+                    goto done;
+#endif
+		fmt_anchor = fmt;
 		fmt++;		/* skip over '%' */
 
 		flags = 0;
@@ -464,9 +791,28 @@ _DEFUN (_VFPRINTF_R, (data, fp, fmt0, ap),
 		width = 0;
 		prec = -1;
 		sign = '\0';
+#ifdef FLOATING_POINT
+		lead = 0;
+#endif
+#ifdef _WANT_IO_C99_FORMATS
+		nseps = nrepeats = 0;
+#endif
+#ifndef _NO_POS_ARGS
+		N = arg_index;
+		is_pos_arg = 0;
+#endif
 
 rflag:		ch = *fmt++;
 reswitch:	switch (ch) {
+#ifdef _WANT_IO_C99_FORMATS
+		case '\'':
+			thousands_sep = _localeconv_r (data)->thousands_sep;
+			thsnd_len = strlen (thousands_sep);
+			grouping = _localeconv_r (data)->grouping;
+			if (thsnd_len > 0 && grouping && *grouping)
+			  flags |= GROUPING;
+			goto rflag;
+#endif
 		case ' ':
 			/*
 			 * ``If the space and + flags both appear, the space
@@ -480,13 +826,47 @@ reswitch:	switch (ch) {
 			flags |= ALT;
 			goto rflag;
 		case '*':
+#ifndef _NO_POS_ARGS
+			/* we must check for positional arg used for dynamic width */
+			n = N;
+			old_is_pos_arg = is_pos_arg;
+			is_pos_arg = 0;
+			if (is_digit (*fmt)) {
+				char *old_fmt = fmt;
+
+				n = 0;
+				ch = *fmt++;
+				do {
+					n = 10 * n + to_digit (ch);
+					ch = *fmt++;
+				} while (is_digit (ch));
+
+				if (ch == '$') {
+					if (n <= MAX_POS_ARGS) {
+						n -= 1;
+						is_pos_arg = 1;
+					}
+					else
+						goto error;
+				}
+				else {
+					fmt = old_fmt;
+					goto rflag;
+				}
+			}
+#endif /* !_NO_POS_ARGS */
+
 			/*
 			 * ``A negative field width argument is taken as a
 			 * - flag followed by a positive field width.''
 			 *	-- ANSI X3J11
 			 * They don't exclude field widths read from args.
 			 */
-			if ((width = va_arg(ap, int)) >= 0)
+			width = GET_ARG (n, ap, int);
+#ifndef _NO_POS_ARGS
+			is_pos_arg = old_is_pos_arg;
+#endif
+			if (width >= 0)
 				goto rflag;
 			width = -width;
 			/* FALLTHROUGH */
@@ -498,13 +878,46 @@ reswitch:	switch (ch) {
 			goto rflag;
 		case '.':
 			if ((ch = *fmt++) == '*') {
-				n = va_arg(ap, int);
-				prec = n < 0 ? -1 : n;
+#ifndef _NO_POS_ARGS
+				/* we must check for positional arg used for dynamic width */
+				n = N;
+				old_is_pos_arg = is_pos_arg;
+				is_pos_arg = 0;
+				if (is_digit (*fmt)) {
+					char *old_fmt = fmt;
+
+					n = 0;
+					ch = *fmt++;
+					do {
+						n = 10 * n + to_digit (ch);
+						ch = *fmt++;
+					} while (is_digit (ch));
+
+					if (ch == '$') {
+						if (n <= MAX_POS_ARGS) {
+							n -= 1;
+							is_pos_arg = 1;
+						}
+						else
+							goto error;
+					}
+					else {
+						fmt = old_fmt;
+						goto rflag;
+					}
+				}
+#endif /* !_NO_POS_ARGS */
+				prec = GET_ARG (n, ap, int);
+#ifndef _NO_POS_ARGS
+				is_pos_arg = old_is_pos_arg;
+#endif
+				if (prec < 0)
+					prec = -1;
 				goto rflag;
 			}
 			n = 0;
-			while (is_digit(ch)) {
-				n = 10 * n + to_digit(ch);
+			while (is_digit (ch)) {
+				n = 10 * n + to_digit (ch);
 				ch = *fmt++;
 			}
 			prec = n < 0 ? -1 : n;
@@ -521,9 +934,20 @@ reswitch:	switch (ch) {
 		case '5': case '6': case '7': case '8': case '9':
 			n = 0;
 			do {
-				n = 10 * n + to_digit(ch);
+				n = 10 * n + to_digit (ch);
 				ch = *fmt++;
-			} while (is_digit(ch));
+			} while (is_digit (ch));
+#ifndef _NO_POS_ARGS
+			if (ch == '$') {
+				if (n <= MAX_POS_ARGS) {
+					N = n - 1;
+					is_pos_arg = 1;
+					goto rflag;
+				}
+				else
+					goto error;
+			}
+#endif /* !_NO_POS_ARGS */
 			width = n;
 			goto reswitch;
 #ifdef FLOATING_POINT
@@ -532,30 +956,94 @@ reswitch:	switch (ch) {
 			goto rflag;
 #endif
 		case 'h':
-			flags |= SHORTINT;
+#ifdef _WANT_IO_C99_FORMATS
+			if (*fmt == 'h') {
+				fmt++;
+				flags |= CHARINT;
+			} else
+#endif
+				flags |= SHORTINT;
 			goto rflag;
 		case 'l':
+#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
 			if (*fmt == 'l') {
 				fmt++;
 				flags |= QUADINT;
-			} else {
+			} else
+#endif
 				flags |= LONGINT;
-			}
 			goto rflag;
-		case 'q':
+		case 'q': /* extension */
 			flags |= QUADINT;
 			goto rflag;
+#ifdef _WANT_IO_C99_FORMATS
+		case 'j':
+		  if (sizeof (intmax_t) == sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    flags |= QUADINT;
+		  goto rflag;
+		case 'z':
+		  if (sizeof (size_t) < sizeof (int))
+		    /* POSIX states size_t is 16 or more bits, as is short.  */
+		    flags |= SHORTINT;
+		  else if (sizeof (size_t) == sizeof (int))
+		    /* no flag needed */;
+		  else if (sizeof (size_t) <= sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    /* POSIX states that at least one programming
+		       environment must support size_t no wider than
+		       long, but that means other environments can
+		       have size_t as wide as long long.  */
+		    flags |= QUADINT;
+		  goto rflag;
+		case 't':
+		  if (sizeof (ptrdiff_t) < sizeof (int))
+		    /* POSIX states ptrdiff_t is 16 or more bits, as
+		       is short.  */
+		    flags |= SHORTINT;
+		  else if (sizeof (ptrdiff_t) == sizeof (int))
+		    /* no flag needed */;
+		  else if (sizeof (ptrdiff_t) <= sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    /* POSIX states that at least one programming
+		       environment must support ptrdiff_t no wider than
+		       long, but that means other environments can
+		       have ptrdiff_t as wide as long long.  */
+		    flags |= QUADINT;
+		  goto rflag;
+		case 'C':
+#endif /* _WANT_IO_C99_FORMATS */
 		case 'c':
-			*(cp = buf) = va_arg(ap, int);
-			size = 1;
+			cp = buf;
+#ifdef _MB_CAPABLE
+			if (ch == 'C' || (flags & LONGINT)) {
+				mbstate_t ps;
+
+				memset ((_PTR)&ps, '\0', sizeof (mbstate_t));
+				if ((size = (int)_wcrtomb_r (data, cp,
+					       (wchar_t)GET_ARG (N, ap, wint_t),
+						&ps)) == -1) {
+					fp->_flags |= __SERR;
+					goto error;
+				}
+			}
+			else
+#endif /* _MB_CAPABLE */
+			{
+				*cp = GET_ARG (N, ap, int);
+				size = 1;
+			}
 			sign = '\0';
 			break;
-		case 'D':
+		case 'D':  /* extension */
 			flags |= LONGINT;
 			/*FALLTHROUGH*/
 		case 'd':
 		case 'i':
-			_uquad = SARG();
+			_uquad = SARG ();
 #ifndef _NO_LONGLONG
 			if ((quad_t)_uquad < 0)
 #else
@@ -569,93 +1057,169 @@ reswitch:	switch (ch) {
 			base = DEC;
 			goto number;
 #ifdef FLOATING_POINT
+# ifdef _WANT_IO_C99_FORMATS
+		case 'a':
+		case 'A':
+		case 'F':
+# endif
 		case 'e':
 		case 'E':
 		case 'f':
 		case 'g':
 		case 'G':
-			if (prec == -1) {
-				prec = DEFPREC;
-			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
-				prec = 1;
-			}
-
-#ifdef _NO_LONGDBL
+# ifdef _NO_LONGDBL
 			if (flags & LONGDBL) {
-				_fpvalue = (double) va_arg(ap, _LONG_DOUBLE);
+				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
 			} else {
-				_fpvalue = va_arg(ap, double);
+				_fpvalue = GET_ARG (N, ap, double);
 			}
 
-			/* do this before tricky precision changes */
-			if (isinf(_fpvalue)) {
+			/* do this before tricky precision changes
+
+			   If the output is infinite or NaN, leading
+			   zeros are not permitted.  Otherwise, scanf
+			   could not read what printf wrote.
+			 */
+			if (isinf (_fpvalue)) {
 				if (_fpvalue < 0)
 					sign = '-';
-				cp = "Inf";
+				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
+					cp = "INF";
+				else
+					cp = "inf";
 				size = 3;
+				flags &= ~ZEROPAD;
 				break;
 			}
-			if (isnan(_fpvalue)) {
-				cp = "NaN";
+			if (isnan (_fpvalue)) {
+				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
+					cp = "NAN";
+				else
+					cp = "nan";
 				size = 3;
+				flags &= ~ZEROPAD;
 				break;
 			}
 
-#else /* !_NO_LONGDBL */
-			
+# else /* !_NO_LONGDBL */
+
 			if (flags & LONGDBL) {
-				_fpvalue = va_arg(ap, _LONG_DOUBLE);
+				_fpvalue = GET_ARG (N, ap, _LONG_DOUBLE);
 			} else {
-				_fpvalue = (_LONG_DOUBLE)va_arg(ap, double);
+				_fpvalue = (_LONG_DOUBLE)GET_ARG (N, ap, double);
 			}
 
 			/* do this before tricky precision changes */
-			tmp = _ldcheck (&_fpvalue);
-			if (tmp == 2) {
+			expt = _ldcheck (&_fpvalue);
+			if (expt == 2) {
 				if (_fpvalue < 0)
 					sign = '-';
-				cp = "Inf";
+				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
+					cp = "INF";
+				else
+					cp = "inf";
 				size = 3;
+				flags &= ~ZEROPAD;
 				break;
 			}
-			if (tmp == 1) {
-				cp = "NaN";
+			if (expt == 1) {
+				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
+					cp = "NAN";
+				else
+					cp = "nan";
 				size = 3;
+				flags &= ~ZEROPAD;
 				break;
 			}
-#endif /* !_NO_LONGDBL */
+# endif /* !_NO_LONGDBL */
+
+# ifdef _WANT_IO_C99_FORMATS
+			if (ch == 'a' || ch == 'A') {
+				ox[0] = '0';
+				ox[1] = ch == 'a' ? 'x' : 'X';
+				flags |= HEXPREFIX;
+				if (prec >= BUF)
+				  {
+				    if ((malloc_buf =
+					 (char *)_malloc_r (data, prec + 1))
+					== NULL)
+				      {
+					fp->_flags |= __SERR;
+					goto error;
+				      }
+				    cp = malloc_buf;
+				  }
+				else
+				  cp = buf;
+			} else
+# endif /* _WANT_IO_C99_FORMATS */
+			if (prec == -1) {
+				prec = DEFPREC;
+			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
+				prec = 1;
+			}
 
 			flags |= FPT;
 
-			cp = cvt(data, _fpvalue, prec, flags, &softsign,
-				&expt, ch, &ndig);
+			cp = cvt (data, _fpvalue, prec, flags, &softsign,
+				  &expt, ch, &ndig, cp);
 
 			if (ch == 'g' || ch == 'G') {
 				if (expt <= -4 || expt > prec)
-					ch = (ch == 'g') ? 'e' : 'E';
+					ch -= 2; /* 'e' or 'E' */
 				else
 					ch = 'g';
-			} 
-			if (ch <= 'e') {	/* 'e' or 'E' fmt */
+			}
+# ifdef _WANT_IO_C99_FORMATS
+			else if (ch == 'F')
+				ch = 'f';
+# endif
+			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
 				--expt;
-				expsize = exponent(expstr, expt, ch);
+				expsize = exponent (expstr, expt, ch);
 				size = expsize + ndig;
 				if (ndig > 1 || flags & ALT)
 					++size;
-			} else if (ch == 'f') {		/* f fmt */
-				if (expt > 0) {
+# ifdef _WANT_IO_C99_FORMATS
+				flags &= ~GROUPING;
+# endif
+			} else {
+				if (ch == 'f') {		/* f fmt */
+					if (expt > 0) {
+						size = expt;
+						if (prec || flags & ALT)
+							size += prec + 1;
+					} else	/* "0.X" */
+						size = (prec || flags & ALT)
+							  ? prec + 2
+							  : 1;
+				} else if (expt >= ndig) { /* fixed g fmt */
 					size = expt;
-					if (prec || flags & ALT)
-						size += prec + 1;
-				} else	/* "0.X" */
-					size = prec + 2;
-			} else if (expt >= ndig) {	/* fixed g fmt */
-				size = expt;
-				if (flags & ALT)
-					++size;
-			} else
-				size = ndig + (expt > 0 ?
-					1 : 2 - expt);
+					if (flags & ALT)
+						++size;
+				} else
+					size = ndig + (expt > 0 ?
+						1 : 2 - expt);
+# ifdef _WANT_IO_C99_FORMATS
+				if ((flags & GROUPING) && expt > 0) {
+					/* space for thousands' grouping */
+					nseps = nrepeats = 0;
+					lead = expt;
+					while (*grouping != CHAR_MAX) {
+						if (lead <= *grouping)
+							break;
+						lead -= *grouping;
+						if (grouping[1]) {
+							nseps++;
+							grouping++;
+						} else
+							nrepeats++;
+					}
+					size += (nseps + nrepeats) * thsnd_len;
+				} else
+# endif
+					lead = expt;
+			}
 
 			if (softsign)
 				sign = '-';
@@ -664,22 +1228,29 @@ reswitch:	switch (ch) {
 		case 'n':
 #ifndef _NO_LONGLONG
 			if (flags & QUADINT)
-				*va_arg(ap, quad_t *) = ret;
-			else 
+				*GET_ARG (N, ap, quad_ptr_t) = ret;
+			else
 #endif
 			if (flags & LONGINT)
-				*va_arg(ap, long *) = ret;
+				*GET_ARG (N, ap, long_ptr_t) = ret;
 			else if (flags & SHORTINT)
-				*va_arg(ap, short *) = ret;
+				*GET_ARG (N, ap, short_ptr_t) = ret;
+#ifdef _WANT_IO_C99_FORMATS
+			else if (flags & CHARINT)
+				*GET_ARG (N, ap, char_ptr_t) = ret;
+#endif
 			else
-				*va_arg(ap, int *) = ret;
+				*GET_ARG (N, ap, int_ptr_t) = ret;
 			continue;	/* no output */
-		case 'O':
+		case 'O': /* extension */
 			flags |= LONGINT;
 			/*FALLTHROUGH*/
 		case 'o':
-			_uquad = UARG();
+			_uquad = UARG ();
 			base = OCT;
+#ifdef _WANT_IO_C99_FORMATS
+			flags &= ~GROUPING;
+#endif
 			goto nosign;
 		case 'p':
 			/*
@@ -690,22 +1261,100 @@ reswitch:	switch (ch) {
 			 *	-- ANSI X3J11
 			 */
 			/* NOSTRICT */
-			_uquad = (u_long)(unsigned _POINTER_INT)va_arg(ap, void *);
+			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
 			base = HEX;
 			xdigs = "0123456789abcdef";
 			flags |= HEXPREFIX;
-			ch = 'x';
+			ox[0] = '0';
+			ox[1] = ch = 'x';
 			goto nosign;
 		case 's':
-			if ((cp = va_arg(ap, char *)) == NULL)
+#ifdef _WANT_IO_C99_FORMATS
+		case 'S':
+#endif
+			sign = '\0';
+			cp = GET_ARG (N, ap, char_ptr_t);
+#ifndef __OPTIMIZE_SIZE__
+			/* Behavior is undefined if the user passed a
+			   NULL string when precision is not 0.
+			   However, if we are not optimizing for size,
+			   we might as well mirror glibc behavior.  */
+			if (cp == NULL) {
 				cp = "(null)";
+				size = ((unsigned) prec > 6U) ? 6 : prec;
+			}
+			else
+#endif /* __OPTIMIZE_SIZE__ */
+#ifdef _MB_CAPABLE
+			if (ch == 'S' || (flags & LONGINT)) {
+				mbstate_t ps;
+				_CONST wchar_t *wcp;
+
+				wcp = (_CONST wchar_t *)cp;
+				size = m = 0;
+				memset ((_PTR)&ps, '\0', sizeof (mbstate_t));
+
+				/* Count number of bytes needed for multibyte
+				   string that will be produced from widechar
+				   string.  */
+				if (prec >= 0) {
+					while (1) {
+						if (wcp[m] == L'\0')
+							break;
+						if ((n = (int)_wcrtomb_r (data,
+						     buf, wcp[m], &ps)) == -1) {
+							fp->_flags |= __SERR;
+							goto error;
+						}
+						if (n + size > prec)
+							break;
+						m += 1;
+						size += n;
+						if (size == prec)
+							break;
+					}
+				}
+				else {
+					if ((size = (int)_wcsrtombs_r (data,
+						   NULL, &wcp, 0, &ps)) == -1) {
+						fp->_flags |= __SERR;
+						goto error;
+					}
+					wcp = (_CONST wchar_t *)cp;
+				}
+
+				if (size == 0)
+					break;
+
+				if (size >= BUF) {
+					if ((malloc_buf =
+					     (char *)_malloc_r (data, size + 1))
+					    == NULL) {
+						fp->_flags |= __SERR;
+						goto error;
+					}
+					cp = malloc_buf;
+				} else
+					cp = buf;
+
+				/* Convert widechar string to multibyte string. */
+				memset ((_PTR)&ps, '\0', sizeof (mbstate_t));
+				if (_wcsrtombs_r (data, cp, &wcp, size, &ps)
+				    != size) {
+					fp->_flags |= __SERR;
+					goto error;
+				}
+				cp[size] = '\0';
+			}
+			else
+#endif /* _MB_CAPABLE */
 			if (prec >= 0) {
 				/*
 				 * can't use strlen; can only look for the
 				 * NUL in the first `prec' characters, and
-				 * strlen() will go further.
+				 * strlen () will go further.
 				 */
-				char *p = memchr(cp, 0, prec);
+				char *p = memchr (cp, 0, prec);
 
 				if (p != NULL) {
 					size = p - cp;
@@ -714,14 +1363,14 @@ reswitch:	switch (ch) {
 				} else
 					size = prec;
 			} else
-				size = strlen(cp);
-			sign = '\0';
+				size = strlen (cp);
+
 			break;
-		case 'U':
+		case 'U': /* extension */
 			flags |= LONGINT;
 			/*FALLTHROUGH*/
 		case 'u':
-			_uquad = UARG();
+			_uquad = UARG ();
 			base = DEC;
 			goto nosign;
 		case 'X':
@@ -729,12 +1378,18 @@ reswitch:	switch (ch) {
 			goto hex;
 		case 'x':
 			xdigs = "0123456789abcdef";
-hex:			_uquad = UARG();
+hex:			_uquad = UARG ();
 			base = HEX;
 			/* leading 0x/X only if non-zero */
-			if (flags & ALT && _uquad != 0)
+			if (flags & ALT && _uquad != 0) {
+				ox[0] = '0';
+				ox[1] = ch;
 				flags |= HEXPREFIX;
+			}
 
+#ifdef _WANT_IO_C99_FORMATS
+			flags &= ~GROUPING;
+#endif
 			/* unsigned conversions */
 nosign:			sign = '\0';
 			/*
@@ -760,7 +1415,7 @@ number:			if ((dprec = prec) >= 0)
 				switch (base) {
 				case OCT:
 					do {
-						*--cp = to_char(_uquad & 7);
+						*--cp = to_char (_uquad & 7);
 						_uquad >>= 3;
 					} while (_uquad);
 					/* handle octal leading 0 */
@@ -770,11 +1425,37 @@ number:			if ((dprec = prec) >= 0)
 
 				case DEC:
 					/* many numbers are 1 digit */
-					while (_uquad >= 10) {
-						*--cp = to_char(_uquad % 10);
-						_uquad /= 10;
+					if (_uquad < 10) {
+						*--cp = to_char(_uquad);
+						break;
 					}
-					*--cp = to_char(_uquad);
+#ifdef _WANT_IO_C99_FORMATS
+					ndig = 0;
+#endif
+					do {
+					  *--cp = to_char (_uquad % 10);
+#ifdef _WANT_IO_C99_FORMATS
+					  ndig++;
+					  /* If (*grouping == CHAR_MAX) then no
+					     more grouping */
+					  if ((flags & GROUPING)
+					      && ndig == *grouping
+					      && *grouping != CHAR_MAX
+					      && _uquad > 9) {
+					    cp -= thsnd_len;
+					    strncpy (cp, thousands_sep,
+						     thsnd_len);
+					    ndig = 0;
+					    /* If (grouping[1] == '\0') then we
+					       have to use *grouping character
+					       (last grouping rule) for all
+					       next cases. */
+					    if (grouping[1] != '\0')
+					      grouping++;
+					  }
+#endif
+					  _uquad /= 10;
+					} while (_uquad != 0);
 					break;
 
 				case HEX:
@@ -786,7 +1467,7 @@ number:			if ((dprec = prec) >= 0)
 
 				default:
 					cp = "bug in vfprintf: bad base";
-					size = strlen(cp);
+					size = strlen (cp);
 					goto skipsize;
 				}
 			}
@@ -826,6 +1507,7 @@ number:			if ((dprec = prec) >= 0)
 		 * required by a decimal [diouxX] precision, then print the
 		 * string proper, then emit zeroes required by any leftover
 		 * floating precision; finally, if LADJUST, pad with blanks.
+		 * If flags&FPT, ch must be in [aAeEfg].
 		 *
 		 * Compute actual size, so we know how much to pad.
 		 * size excludes decimal prec; realsz includes it.
@@ -833,130 +1515,195 @@ number:			if ((dprec = prec) >= 0)
 		realsz = dprec > size ? dprec : size;
 		if (sign)
 			realsz++;
-		else if (flags & HEXPREFIX)
+		if (flags & HEXPREFIX)
 			realsz+= 2;
 
 		/* right-adjusting blank padding */
 		if ((flags & (LADJUST|ZEROPAD)) == 0)
-			PAD(width - realsz, blanks);
+			PAD (width - realsz, blanks);
 
 		/* prefix */
-		if (sign) {
-			PRINT(&sign, 1);
-		} else if (flags & HEXPREFIX) {
-			ox[0] = '0';
-			ox[1] = ch;
-			PRINT(ox, 2);
-		}
+		if (sign)
+			PRINT (&sign, 1);
+		if (flags & HEXPREFIX)
+			PRINT (ox, 2);
 
 		/* right-adjusting zero padding */
 		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
-			PAD(width - realsz, zeroes);
+			PAD (width - realsz, zeroes);
 
 		/* leading zeroes from decimal precision */
-		PAD(dprec - size, zeroes);
+		PAD (dprec - size, zeroes);
 
 		/* the string or number proper */
 #ifdef FLOATING_POINT
 		if ((flags & FPT) == 0) {
-			PRINT(cp, size);
+			PRINT (cp, size);
 		} else {	/* glue together f_p fragments */
 			if (ch >= 'f') {	/* 'f' or 'g' */
 				if (_fpvalue == 0) {
 					/* kludge for __dtoa irregularity */
-					PRINT("0", 1);
-					if (expt < ndig || (flags & ALT) != 0) {
-						PRINT(decimal_point, 1);
-						PAD(ndig - 1, zeroes);
+					PRINT ("0", 1);
+					if (expt < ndig || flags & ALT) {
+						PRINT (decimal_point, decp_len);
+						PAD (ndig - 1, zeroes);
 					}
 				} else if (expt <= 0) {
-					PRINT("0", 1);
-					if(expt || ndig) {
-						PRINT(decimal_point, 1);
-						PAD(-expt, zeroes);
-						PRINT(cp, ndig);
+					PRINT ("0", 1);
+					if (expt || ndig || flags & ALT) {
+						PRINT (decimal_point, decp_len);
+						PAD (-expt, zeroes);
+						PRINT (cp, ndig);
 					}
-				} else if (expt >= ndig) {
-					PRINT(cp, ndig);
-					PAD(expt - ndig, zeroes);
-					if (flags & ALT)
-						PRINT(".", 1);
 				} else {
-					PRINT(cp, expt);
-					cp += expt;
-					PRINT(".", 1);
-					PRINT(cp, ndig-expt);
+					char *convbuf = cp;
+					PRINTANDPAD(cp, convbuf + ndig,
+						    lead, zeroes);
+					cp += lead;
+#ifdef _WANT_IO_C99_FORMATS
+					if (flags & GROUPING) {
+					    while (nseps > 0 || nrepeats > 0) {
+						if (nrepeats > 0)
+						    nrepeats--;
+						else {
+						    grouping--;
+						    nseps--;
+						}
+						PRINT(thousands_sep, thsnd_len);
+						PRINTANDPAD (cp, convbuf + ndig,
+							     *grouping, zeroes);
+						cp += *grouping;
+					    }
+					    if (cp > convbuf + ndig)
+						cp = convbuf + ndig;
+					}
+#endif
+					if (expt < ndig || flags & ALT)
+					    PRINT (decimal_point, decp_len);
+					PRINTANDPAD (cp, convbuf + ndig,
+						     ndig - expt, zeroes);
 				}
-			} else {	/* 'e' or 'E' */
+			} else {	/* 'a', 'A', 'e', or 'E' */
 				if (ndig > 1 || flags & ALT) {
-					ox[0] = *cp++;
-					ox[1] = '.';
-					PRINT(ox, 2);
-                                       if (_fpvalue) {
-						PRINT(cp, ndig-1);
+					PRINT (cp, 1);
+					cp++;
+					PRINT (decimal_point, decp_len);
+					if (_fpvalue) {
+						PRINT (cp, ndig - 1);
 					} else	/* 0.[0..] */
 						/* __dtoa irregularity */
-						PAD(ndig - 1, zeroes);
+						PAD (ndig - 1, zeroes);
 				} else	/* XeYYY */
-					PRINT(cp, 1);
-				PRINT(expstr, expsize);
+					PRINT (cp, 1);
+				PRINT (expstr, expsize);
 			}
 		}
-#else
-		PRINT(cp, size);
+#else /* !FLOATING_POINT */
+		PRINT (cp, size);
 #endif
 		/* left-adjusting padding (always blank) */
 		if (flags & LADJUST)
-			PAD(width - realsz, blanks);
+			PAD (width - realsz, blanks);
 
 		/* finally, adjust ret */
 		ret += width > realsz ? width : realsz;
 
-		FLUSH();	/* copy out the I/O vectors */
+		FLUSH ();	/* copy out the I/O vectors */
+
+                if (malloc_buf != NULL) {
+			_free_r (data, malloc_buf);
+			malloc_buf = NULL;
+		}
 	}
 done:
-	FLUSH();
+	FLUSH ();
 error:
-	return (__sferror(fp) ? EOF : ret);
+	if (malloc_buf != NULL)
+		_free_r (data, malloc_buf);
+#ifndef STRING_ONLY
+	_funlockfile (fp);
+#endif
+	return (__sferror (fp) ? EOF : ret);
 	/* NOTREACHED */
 }
 
 #ifdef FLOATING_POINT
 
-#ifdef _NO_LONGDBL
-extern char *_dtoa_r _PARAMS((struct _reent *, double, int,
-			      int, int *, int *, char **));
-#else
-extern char *_ldtoa_r _PARAMS((struct _reent *, _LONG_DOUBLE, int,
-			      int, int *, int *, char **));
-#undef word0
-#define word0(x) ldword0(x)
-#endif
-
+/* Using reentrant DATA, convert finite VALUE into a string of digits
+   with no decimal point, using NDIGITS precision and FLAGS as guides
+   to whether trailing zeros must be included.  Set *SIGN to nonzero
+   if VALUE was negative.  Set *DECPT to the exponent plus one.  Set
+   *LENGTH to the length of the returned string.  CH must be one of
+   [aAeEfFgG]; if it is [aA], then the return string lives in BUF,
+   otherwise the return value shares the mprec reentrant storage.  */
 static char *
-cvt(data, value, ndigits, flags, sign, decpt, ch, length)
-	struct _reent *data;
-#ifdef _NO_LONGDBL
-	double value;
-#else
-	_LONG_DOUBLE value;
-#endif
-	int ndigits, flags, *decpt, ch, *length;
-	char *sign;
+cvt(struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
+    char *sign, int *decpt, int ch, int *length, char *buf)
 {
 	int mode, dsgn;
 	char *digits, *bp, *rve;
-#ifdef _NO_LONGDBL
-        union double_union tmp;
-#else
-        struct ldieee *ldptr;
-#endif
+# ifdef _NO_LONGDBL
+	union double_union tmp;
 
-	if (ch == 'f') {
+	tmp.d = value;
+	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
+		value = -value;
+		*sign = '-';
+	} else
+		*sign = '\000';
+# else /* !_NO_LONGDBL */
+	union
+	{
+	  struct ldieee ieee;
+	  _LONG_DOUBLE val;
+	} ld;
+
+	ld.val = value;
+	if (ld.ieee.sign) { /* this will check for < 0 and -0.0 */
+		value = -value;
+		*sign = '-';
+	} else
+		*sign = '\000';
+# endif /* !_NO_LONGDBL */
+
+# ifdef _WANT_IO_C99_FORMATS
+	if (ch == 'a' || ch == 'A') {
+		/* This code assumes FLT_RADIX is a power of 2.  The initial
+		   division ensures the digit before the decimal will be less
+		   than FLT_RADIX (unless it is rounded later).	 There is no
+		   loss of precision in these calculations.  */
+		value = FREXP (value, decpt) / 8;
+		if (!value)
+			*decpt = 1;
+		digits = ch == 'a' ? "0123456789abcdef" : "0123456789ABCDEF";
+		bp = buf;
+		do {
+			value *= 16;
+			mode = (int) value;
+			value -= mode;
+			*bp++ = digits[mode];
+		} while (ndigits-- && value);
+		if (value > 0.5 || (value == 0.5 && mode & 1)) {
+			/* round to even */
+			rve = bp;
+			while (*--rve == digits[0xf]) {
+				*rve = '0';
+			}
+			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
+		} else {
+			while (ndigits-- >= 0) {
+				*bp++ = '0';
+			}
+		}
+		*length = bp - buf;
+		return buf;
+	}
+# endif /* _WANT_IO_C99_FORMATS */
+	if (ch == 'f' || ch == 'F') {
 		mode = 3;		/* ndigits after the decimal point */
 	} else {
-		/* To obtain ndigits after the decimal point for the 'e' 
-		 * and 'E' formats, round to ndigits + 1 significant 
+		/* To obtain ndigits after the decimal point for the 'e'
+		 * and 'E' formats, round to ndigits + 1 significant
 		 * figures.
 		 */
 		if (ch == 'e' || ch == 'E') {
@@ -965,30 +1712,11 @@ cvt(data, value, ndigits, flags, sign, decpt, ch, length)
 		mode = 2;		/* ndigits significant digits */
 	}
 
-#ifdef _NO_LONGDBL
-        tmp.d = value;
-
-	if (word0(tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
-		value = -value;
-		*sign = '-';
-        } else
-		*sign = '\000';
-
-	digits = _dtoa_r(data, value, mode, ndigits, decpt, &dsgn, &rve);
-#else /* !_NO_LONGDBL */
-	ldptr = (struct ldieee *)&value;
-	if (ldptr->sign) { /* this will check for < 0 and -0.0 */
-		value = -value;
-		*sign = '-';
-        } else
-		*sign = '\000';
-
-	digits = _ldtoa_r(data, value, mode, ndigits, decpt, &dsgn, &rve);
-#endif /* !_NO_LONGDBL */
+	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
 
 	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
 		bp = digits + ndigits;
-		if (ch == 'f') {
+		if (ch == 'f' || ch == 'F') {
 			if (*digits == '0' && value)
 				*decpt = -ndigits + 1;
 			bp += *decpt;
@@ -1003,33 +1731,460 @@ cvt(data, value, ndigits, flags, sign, decpt, ch, length)
 }
 
 static int
-exponent(p0, exp, fmtch)
-	char *p0;
-	int exp, fmtch;
+exponent(char *p0, int exp, int fmtch)
 {
 	register char *p, *t;
-	char expbuf[40];
+	char expbuf[MAXEXPLEN];
+# ifdef _WANT_IO_C99_FORMATS
+	int isa = fmtch == 'a' || fmtch == 'A';
+# else
+#  define isa 0
+# endif
 
 	p = p0;
-	*p++ = fmtch;
+	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
 	if (exp < 0) {
 		exp = -exp;
 		*p++ = '-';
 	}
 	else
 		*p++ = '+';
-	t = expbuf + 40;
+	t = expbuf + MAXEXPLEN;
 	if (exp > 9) {
 		do {
-			*--t = to_char(exp % 10);
+			*--t = to_char (exp % 10);
 		} while ((exp /= 10) > 9);
-		*--t = to_char(exp);
-		for (; t < expbuf + 40; *p++ = *t++);
+		*--t = to_char (exp);
+		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
 	}
 	else {
-		*p++ = '0';
-		*p++ = to_char(exp);
+		if (!isa)
+			*p++ = '0';
+		*p++ = to_char (exp);
 	}
 	return (p - p0);
 }
 #endif /* FLOATING_POINT */
+
+
+#ifndef _NO_POS_ARGS
+
+/* Positional argument support.
+   Written by Jeff Johnston
+
+   Copyright (c) 2002 Red Hat Incorporated.
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+      Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+      Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+      The name of Red Hat Incorporated may not be used to endorse
+      or promote products derived from this software without specific
+      prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL RED HAT INCORPORATED BE LIABLE FOR ANY
+   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
+
+/* The below constant state tables are shared between all versions of
+   vfprintf and vfwprintf.  They must only be defined once, which we do in
+   the STRING_ONLY/INTEGER_ONLY versions here. */
+#if defined (STRING_ONLY) && defined(INTEGER_ONLY)
+
+_CONST __CH_CLASS __chclass[256] = {
+  /* 00-07 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* 08-0f */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* 10-17 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* 18-1f */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* 20-27 */  FLAG,    OTHER,   OTHER,   FLAG,    DOLLAR,  OTHER,   OTHER,   FLAG,
+  /* 28-2f */  OTHER,   OTHER,   STAR,    FLAG,    OTHER,   FLAG,    DOT,     OTHER,
+  /* 30-37 */  ZERO,    DIGIT,   DIGIT,   DIGIT,   DIGIT,   DIGIT,   DIGIT,   DIGIT,
+  /* 38-3f */  DIGIT,   DIGIT,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* 40-47 */  OTHER,   SPEC,    OTHER,   SPEC,    SPEC,    SPEC,    SPEC,    SPEC,
+  /* 48-4f */  OTHER,   OTHER,   OTHER,   OTHER,   MODFR,   OTHER,   OTHER,   SPEC,
+  /* 50-57 */  OTHER,   OTHER,   OTHER,   SPEC,    OTHER,   SPEC,    OTHER,   OTHER,
+  /* 58-5f */  SPEC,    OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* 60-67 */  OTHER,   SPEC,    OTHER,   SPEC,    SPEC,    SPEC,    SPEC,    SPEC,
+  /* 68-6f */  MODFR,   SPEC,    MODFR,   OTHER,   MODFR,   OTHER,   SPEC,    SPEC,
+  /* 70-77 */  SPEC,    MODFR,   OTHER,   SPEC,    MODFR,   SPEC,    OTHER,   OTHER,
+  /* 78-7f */  SPEC,    OTHER,   MODFR,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* 80-87 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* 88-8f */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* 90-97 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* 98-9f */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* a0-a7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* a8-af */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* b0-b7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* b8-bf */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* c0-c7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* c8-cf */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* d0-d7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* d8-df */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* e0-e7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* e8-ef */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* f0-f7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+  /* f8-ff */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
+};
+
+_CONST __STATE __state_table[MAX_STATE][MAX_CH_CLASS] = {
+  /*             '0'     '1-9'     '$'     MODFR    SPEC    '.'     '*'    FLAG    OTHER */
+  /* START */  { SFLAG,   WDIG,    DONE,   SMOD,    DONE,   SDOT,  VARW,   SFLAG,  DONE },
+  /* SFLAG */  { SFLAG,   WDIG,    DONE,   SMOD,    DONE,   SDOT,  VARW,   SFLAG,  DONE },
+  /* WDIG  */  { DONE,    DONE,    WIDTH,  SMOD,    DONE,   SDOT,  DONE,   DONE,   DONE },
+  /* WIDTH */  { DONE,    DONE,    DONE,   SMOD,    DONE,   SDOT,  DONE,   DONE,   DONE },
+  /* SMOD  */  { DONE,    DONE,    DONE,   DONE,    DONE,   DONE,  DONE,   DONE,   DONE },
+  /* SDOT  */  { SDOT,    PREC,    DONE,   SMOD,    DONE,   DONE,  VARP,   DONE,   DONE },
+  /* VARW  */  { DONE,    VWDIG,   DONE,   SMOD,    DONE,   SDOT,  DONE,   DONE,   DONE },
+  /* VARP  */  { DONE,    VPDIG,   DONE,   SMOD,    DONE,   DONE,  DONE,   DONE,   DONE },
+  /* PREC  */  { DONE,    DONE,    DONE,   SMOD,    DONE,   DONE,  DONE,   DONE,   DONE },
+  /* VWDIG */  { DONE,    DONE,    WIDTH,  DONE,    DONE,   DONE,  DONE,   DONE,   DONE },
+  /* VPDIG */  { DONE,    DONE,    PREC,   DONE,    DONE,   DONE,  DONE,   DONE,   DONE },
+};
+
+_CONST __ACTION __action_table[MAX_STATE][MAX_CH_CLASS] = {
+  /*             '0'     '1-9'     '$'     MODFR    SPEC    '.'     '*'    FLAG    OTHER */
+  /* START */  { NOOP,    NUMBER,  NOOP,   GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
+  /* SFLAG */  { NOOP,    NUMBER,  NOOP,   GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
+  /* WDIG  */  { NOOP,    NOOP,    GETPOS, GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
+  /* WIDTH */  { NOOP,    NOOP,    NOOP,   GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
+  /* SMOD  */  { NOOP,    NOOP,    NOOP,   NOOP,    GETARG, NOOP,  NOOP,   NOOP,   NOOP },
+  /* SDOT  */  { NOOP,    SKIPNUM, NOOP,   GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
+  /* VARW  */  { NOOP,    NUMBER,  NOOP,   GETPW,   GETPWB, GETPW, NOOP,   NOOP,   NOOP },
+  /* VARP  */  { NOOP,    NUMBER,  NOOP,   GETPW,   GETPWB, NOOP,  NOOP,   NOOP,   NOOP },
+  /* PREC  */  { NOOP,    NOOP,    NOOP,   GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
+  /* VWDIG */  { NOOP,    NOOP,    PWPOS,  NOOP,    NOOP,   NOOP,  NOOP,   NOOP,   NOOP },
+  /* VPDIG */  { NOOP,    NOOP,    PWPOS,  NOOP,    NOOP,   NOOP,  NOOP,   NOOP,   NOOP },
+};
+
+#endif /* STRING_ONLY && INTEGER_ONLY */
+
+/* function to get positional parameter N where n = N - 1 */
+static union arg_val *
+_DEFUN(get_arg, (data, n, fmt, ap, numargs_p, args, arg_type, last_fmt),
+       struct _reent *data _AND
+       int n               _AND
+       char *fmt           _AND
+       va_list *ap         _AND
+       int *numargs_p      _AND
+       union arg_val *args _AND
+       int *arg_type       _AND
+       char **last_fmt)
+{
+  int ch;
+  int number, flags;
+  int spec_type;
+  int numargs = *numargs_p;
+  __CH_CLASS chtype;
+  __STATE state, next_state;
+  __ACTION action;
+  int pos, last_arg;
+  int max_pos_arg = n;
+  /* Only need types that can be reached via vararg promotions.  */
+  enum types { INT, LONG_INT, QUAD_INT, CHAR_PTR, DOUBLE, LONG_DOUBLE, WIDE_CHAR };
+# ifdef _MB_CAPABLE
+  wchar_t wc;
+  mbstate_t wc_state;
+  int nbytes;
+# endif
+
+  /* if this isn't the first call, pick up where we left off last time */
+  if (*last_fmt != NULL)
+    fmt = *last_fmt;
+
+# ifdef _MB_CAPABLE
+  memset (&wc_state, '\0', sizeof (wc_state));
+# endif
+
+  /* we need to process either to end of fmt string or until we have actually
+     read the desired parameter from the vararg list. */
+  while (*fmt && n >= numargs)
+    {
+# ifdef _MB_CAPABLE
+      while ((nbytes = __mbtowc (data, &wc, fmt, MB_CUR_MAX,
+				 __locale_charset (), &wc_state)) > 0)
+	{
+	  fmt += nbytes;
+	  if (wc == '%')
+	    break;
+	}
+
+      if (nbytes <= 0)
+	break;
+# else
+      while (*fmt != '\0' && *fmt != '%')
+	fmt += 1;
+
+      if (*fmt == '\0')
+	break;
+# endif /* ! _MB_CAPABLE */
+      state = START;
+      flags = 0;
+      pos = -1;
+      number = 0;
+      spec_type = INT;
+
+      /* Use state/action table to process format specifiers.  We ignore invalid
+         formats and we are only interested in information that tells us how to
+         read the vararg list. */
+      while (state != DONE)
+	{
+	  ch = *fmt++;
+	  chtype = __chclass[ch];
+	  next_state = __state_table[state][chtype];
+	  action = __action_table[state][chtype];
+	  state = next_state;
+
+	  switch (action)
+	    {
+	    case GETMOD:  /* we have format modifier */
+	      switch (ch)
+		{
+		case 'h':
+		  /* No flag needed, since short and char promote to int.  */
+		  break;
+		case 'L':
+		  flags |= LONGDBL;
+		  break;
+		case 'q':
+		  flags |= QUADINT;
+		  break;
+# ifdef _WANT_IO_C99_FORMATS
+		case 'j':
+		  if (sizeof (intmax_t) == sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    flags |= QUADINT;
+		  break;
+		case 'z':
+		  if (sizeof (size_t) <= sizeof (int))
+		    /* no flag needed */;
+		  else if (sizeof (size_t) <= sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    /* POSIX states that at least one programming
+		       environment must support size_t no wider than
+		       long, but that means other environments can
+		       have size_t as wide as long long.  */
+		    flags |= QUADINT;
+		  break;
+		case 't':
+		  if (sizeof (ptrdiff_t) <= sizeof (int))
+		    /* no flag needed */;
+		  else if (sizeof (ptrdiff_t) <= sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    /* POSIX states that at least one programming
+		       environment must support ptrdiff_t no wider than
+		       long, but that means other environments can
+		       have ptrdiff_t as wide as long long.  */
+		    flags |= QUADINT;
+		  break;
+# endif /* _WANT_IO_C99_FORMATS */
+		case 'l':
+		default:
+# if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
+		  if (*fmt == 'l')
+		    {
+		      flags |= QUADINT;
+		      ++fmt;
+		    }
+		  else
+# endif
+		    flags |= LONGINT;
+		  break;
+		}
+	      break;
+	    case GETARG: /* we have format specifier */
+	      {
+		numargs &= (MAX_POS_ARGS - 1);
+		/* process the specifier and translate it to a type to fetch from varargs */
+		switch (ch)
+		  {
+		  case 'd':
+		  case 'i':
+		  case 'o':
+		  case 'x':
+		  case 'X':
+		  case 'u':
+		    if (flags & LONGINT)
+		      spec_type = LONG_INT;
+# ifndef _NO_LONGLONG
+		    else if (flags & QUADINT)
+		      spec_type = QUAD_INT;
+# endif
+		    else
+		      spec_type = INT;
+		    break;
+		  case 'D':
+		  case 'U':
+		  case 'O':
+		    spec_type = LONG_INT;
+		    break;
+# ifdef _WANT_IO_C99_FORMATS
+		  case 'a':
+		  case 'A':
+		  case 'F':
+# endif
+		  case 'f':
+		  case 'g':
+		  case 'G':
+		  case 'E':
+		  case 'e':
+# ifndef _NO_LONGDBL
+		    if (flags & LONGDBL)
+		      spec_type = LONG_DOUBLE;
+		    else
+# endif
+		      spec_type = DOUBLE;
+		    break;
+		  case 's':
+# ifdef _WANT_IO_C99_FORMATS
+		  case 'S':
+# endif
+		  case 'p':
+		  case 'n':
+		    spec_type = CHAR_PTR;
+		    break;
+		  case 'c':
+# ifdef _WANT_IO_C99_FORMATS
+		    if (flags & LONGINT)
+		      spec_type = WIDE_CHAR;
+		    else
+# endif
+		      spec_type = INT;
+		    break;
+# ifdef _WANT_IO_C99_FORMATS
+		  case 'C':
+		    spec_type = WIDE_CHAR;
+		    break;
+# endif
+		  }
+
+		/* if we have a positional parameter, just store the type, otherwise
+		   fetch the parameter from the vararg list */
+		if (pos != -1)
+		  arg_type[pos] = spec_type;
+		else
+		  {
+		    switch (spec_type)
+		      {
+		      case LONG_INT:
+			args[numargs++].val_long = va_arg (*ap, long);
+			break;
+		      case QUAD_INT:
+			args[numargs++].val_quad_t = va_arg (*ap, quad_t);
+			break;
+		      case WIDE_CHAR:
+			args[numargs++].val_wint_t = va_arg (*ap, wint_t);
+			break;
+		      case INT:
+			args[numargs++].val_int = va_arg (*ap, int);
+			break;
+		      case CHAR_PTR:
+			args[numargs++].val_char_ptr_t = va_arg (*ap, char *);
+			break;
+		      case DOUBLE:
+			args[numargs++].val_double = va_arg (*ap, double);
+			break;
+		      case LONG_DOUBLE:
+			args[numargs++].val__LONG_DOUBLE = va_arg (*ap, _LONG_DOUBLE);
+			break;
+		      }
+		  }
+	      }
+	      break;
+	    case GETPOS: /* we have positional specifier */
+	      if (arg_type[0] == -1)
+		memset (arg_type, 0, sizeof (int) * MAX_POS_ARGS);
+	      pos = number - 1;
+	      max_pos_arg = (max_pos_arg > pos ? max_pos_arg : pos);
+	      break;
+	    case PWPOS:  /* we have positional specifier for width or precision */
+	      if (arg_type[0] == -1)
+		memset (arg_type, 0, sizeof (int) * MAX_POS_ARGS);
+	      number -= 1;
+	      arg_type[number] = INT;
+	      max_pos_arg = (max_pos_arg > number ? max_pos_arg : number);
+	      break;
+	    case GETPWB: /* we require format pushback */
+	      --fmt;
+	      /* fallthrough */
+	    case GETPW:  /* we have a variable precision or width to acquire */
+	      args[numargs++].val_int = va_arg (*ap, int);
+	      break;
+	    case NUMBER: /* we have a number to process */
+	      number = (ch - '0');
+	      while ((ch = *fmt) != '\0' && is_digit (ch))
+		{
+		  number = number * 10 + (ch - '0');
+		  ++fmt;
+		}
+	      break;
+	    case SKIPNUM: /* we have a number to skip */
+	      while ((ch = *fmt) != '\0' && is_digit (ch))
+		++fmt;
+	      break;
+	    case NOOP:
+	    default:
+	      break; /* do nothing */
+	    }
+	}
+    }
+
+  /* process all arguments up to at least the one we are looking for and if we
+     have seen the end of the string, then process up to the max argument needed */
+  if (*fmt == '\0')
+    last_arg = max_pos_arg;
+  else
+    last_arg = n;
+
+  while (numargs <= last_arg)
+    {
+      switch (arg_type[numargs])
+	{
+	case LONG_INT:
+	  args[numargs++].val_long = va_arg (*ap, long);
+	  break;
+	case QUAD_INT:
+	  args[numargs++].val_quad_t = va_arg (*ap, quad_t);
+	  break;
+	case CHAR_PTR:
+	  args[numargs++].val_char_ptr_t = va_arg (*ap, char *);
+	  break;
+	case DOUBLE:
+	  args[numargs++].val_double = va_arg (*ap, double);
+	  break;
+	case LONG_DOUBLE:
+	  args[numargs++].val__LONG_DOUBLE = va_arg (*ap, _LONG_DOUBLE);
+	  break;
+	case WIDE_CHAR:
+	  args[numargs++].val_wint_t = va_arg (*ap, wint_t);
+	  break;
+	case INT:
+	default:
+	  args[numargs++].val_int = va_arg (*ap, int);
+	  break;
+	}
+    }
+
+  /* alter the global numargs value and keep a reference to the last bit of the fmt
+     string we processed here because the caller will continue processing where we started */
+  *numargs_p = numargs;
+  *last_fmt = fmt;
+  return &args[n];
+}
+#endif /* !_NO_POS_ARGS */
diff --git a/msys/rt/src/newlib/libc/stdio/vfwprintf.c b/msys/rt/src/newlib/libc/stdio/vfwprintf.c
new file mode 100644
index 0000000..9fc3529
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdio/vfwprintf.c
@@ -0,0 +1,1942 @@
+/*
+ * Copyright (c) 1990 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Chris Torek.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+FUNCTION
+<<vfwprintf>>, <<vwprintf>>, <<vswprintf>>---wide character format argument list
+
+INDEX
+	vfwprintf
+INDEX
+	_vfwprintf_r
+INDEX
+	vwprintf
+INDEX
+	_vwprintf_r
+INDEX
+	vswprintf
+INDEX
+	_vswprintf_r
+
+ANSI_SYNOPSIS
+	#include <stdio.h>
+	#include <stdarg.h>
+	#include <wchar.h>
+	int vwprintf(const wchar_t *<[fmt]>, va_list <[list]>);
+	int vfwprintf(FILE *<[fp]>, const wchar_t *<[fmt]>, va_list <[list]>);
+	int vswprintf(wchar_t *<[str]>, size_t <[size]>, const wchar_t *<[fmt]>,
+			va_list <[list]>);
+
+	int _vwprintf_r(struct _reent *<[reent]>, const wchar_t *<[fmt]>,
+		va_list <[list]>);
+	int _vfwprintf_r(struct _reent *<[reent]>, FILE *<[fp]>,
+		const wchar_t *<[fmt]>, va_list <[list]>);
+	int _vswprintf_r(struct _reent *<[reent]>, wchar_t *<[str]>,
+		size_t <[size]>, const wchar_t *<[fmt]>, va_list <[list]>);
+
+DESCRIPTION
+<<vwprintf>>, <<vfwprintf>> and <<vswprintf>> are (respectively) variants
+of <<wprintf>>, <<fwprintf>> and <<swprintf>>.  They differ only in allowing
+their caller to pass the variable argument list as a <<va_list>> object
+(initialized by <<va_start>>) rather than directly accepting a variable
+number of arguments.  The caller is responsible for calling <<va_end>>.
+
+<<_vwprintf_r>>, <<_vfwprintf_r>> and <<_vswprintf_r>> are reentrant
+versions of the above.
+
+RETURNS
+The return values are consistent with the corresponding functions.
+
+PORTABILITY
+POSIX-1.2008 with extensions; C99 (compliant except for POSIX extensions).
+
+Supporting OS subroutines required: <<close>>, <<fstat>>, <<isatty>>,
+<<lseek>>, <<read>>, <<sbrk>>, <<write>>.
+
+SEEALSO
+<<wprintf>>, <<fwprintf>> and <<swprintf>>.
+*/
+
+/*
+ * Actual wprintf innards.
+ *
+ * This code is large and complicated...
+ */
+#include <newlib.h>
+
+#ifdef INTEGER_ONLY
+# define VFWPRINTF vfiwprintf
+# ifdef STRING_ONLY
+#   define _VFWPRINTF_R _svfiwprintf_r
+# else
+#   define _VFWPRINTF_R _vfiwprintf_r
+# endif
+#else
+# define VFWPRINTF vfwprintf
+# ifdef STRING_ONLY
+#   define _VFWPRINTF_R _svfwprintf_r
+# else
+#   define _VFWPRINTF_R _vfwprintf_r
+# endif
+# ifndef NO_FLOATING_POINT
+#  define FLOATING_POINT
+# endif
+#endif
+
+#define _NO_POS_ARGS
+#ifdef _WANT_IO_POS_ARGS
+# undef _NO_POS_ARGS
+#endif
+
+#include <_ansi.h>
+#include <reent.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <stdint.h>
+#include <wchar.h>
+#include <sys/lock.h>
+#include <stdarg.h>
+#include "local.h"
+#include "fvwrite.h"
+#include "vfieeefp.h"
+#ifdef __HAVE_LOCALE_INFO_EXTENDED__
+#include "../locale/lnumeric.h"
+#endif
+
+/* Currently a test is made to see if long double processing is warranted.
+   This could be changed in the future should the _ldtoa_r code be
+   preferred over _dtoa_r.  */
+#define _NO_LONGDBL
+#if defined _WANT_IO_LONG_DOUBLE && (LDBL_MANT_DIG > DBL_MANT_DIG)
+#undef _NO_LONGDBL
+#endif
+
+#define _NO_LONGLONG
+#if defined _WANT_IO_LONG_LONG \
+	&& (defined __GNUC__ || __STDC_VERSION__ >= 199901L)
+# undef _NO_LONGLONG
+#endif
+
+int _EXFUN(_VFWPRINTF_R, (struct _reent *, FILE *, _CONST wchar_t *, va_list));
+/* Defined in vfprintf.c. */
+#ifdef STRING_ONLY
+#define __SPRINT __ssprint_r
+#else
+#define __SPRINT __sprint_r
+#endif
+int _EXFUN(__SPRINT, (struct _reent *, FILE *, register struct __suio *));
+
+#ifndef STRING_ONLY
+/*
+ * Helper function for `fprintf to unbuffered unix file': creates a
+ * temporary buffer.  We only work on write-only files; this avoids
+ * worries about ungetc buffers and so forth.
+ */
+static int
+_DEFUN(__sbwprintf, (rptr, fp, fmt, ap),
+       struct _reent *rptr _AND
+       register FILE *fp   _AND
+       _CONST wchar_t *fmt  _AND
+       va_list ap)
+{
+	int ret;
+	FILE fake;
+	unsigned char buf[BUFSIZ];
+
+	/* copy the important variables */
+	fake._flags = fp->_flags & ~__SNBF;
+	fake._flags2 = fp->_flags2;
+	fake._file = fp->_file;
+	fake._cookie = fp->_cookie;
+	fake._write = fp->_write;
+
+	/* set up the buffer */
+	fake._bf._base = fake._p = buf;
+	fake._bf._size = fake._w = sizeof (buf);
+	fake._lbfsize = 0;	/* not actually used, but Just In Case */
+#ifndef __SINGLE_THREAD__
+	__lock_init_recursive (fake._lock);
+#endif
+
+	/* do the work, then copy any error status */
+	ret = _VFWPRINTF_R (rptr, &fake, fmt, ap);
+	if (ret >= 0 && _fflush_r (rptr, &fake))
+		ret = EOF;
+	if (fake._flags & __SERR)
+		fp->_flags |= __SERR;
+
+#ifndef __SINGLE_THREAD__
+	__lock_close_recursive (fake._lock);
+#endif
+	return (ret);
+}
+#endif /* !STRING_ONLY */
+
+
+#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
+# include <locale.h>
+#endif
+#ifdef FLOATING_POINT
+# include <math.h>
+
+/* For %La, an exponent of 15 bits occupies the exponent character, a
+   sign, and up to 5 digits.  */
+# define MAXEXPLEN		7
+# define DEFPREC		6
+
+# ifdef _NO_LONGDBL
+
+extern char *_dtoa_r _PARAMS((struct _reent *, double, int,
+			      int, int *, int *, char **));
+
+#  define _PRINTF_FLOAT_TYPE double
+#  define _DTOA_R _dtoa_r
+#  define FREXP frexp
+
+# else /* !_NO_LONGDBL */
+
+extern char *_ldtoa_r _PARAMS((struct _reent *, _LONG_DOUBLE, int,
+			      int, int *, int *, char **));
+
+extern int _EXFUN(_ldcheck,(_LONG_DOUBLE *));
+
+#  define _PRINTF_FLOAT_TYPE _LONG_DOUBLE
+#  define _DTOA_R _ldtoa_r
+/* FIXME - frexpl is not yet supported; and cvt infloops if (double)f
+   converts a finite value into infinity.  */
+/* #  define FREXP frexpl */
+#  define FREXP(f,e) ((_LONG_DOUBLE) frexp ((double)f, e))
+# endif /* !_NO_LONGDBL */
+
+static wchar_t *wcvt(struct _reent *, _PRINTF_FLOAT_TYPE, int, int, wchar_t *,
+		    int *, int, int *, wchar_t *, int);
+
+static int wexponent(wchar_t *, int, int);
+
+#endif /* FLOATING_POINT */
+
+/* BUF must be big enough for the maximum %#llo (assuming long long is
+   at most 64 bits, this would be 23 characters), the maximum
+   multibyte character %C, and the maximum default precision of %La
+   (assuming long double is at most 128 bits with 113 bits of
+   mantissa, this would be 29 characters).  %e, %f, and %g use
+   reentrant storage shared with mprec.  All other formats that use
+   buf get by with fewer characters.  Making BUF slightly bigger
+   reduces the need for malloc in %.*a and %ls/%S, when large precision or
+   long strings are processed.
+   The bigger size of 100 bytes is used on systems which allow number
+   strings using the locale's grouping character.  Since that's a multibyte
+   value, we should use a conservative value.
+   */
+#ifdef _WANT_IO_C99_FORMATS
+#define BUF             100
+#else
+#define	BUF		40
+#endif
+#if defined _MB_CAPABLE && MB_LEN_MAX > BUF
+# undef BUF
+# define BUF MB_LEN_MAX
+#endif
+
+#ifndef _NO_LONGLONG
+# define quad_t long long
+# define u_quad_t unsigned long long
+#else
+# define quad_t long
+# define u_quad_t unsigned long
+#endif
+
+typedef quad_t * quad_ptr_t;
+typedef _PTR     void_ptr_t;
+typedef char *   char_ptr_t;
+typedef wchar_t* wchar_ptr_t;
+typedef long *   long_ptr_t;
+typedef int  *   int_ptr_t;
+typedef short *  short_ptr_t;
+
+#ifndef _NO_POS_ARGS
+# ifdef NL_ARGMAX
+#  define MAX_POS_ARGS NL_ARGMAX
+# else
+#  define MAX_POS_ARGS 32
+# endif
+
+union arg_val
+{
+  int val_int;
+  u_int val_u_int;
+  long val_long;
+  u_long val_u_long;
+  float val_float;
+  double val_double;
+  _LONG_DOUBLE val__LONG_DOUBLE;
+  int_ptr_t val_int_ptr_t;
+  short_ptr_t val_short_ptr_t;
+  long_ptr_t val_long_ptr_t;
+  char_ptr_t val_char_ptr_t;
+  wchar_ptr_t val_wchar_ptr_t;
+  quad_ptr_t val_quad_ptr_t;
+  void_ptr_t val_void_ptr_t;
+  quad_t val_quad_t;
+  u_quad_t val_u_quad_t;
+  wint_t val_wint_t;
+};
+
+static union arg_val *
+_EXFUN(get_arg, (struct _reent *data, int n, wchar_t *fmt,
+                 va_list *ap, int *numargs, union arg_val *args,
+                 int *arg_type, wchar_t **last_fmt));
+#endif /* !_NO_POS_ARGS */
+
+/*
+ * Macros for converting digits to letters and vice versa
+ */
+#define	to_digit(c)	((c) - L'0')
+#define is_digit(c)	((unsigned)to_digit (c) <= 9)
+#define	to_char(n)	((n) + L'0')
+
+/*
+ * Flags used during conversion.
+ */
+#define	ALT		0x001		/* alternate form */
+#define	HEXPREFIX	0x002		/* add 0x or 0X prefix */
+#define	LADJUST		0x004		/* left adjustment */
+#define	LONGDBL		0x008		/* long double */
+#define	LONGINT		0x010		/* long integer */
+#ifndef _NO_LONGLONG
+# define QUADINT	0x020		/* quad integer */
+#else /* ifdef _NO_LONGLONG, make QUADINT equivalent to LONGINT, so
+	 that %lld behaves the same as %ld, not as %d, as expected if:
+	 sizeof (long long) = sizeof long > sizeof int  */
+# define QUADINT	LONGINT
+#endif
+#define	SHORTINT	0x040		/* short integer */
+#define	ZEROPAD		0x080		/* zero (as opposed to blank) pad */
+#define FPT		0x100		/* Floating point number */
+#ifdef _WANT_IO_C99_FORMATS
+# define CHARINT	0x200		/* char as integer */
+#else /* define as 0, to make SARG and UARG occupy fewer instructions  */
+# define CHARINT	0
+#endif
+#ifdef _WANT_IO_C99_FORMATS
+# define GROUPING	0x400		/* use grouping ("'" flag) */
+#endif
+
+#ifndef STRING_ONLY
+int
+_DEFUN(VFWPRINTF, (fp, fmt0, ap),
+       FILE * fp         _AND
+       _CONST wchar_t *fmt0 _AND
+       va_list ap)
+{
+  int result;
+  result = _VFWPRINTF_R (_REENT, fp, fmt0, ap);
+  return result;
+}
+#endif /* STRING_ONLY */
+
+int
+_DEFUN(_VFWPRINTF_R, (data, fp, fmt0, ap),
+       struct _reent *data _AND
+       FILE * fp           _AND
+       _CONST wchar_t *fmt0   _AND
+       va_list ap)
+{
+	register wchar_t *fmt;	/* format string */
+	register wint_t ch;	/* character from fmt */
+	register int n, m;	/* handy integers (short term usage) */
+	register wchar_t *cp;	/* handy char pointer (short term usage) */
+	register struct __siov *iovp;/* for PRINT macro */
+	register int flags;	/* flags as above */
+	wchar_t *fmt_anchor;    /* current format spec being processed */
+#ifndef _NO_POS_ARGS
+	int N;                  /* arg number */
+	int arg_index;          /* index into args processed directly */
+	int numargs;            /* number of varargs read */
+	wchar_t *saved_fmt;     /* saved fmt pointer */
+	union arg_val args[MAX_POS_ARGS];
+	int arg_type[MAX_POS_ARGS];
+	int is_pos_arg;         /* is current format positional? */
+	int old_is_pos_arg;     /* is current format positional? */
+#endif
+	int ret;		/* return value accumulator */
+	int width;		/* width from format (%8d), or 0 */
+	int prec;		/* precision from format (%.3d), or -1 */
+	wchar_t sign;		/* sign prefix (' ', '+', '-', or \0) */
+#ifdef _WANT_IO_C99_FORMATS
+				/* locale specific numeric grouping */
+	wchar_t thousands_sep;
+	const char *grouping;
+#endif
+#ifdef _MB_CAPABLE
+	mbstate_t state;        /* mbtowc calls from library must not change state */
+#endif
+#ifdef FLOATING_POINT
+	wchar_t decimal_point;
+	wchar_t softsign;		/* temporary negative sign for floats */
+	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
+# define _fpvalue (_double_.fp)
+	int expt;		/* integer value of exponent */
+	int expsize = 0;	/* character count for expstr */
+	wchar_t expstr[MAXEXPLEN];	/* buffer for exponent string */
+	int lead;		/* sig figs before decimal or group sep */
+#endif /* FLOATING_POINT */
+#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
+	int ndig = 0;		/* actual number of digits returned by cvt */
+#endif
+#ifdef _WANT_IO_C99_FORMATS
+	int nseps;		/* number of group separators with ' */
+	int nrepeats;		/* number of repeats of the last group */
+#endif
+	u_quad_t _uquad;	/* integer arguments %[diouxX] */
+	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
+	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
+	int realsz;		/* field size expanded by dprec */
+	int size = 0;		/* size of converted field or string */
+	wchar_t *xdigs = NULL;	/* digits for [xX] conversion */
+#define NIOV 8
+	struct __suio uio;	/* output information: summary */
+	struct __siov iov[NIOV];/* ... and individual io vectors */
+	wchar_t buf[BUF];	/* space for %c, %ls/%S, %[diouxX], %[aA] */
+	wchar_t ox[2];		/* space for 0x hex-prefix */
+	wchar_t *malloc_buf = NULL;/* handy pointer for malloced buffers */
+
+	/*
+	 * Choose PADSIZE to trade efficiency vs. size.  If larger printf
+	 * fields occur frequently, increase PADSIZE and make the initialisers
+	 * below longer.
+	 */
+#define	PADSIZE	16		/* pad chunk size */
+	static _CONST wchar_t blanks[PADSIZE] =
+	 {L' ',L' ',L' ',L' ',L' ',L' ',L' ',L' ',
+	  L' ',L' ',L' ',L' ',L' ',L' ',L' ',L' '};
+	static _CONST wchar_t zeroes[PADSIZE] =
+	 {L'0',L'0',L'0',L'0',L'0',L'0',L'0',L'0',
+	  L'0',L'0',L'0',L'0',L'0',L'0',L'0',L'0'};
+
+#ifdef FLOATING_POINT
+#ifdef _MB_CAPABLE
+#ifdef __HAVE_LOCALE_INFO_EXTENDED__
+	decimal_point = *__get_current_numeric_locale ()->wdecimal_point;
+#else
+	{
+	  size_t nconv;
+
+	  memset (&state, '\0', sizeof (state));
+	  nconv = _mbrtowc_r (data, &decimal_point,
+			      _localeconv_r (data)->decimal_point,
+			      MB_CUR_MAX, &state);
+	  if (nconv == (size_t) -1 || nconv == (size_t) -2)
+	    decimal_point = L'.';
+	}
+#endif
+#else
+	decimal_point = (wchar_t) *_localeconv_r (data)->decimal_point;
+#endif
+#endif
+	/*
+	 * BEWARE, these `goto error' on error, and PAD uses `n'.
+	 */
+#define	PRINT(ptr, len) { \
+	iovp->iov_base = (char *) (ptr); \
+	iovp->iov_len = (len) * sizeof (wchar_t); \
+	uio.uio_resid += (len) * sizeof (wchar_t); \
+	iovp++; \
+	if (++uio.uio_iovcnt >= NIOV) { \
+		if (__SPRINT(data, fp, &uio)) \
+			goto error; \
+		iovp = iov; \
+	} \
+}
+#define	PAD(howmany, with) { \
+	if ((n = (howmany)) > 0) { \
+		while (n > PADSIZE) { \
+			PRINT (with, PADSIZE); \
+			n -= PADSIZE; \
+		} \
+		PRINT (with, n); \
+	} \
+}
+#define PRINTANDPAD(p, ep, len, with) { \
+	int n = (ep) - (p); \
+	if (n > (len)) \
+		n = (len); \
+	if (n > 0) \
+		PRINT((p), n); \
+	PAD((len) - (n > 0 ? n : 0), (with)); \
+}
+#define	FLUSH() { \
+	if (uio.uio_resid && __SPRINT(data, fp, &uio)) \
+		goto error; \
+	uio.uio_iovcnt = 0; \
+	iovp = iov; \
+}
+
+	/* Macros to support positional arguments */
+#ifndef _NO_POS_ARGS
+# define GET_ARG(n, ap, type)						\
+	(is_pos_arg							\
+	 ? (n < numargs							\
+	    ? args[n].val_##type					\
+	    : get_arg (data, n, fmt_anchor, &ap, &numargs, args,	\
+		       arg_type, &saved_fmt)->val_##type)		\
+	 : (arg_index++ < numargs					\
+	    ? args[n].val_##type					\
+	    : (numargs < MAX_POS_ARGS					\
+	       ? args[numargs++].val_##type = va_arg (ap, type)		\
+	       : va_arg (ap, type))))
+#else
+# define GET_ARG(n, ap, type) (va_arg (ap, type))
+#endif
+
+	/*
+	 * To extend shorts properly, we need both signed and unsigned
+	 * argument extraction methods.
+	 */
+#ifndef _NO_LONGLONG
+#define	SARG() \
+	(flags&QUADINT ? GET_ARG (N, ap, quad_t) : \
+	    flags&LONGINT ? GET_ARG (N, ap, long) : \
+	    flags&SHORTINT ? (long)(short)GET_ARG (N, ap, int) : \
+	    flags&CHARINT ? (long)(signed char)GET_ARG (N, ap, int) : \
+	    (long)GET_ARG (N, ap, int))
+#define	UARG() \
+	(flags&QUADINT ? GET_ARG (N, ap, u_quad_t) : \
+	    flags&LONGINT ? GET_ARG (N, ap, u_long) : \
+	    flags&SHORTINT ? (u_long)(u_short)GET_ARG (N, ap, int) : \
+	    flags&CHARINT ? (u_long)(unsigned char)GET_ARG (N, ap, int) : \
+	    (u_long)GET_ARG (N, ap, u_int))
+#else
+#define	SARG() \
+	(flags&LONGINT ? GET_ARG (N, ap, long) : \
+	    flags&SHORTINT ? (long)(short)GET_ARG (N, ap, int) : \
+	    flags&CHARINT ? (long)(signed char)GET_ARG (N, ap, int) : \
+	    (long)GET_ARG (N, ap, int))
+#define	UARG() \
+	(flags&LONGINT ? GET_ARG (N, ap, u_long) : \
+	    flags&SHORTINT ? (u_long)(u_short)GET_ARG (N, ap, int) : \
+	    flags&CHARINT ? (u_long)(unsigned char)GET_ARG (N, ap, int) : \
+	    (u_long)GET_ARG (N, ap, u_int))
+#endif
+
+#ifndef STRING_ONLY
+	/* Initialize std streams if not dealing with sprintf family.  */
+	CHECK_INIT (fp);
+	_flockfile (fp);
+
+	ORIENT(fp, 1);
+
+	/* sorry, fwprintf(read_only_file, "") returns EOF, not 0 */
+	if (cantwrite (fp)) {
+		_funlockfile (fp);
+		return (EOF);
+	}
+
+	/* optimise fwprintf(stderr) (and other unbuffered Unix files) */
+	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
+	    fp->_file >= 0) {
+		_funlockfile (fp);
+		return (__sbwprintf (data, fp, fmt0, ap));
+	}
+#else /* STRING_ONLY */
+        /* Create initial buffer if we are called by asprintf family.  */
+        if (fp->_flags & __SMBF && !fp->_bf._base)
+        {
+		fp->_bf._base = fp->_p = _malloc_r (data, 64);
+		if (!fp->_p)
+		{
+			data->_errno = ENOMEM;
+			return EOF;
+		}
+		fp->_bf._size = 64;
+        }
+#endif /* STRING_ONLY */
+
+	fmt = (wchar_t *)fmt0;
+	uio.uio_iov = iovp = iov;
+	uio.uio_resid = 0;
+	uio.uio_iovcnt = 0;
+	ret = 0;
+#ifndef _NO_POS_ARGS
+	arg_index = 0;
+	saved_fmt = NULL;
+	arg_type[0] = -1;
+	numargs = 0;
+	is_pos_arg = 0;
+#endif
+
+	/*
+	 * Scan the format for conversions (`%' character).
+	 */
+	for (;;) {
+	        cp = fmt;
+                while (*fmt != L'\0' && *fmt != L'%')
+                    ++fmt;
+		if ((m = fmt - cp) != 0) {
+			PRINT (cp, m);
+			ret += m;
+		}
+                if (*fmt == L'\0')
+                    goto done;
+		fmt_anchor = fmt;
+		fmt++;		/* skip over '%' */
+
+		flags = 0;
+		dprec = 0;
+		width = 0;
+		prec = -1;
+		sign = L'\0';
+#ifdef FLOATING_POINT
+		lead = 0;
+#endif
+#ifdef _WANT_IO_C99_FORMATS
+		nseps = nrepeats = 0;
+#endif
+#ifndef _NO_POS_ARGS
+		N = arg_index;
+		is_pos_arg = 0;
+#endif
+
+rflag:		ch = *fmt++;
+reswitch:	switch (ch) {
+#ifdef _WANT_IO_C99_FORMATS
+		case L'\'':
+#ifdef _MB_CAPABLE
+#ifdef __HAVE_LOCALE_INFO_EXTENDED__
+		  thousands_sep = *__get_current_numeric_locale ()->wthousands_sep;
+#else
+		  {
+		    size_t nconv;
+
+		    memset (&state, '\0', sizeof (state));
+		    nconv = _mbrtowc_r (data, &thousands_sep,
+					_localeconv_r (data)->thousands_sep,
+					MB_CUR_MAX, &state);
+		    if (nconv == (size_t) -1 || nconv == (size_t) -2)
+		      thousands_sep = L'\0';
+		  }
+#endif
+#else
+		  thousands_sep = (wchar_t) *_localeconv_r(data)->thousands_sep;
+#endif
+		  grouping = _localeconv_r (data)->grouping;
+		  if (thousands_sep && grouping && *grouping)
+		    flags |= GROUPING;
+		  goto rflag;
+#endif
+		case L' ':
+			/*
+			 * ``If the space and + flags both appear, the space
+			 * flag will be ignored.''
+			 *	-- ANSI X3J11
+			 */
+			if (!sign)
+				sign = L' ';
+			goto rflag;
+		case L'#':
+			flags |= ALT;
+			goto rflag;
+		case L'*':
+#ifndef _NO_POS_ARGS
+			/* we must check for positional arg used for dynamic width */
+			n = N;
+			old_is_pos_arg = is_pos_arg;
+			is_pos_arg = 0;
+			if (is_digit (*fmt)) {
+				wchar_t *old_fmt = fmt;
+
+				n = 0;
+				ch = *fmt++;
+				do {
+					n = 10 * n + to_digit (ch);
+					ch = *fmt++;
+				} while (is_digit (ch));
+
+				if (ch == L'$') {
+					if (n <= MAX_POS_ARGS) {
+						n -= 1;
+						is_pos_arg = 1;
+					}
+					else
+						goto error;
+				}
+				else {
+					fmt = old_fmt;
+					goto rflag;
+				}
+			}
+#endif /* !_NO_POS_ARGS */
+
+			/*
+			 * ``A negative field width argument is taken as a
+			 * - flag followed by a positive field width.''
+			 *	-- ANSI X3J11
+			 * They don't exclude field widths read from args.
+			 */
+			width = GET_ARG (n, ap, int);
+#ifndef _NO_POS_ARGS
+			is_pos_arg = old_is_pos_arg;
+#endif
+			if (width >= 0)
+				goto rflag;
+			width = -width;
+			/* FALLTHROUGH */
+		case L'-':
+			flags |= LADJUST;
+			goto rflag;
+		case L'+':
+			sign = L'+';
+			goto rflag;
+		case L'.':
+			if ((ch = *fmt++) == L'*') {
+#ifndef _NO_POS_ARGS
+				/* we must check for positional arg used for dynamic width */
+				n = N;
+				old_is_pos_arg = is_pos_arg;
+				is_pos_arg = 0;
+				if (is_digit (*fmt)) {
+					wchar_t *old_fmt = fmt;
+
+					n = 0;
+					ch = *fmt++;
+					do {
+						n = 10 * n + to_digit (ch);
+						ch = *fmt++;
+					} while (is_digit (ch));
+
+					if (ch == L'$') {
+						if (n <= MAX_POS_ARGS) {
+							n -= 1;
+							is_pos_arg = 1;
+						}
+						else
+							goto error;
+					}
+					else {
+						fmt = old_fmt;
+						goto rflag;
+					}
+				}
+#endif /* !_NO_POS_ARGS */
+				prec = GET_ARG (n, ap, int);
+#ifndef _NO_POS_ARGS
+				is_pos_arg = old_is_pos_arg;
+#endif
+				if (prec < 0)
+					prec = -1;
+				goto rflag;
+			}
+			n = 0;
+			while (is_digit (ch)) {
+				n = 10 * n + to_digit (ch);
+				ch = *fmt++;
+			}
+			prec = n < 0 ? -1 : n;
+			goto reswitch;
+		case L'0':
+			/*
+			 * ``Note that 0 is taken as a flag, not as the
+			 * beginning of a field width.''
+			 *	-- ANSI X3J11
+			 */
+			flags |= ZEROPAD;
+			goto rflag;
+		case L'1': case L'2': case L'3': case L'4':
+		case L'5': case L'6': case L'7': case L'8': case L'9':
+			n = 0;
+			do {
+				n = 10 * n + to_digit (ch);
+				ch = *fmt++;
+			} while (is_digit (ch));
+#ifndef _NO_POS_ARGS
+			if (ch == L'$') {
+				if (n <= MAX_POS_ARGS) {
+					N = n - 1;
+					is_pos_arg = 1;
+					goto rflag;
+				}
+				else
+					goto error;
+			}
+#endif /* !_NO_POS_ARGS */
+			width = n;
+			goto reswitch;
+#ifdef FLOATING_POINT
+		case L'L':
+			flags |= LONGDBL;
+			goto rflag;
+#endif
+		case L'h':
+#ifdef _WANT_IO_C99_FORMATS
+			if (*fmt == L'h') {
+				fmt++;
+				flags |= CHARINT;
+			} else
+#endif
+				flags |= SHORTINT;
+			goto rflag;
+		case L'l':
+#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
+			if (*fmt == L'l') {
+				fmt++;
+				flags |= QUADINT;
+			} else
+#endif
+				flags |= LONGINT;
+			goto rflag;
+		case L'q': /* GNU extension */
+			flags |= QUADINT;
+			goto rflag;
+#ifdef _WANT_IO_C99_FORMATS
+		case L'j':
+		  if (sizeof (intmax_t) == sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    flags |= QUADINT;
+		  goto rflag;
+		case L'z':
+		  if (sizeof (size_t) < sizeof (int))
+		    /* POSIX states size_t is 16 or more bits, as is short.  */
+		    flags |= SHORTINT;
+		  else if (sizeof (size_t) == sizeof (int))
+		    /* no flag needed */;
+		  else if (sizeof (size_t) <= sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    /* POSIX states that at least one programming
+		       environment must support size_t no wider than
+		       long, but that means other environments can
+		       have size_t as wide as long long.  */
+		    flags |= QUADINT;
+		  goto rflag;
+		case L't':
+		  if (sizeof (ptrdiff_t) < sizeof (int))
+		    /* POSIX states ptrdiff_t is 16 or more bits, as
+		       is short.  */
+		    flags |= SHORTINT;
+		  else if (sizeof (ptrdiff_t) == sizeof (int))
+		    /* no flag needed */;
+		  else if (sizeof (ptrdiff_t) <= sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    /* POSIX states that at least one programming
+		       environment must support ptrdiff_t no wider than
+		       long, but that means other environments can
+		       have ptrdiff_t as wide as long long.  */
+		    flags |= QUADINT;
+		  goto rflag;
+		case L'C':	/* POSIX extension */
+#endif /* _WANT_IO_C99_FORMATS */
+		case L'c':
+			cp = buf;
+			if (ch == L'c' && !(flags & LONGINT)) {
+				wint_t wc = btowc ((int) GET_ARG (N, ap, int));
+				if (wc == WEOF) {
+				    fp->_flags |= __SERR;
+				    goto error;
+				}
+				cp[0] = (wchar_t) wc;
+			}
+			else
+			{
+				cp[0] = GET_ARG (N, ap, int);
+			}
+			cp[1] = L'\0';
+			size = 1;
+			sign = L'\0';
+			break;
+		case L'd':
+		case L'i':
+			_uquad = SARG ();
+#ifndef _NO_LONGLONG
+			if ((quad_t)_uquad < 0)
+#else
+			if ((long) _uquad < 0)
+#endif
+			{
+
+				_uquad = -_uquad;
+				sign = L'-';
+			}
+			base = DEC;
+			goto number;
+#ifdef FLOATING_POINT
+# ifdef _WANT_IO_C99_FORMATS
+		case L'a':
+		case L'A':
+		case L'F':
+# endif
+		case L'e':
+		case L'E':
+		case L'f':
+		case L'g':
+		case L'G':
+# ifdef _NO_LONGDBL
+			if (flags & LONGDBL) {
+				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
+			} else {
+				_fpvalue = GET_ARG (N, ap, double);
+			}
+
+			/* do this before tricky precision changes
+
+			   If the output is infinite or NaN, leading
+			   zeros are not permitted.  Otherwise, scanf
+			   could not read what printf wrote.
+			 */
+			if (isinf (_fpvalue)) {
+				if (_fpvalue < 0)
+					sign = '-';
+				if (ch <= L'G') /* 'A', 'E', 'F', or 'G' */
+					cp = L"INF";
+				else
+					cp = L"inf";
+				size = 3;
+				flags &= ~ZEROPAD;
+				break;
+			}
+			if (isnan (_fpvalue)) {
+				if (ch <= L'G') /* 'A', 'E', 'F', or 'G' */
+					cp = L"NAN";
+				else
+					cp = L"nan";
+				size = 3;
+				flags &= ~ZEROPAD;
+				break;
+			}
+
+# else /* !_NO_LONGDBL */
+
+			if (flags & LONGDBL) {
+				_fpvalue = GET_ARG (N, ap, _LONG_DOUBLE);
+			} else {
+				_fpvalue = (_LONG_DOUBLE)GET_ARG (N, ap, double);
+			}
+
+			/* do this before tricky precision changes */
+			expt = _ldcheck (&_fpvalue);
+			if (expt == 2) {
+				if (_fpvalue < 0)
+					sign = L'-';
+				if (ch <= L'G') /* 'A', 'E', 'F', or 'G' */
+					cp = L"INF";
+				else
+					cp = L"inf";
+				size = 3;
+				flags &= ~ZEROPAD;
+				break;
+			}
+			if (expt == 1) {
+				if (ch <= L'G') /* 'A', 'E', 'F', or 'G' */
+					cp = L"NAN";
+				else
+					cp = L"nan";
+				size = 3;
+				flags &= ~ZEROPAD;
+				break;
+			}
+# endif /* !_NO_LONGDBL */
+
+			cp = buf;
+# ifdef _WANT_IO_C99_FORMATS
+			if (ch == L'a' || ch == L'A') {
+				ox[0] = L'0';
+				ox[1] = ch == L'a' ? L'x' : L'X';
+				flags |= HEXPREFIX;
+				if (prec >= BUF)
+				  {
+				    if ((malloc_buf =
+					 (wchar_t *)_malloc_r (data, (prec + 1) * sizeof (wchar_t)))
+					== NULL)
+				      {
+					fp->_flags |= __SERR;
+					goto error;
+				      }
+				    cp = malloc_buf;
+				  }
+			} else
+# endif /* _WANT_IO_C99_FORMATS */
+			if (prec == -1) {
+				prec = DEFPREC;
+			} else if ((ch == L'g' || ch == L'G') && prec == 0) {
+				prec = 1;
+			}
+
+			flags |= FPT;
+
+			cp = wcvt (data, _fpvalue, prec, flags, &softsign,
+				   &expt, ch, &ndig, cp, BUF);
+
+			/* If buf is not large enough for the converted wchar_t
+			   sequence, call wcvt again with a malloced new buffer.
+			   This should happen fairly rarely.
+			 */
+			if (cp == buf && ndig > BUF && malloc_buf == NULL) {
+				if ((malloc_buf =
+				    (wchar_t *)_malloc_r (data, ndig * sizeof (wchar_t)))
+				    == NULL)
+				  {
+				    fp->_flags |= __SERR;
+				    goto error;
+				  }
+				cp = wcvt (data, _fpvalue, prec, flags, &softsign,
+					   &expt, ch, &ndig, malloc_buf, ndig);
+			}
+
+			if (ch == L'g' || ch == L'G') {
+				if (expt <= -4 || expt > prec)
+					ch -= 2; /* 'e' or 'E' */
+				else
+					ch = L'g';
+			}
+# ifdef _WANT_IO_C99_FORMATS
+			else if (ch == L'F')
+				ch = L'f';
+# endif
+			if (ch <= L'e') {	/* 'a', 'A', 'e', or 'E' fmt */
+				--expt;
+				expsize = wexponent (expstr, expt, ch);
+				size = expsize + ndig;
+				if (ndig > 1 || flags & ALT)
+					++size;
+# ifdef _WANT_IO_C99_FORMATS
+				flags &= ~GROUPING;
+# endif
+			} else {
+				if (ch == L'f') {		/* f fmt */
+					if (expt > 0) {
+						size = expt;
+						if (prec || flags & ALT)
+							size += prec + 1;
+					} else	/* "0.X" */
+						size = (prec || flags & ALT)
+							  ? prec + 2
+							  : 1;
+				} else if (expt >= ndig) { /* fixed g fmt */
+					size = expt;
+					if (flags & ALT)
+						++size;
+				} else
+					size = ndig + (expt > 0 ?
+						1 : 2 - expt);
+# ifdef _WANT_IO_C99_FORMATS
+				if ((flags & GROUPING) && expt > 0) {
+					/* space for thousands' grouping */
+					nseps = nrepeats = 0;
+					lead = expt;
+					while (*grouping != CHAR_MAX) {
+						if (lead <= *grouping)
+							break;
+						lead -= *grouping;
+						if (grouping[1]) {
+							nseps++;
+							grouping++;
+						} else
+							nrepeats++;
+					}
+					size += nseps + nrepeats;
+				} else
+# endif
+				lead = expt;
+			}
+			if (softsign)
+				sign = L'-';
+			break;
+#endif /* FLOATING_POINT */
+		case L'n':
+#ifndef _NO_LONGLONG
+			if (flags & QUADINT)
+				*GET_ARG (N, ap, quad_ptr_t) = ret;
+			else
+#endif
+			if (flags & LONGINT)
+				*GET_ARG (N, ap, long_ptr_t) = ret;
+			else if (flags & SHORTINT)
+				*GET_ARG (N, ap, short_ptr_t) = ret;
+#ifdef _WANT_IO_C99_FORMATS
+			else if (flags & CHARINT)
+				*GET_ARG (N, ap, char_ptr_t) = ret;
+#endif
+			else
+				*GET_ARG (N, ap, int_ptr_t) = ret;
+			continue;	/* no output */
+		case L'o':
+			_uquad = UARG ();
+			base = OCT;
+#ifdef _WANT_IO_C99_FORMATS
+			flags &= ~GROUPING;
+#endif
+			goto nosign;
+		case L'p':
+			/*
+			 * ``The argument shall be a pointer to void.  The
+			 * value of the pointer is converted to a sequence
+			 * of printable characters, in an implementation-
+			 * defined manner.''
+			 *	-- ANSI X3J11
+			 */
+			/* NOSTRICT */
+			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
+			base = HEX;
+			xdigs = L"0123456789abcdef";
+			flags |= HEXPREFIX;
+			ox[0] = L'0';
+			ox[1] = ch = L'x';
+			goto nosign;
+		case L's':
+#ifdef _WANT_IO_C99_FORMATS
+		case L'S':	/* POSIX extension */
+#endif
+			sign = '\0';
+			cp = GET_ARG (N, ap, wchar_ptr_t);
+#ifndef __OPTIMIZE_SIZE__
+			/* Behavior is undefined if the user passed a
+			   NULL string when precision is not 0.
+			   However, if we are not optimizing for size,
+			   we might as well mirror glibc behavior.  */
+			if (cp == NULL) {
+				cp = L"(null)";
+				size = ((unsigned) prec > 6U) ? 6 : prec;
+			}
+			else
+#endif /* __OPTIMIZE_SIZE__ */
+#ifdef _MB_CAPABLE
+			if (ch == L's' && !(flags & LONGINT)) {
+				char *arg = (char *) cp;
+				size_t insize = 0, nchars = 0, nconv = 0;
+				mbstate_t ps;
+				wchar_t *p;
+
+				if (prec >= 0) {
+					char *p = arg;
+					memset ((_PTR)&ps, '\0', sizeof (mbstate_t));
+					while (nchars < (size_t)prec) {
+						nconv = mbrlen (p, MB_CUR_MAX, &ps);
+						if (nconv == 0 || nconv == (size_t)-1 ||
+						    nconv == (size_t)-2)
+							break;
+						p += nconv;
+						++nchars;
+						insize += nconv;
+					}
+					if (nconv == (size_t) -1 || nconv == (size_t) -2) {
+						fp->_flags |= __SERR;
+						goto error;
+					}
+				} else
+					insize = strlen(arg);
+				if (insize >= BUF) {
+				    if ((malloc_buf = (wchar_t *) _malloc_r (data, (insize + 1) * sizeof (wchar_t)))
+								== NULL) {
+							fp->_flags |= __SERR;
+							goto error;
+						}
+						cp = malloc_buf;
+				} else
+					cp = buf;
+				memset ((_PTR)&ps, '\0', sizeof (mbstate_t));
+				p = cp;
+				while (insize != 0) {
+					nconv = _mbrtowc_r (data, p, arg, insize, &ps);
+					if (nconv == 0 || nconv == (size_t)-1 || nconv == (size_t)-2)
+						break;
+					++p;
+					arg += nconv;
+					insize -= nconv;
+				}
+				if (nconv == (size_t) -1 || nconv == (size_t) -2) {
+					fp->_flags |= __SERR;
+					goto error;
+				}
+				*p = L'\0';
+				size = p - cp;
+			}
+			else
+#endif /* _MB_CAPABLE */
+			if (prec >= 0) {
+				/*
+				 * can't use wcslen; can only look for the
+				 * NUL in the first `prec' characters, and
+				 * strlen () will go further.
+				 */
+				wchar_t *p = wmemchr (cp, L'\0', prec);
+
+				if (p != NULL) {
+					size = p - cp;
+					if (size > prec)
+						size = prec;
+				} else
+					size = prec;
+			} else
+				size = wcslen (cp);
+
+			break;
+		case L'u':
+			_uquad = UARG ();
+			base = DEC;
+			goto nosign;
+		case L'X':
+			xdigs = L"0123456789ABCDEF";
+			goto hex;
+		case 'x':
+			xdigs = L"0123456789abcdef";
+hex:			_uquad = UARG ();
+			base = HEX;
+			/* leading 0x/X only if non-zero */
+			if (flags & ALT && _uquad != 0) {
+				ox[0] = L'0';
+				ox[1] = ch;
+				flags |= HEXPREFIX;
+			}
+
+#ifdef _WANT_IO_C99_FORMATS
+			flags &= ~GROUPING;
+#endif
+			/* unsigned conversions */
+nosign:			sign = L'\0';
+			/*
+			 * ``... diouXx conversions ... if a precision is
+			 * specified, the 0 flag will be ignored.''
+			 *	-- ANSI X3J11
+			 */
+number:			if ((dprec = prec) >= 0)
+				flags &= ~ZEROPAD;
+
+			/*
+			 * ``The result of converting a zero value with an
+			 * explicit precision of zero is no characters.''
+			 *	-- ANSI X3J11
+			 */
+			cp = buf + BUF;
+			if (_uquad != 0 || prec != 0) {
+				/*
+				 * Unsigned mod is hard, and unsigned mod
+				 * by a constant is easier than that by
+				 * a variable; hence this switch.
+				 */
+				switch (base) {
+				case OCT:
+					do {
+						*--cp = to_char (_uquad & 7);
+						_uquad >>= 3;
+					} while (_uquad);
+					/* handle octal leading 0 */
+					if (flags & ALT && *cp != L'0')
+						*--cp = L'0';
+					break;
+
+				case DEC:
+					/* many numbers are 1 digit */
+					if (_uquad < 10) {
+						*--cp = to_char(_uquad);
+						break;
+					}
+#ifdef _WANT_IO_C99_FORMATS
+					ndig = 0;
+#endif
+					do {
+					  *--cp = to_char (_uquad % 10);
+#ifdef _WANT_IO_C99_FORMATS
+					  ndig++;
+					  /* If (*grouping == CHAR_MAX) then no
+					     more grouping */
+					  if ((flags & GROUPING)
+					      && ndig == *grouping
+					      && *grouping != CHAR_MAX
+					      && _uquad > 9) {
+					    *--cp = thousands_sep;
+					    ndig = 0;
+					    /* If (grouping[1] == '\0') then we
+					       have to use *grouping character
+					       (last grouping rule) for all
+					       next cases. */
+					    if (grouping[1] != '\0')
+					      grouping++;
+					  }
+#endif
+					  _uquad /= 10;
+					} while (_uquad != 0);
+					break;
+
+				case HEX:
+					do {
+						*--cp = xdigs[_uquad & 15];
+						_uquad >>= 4;
+					} while (_uquad);
+					break;
+
+				default:
+					cp = L"bug in vfprintf: bad base";
+					size = wcslen (cp);
+					goto skipsize;
+				}
+			}
+                       /*
+			* ...result is to be converted to an 'alternate form'.
+			* For o conversion, it increases the precision to force
+			* the first digit of the result to be a zero."
+			*     -- ANSI X3J11
+			*
+			* To demonstrate this case, compile and run:
+                        *    printf ("%#.0o",0);
+			*/
+                       else if (base == OCT && (flags & ALT))
+                         *--cp = L'0';
+
+			size = buf + BUF - cp;
+		skipsize:
+			break;
+		default:	/* "%?" prints ?, unless ? is NUL */
+			if (ch == L'\0')
+				goto done;
+			/* pretend it was %c with argument ch */
+			cp = buf;
+			*cp = ch;
+			size = 1;
+			sign = L'\0';
+			break;
+		}
+
+		/*
+		 * All reasonable formats wind up here.  At this point, `cp'
+		 * points to a string which (if not flags&LADJUST) should be
+		 * padded out to `width' places.  If flags&ZEROPAD, it should
+		 * first be prefixed by any sign or other prefix; otherwise,
+		 * it should be blank padded before the prefix is emitted.
+		 * After any left-hand padding and prefixing, emit zeroes
+		 * required by a decimal [diouxX] precision, then print the
+		 * string proper, then emit zeroes required by any leftover
+		 * floating precision; finally, if LADJUST, pad with blanks.
+		 * If flags&FPT, ch must be in [aAeEfg].
+		 *
+		 * Compute actual size, so we know how much to pad.
+		 * size excludes decimal prec; realsz includes it.
+		 */
+		realsz = dprec > size ? dprec : size;
+		if (sign)
+			realsz++;
+		if (flags & HEXPREFIX)
+			realsz+= 2;
+
+		/* right-adjusting blank padding */
+		if ((flags & (LADJUST|ZEROPAD)) == 0)
+			PAD (width - realsz, blanks);
+
+		/* prefix */
+		if (sign)
+			PRINT (&sign, 1);
+		if (flags & HEXPREFIX)
+			PRINT (ox, 2);
+
+		/* right-adjusting zero padding */
+		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
+			PAD (width - realsz, zeroes);
+
+		/* leading zeroes from decimal precision */
+		PAD (dprec - size, zeroes);
+
+		/* the string or number proper */
+#ifdef FLOATING_POINT
+		if ((flags & FPT) == 0) {
+			PRINT (cp, size);
+		} else {	/* glue together f_p fragments */
+			if (ch >= L'f') {	/* 'f' or 'g' */
+				if (_fpvalue == 0) {
+					/* kludge for __dtoa irregularity */
+					PRINT (L"0", 1);
+					if (expt < ndig || flags & ALT) {
+						PRINT (&decimal_point, 1);
+						PAD (ndig - 1, zeroes);
+					}
+				} else if (expt <= 0) {
+					PRINT (L"0", 1);
+					if (expt || ndig || flags & ALT) {
+						PRINT (&decimal_point, 1);
+						PAD (-expt, zeroes);
+						PRINT (cp, ndig);
+					}
+				} else {
+					wchar_t *convbuf = cp;
+					PRINTANDPAD(cp, convbuf + ndig,
+						    lead, zeroes);
+					cp += lead;
+#ifdef _WANT_IO_C99_FORMATS
+					if (flags & GROUPING) {
+					    while (nseps > 0 || nrepeats > 0) {
+						if (nrepeats > 0)
+						    nrepeats--;
+						else {
+						    grouping--;
+						    nseps--;
+						}
+						PRINT (&thousands_sep, 1);
+						PRINTANDPAD (cp, convbuf + ndig,
+							     *grouping, zeroes);
+						cp += *grouping;
+					    }
+					    if (cp > convbuf + ndig)
+						cp = convbuf + ndig;
+					}
+#endif
+					if (expt < ndig || flags & ALT)
+					    PRINT (&decimal_point, 1);
+					PRINTANDPAD (cp, convbuf + ndig,
+						     ndig - expt, zeroes);
+				}
+
+			} else {	/* 'a', 'A', 'e', or 'E' */
+				if (ndig > 1 || flags & ALT) {
+					PRINT (cp, 1);
+					cp++;
+					PRINT (&decimal_point, 1);
+					if (_fpvalue) {
+						PRINT (cp, ndig - 1);
+					} else	/* 0.[0..] */
+						/* __dtoa irregularity */
+						PAD (ndig - 1, zeroes);
+				} else	/* XeYYY */
+					PRINT (cp, 1);
+				PRINT (expstr, expsize);
+			}
+		}
+#else /* !FLOATING_POINT */
+		PRINT (cp, size);
+#endif
+		/* left-adjusting padding (always blank) */
+		if (flags & LADJUST)
+			PAD (width - realsz, blanks);
+
+		/* finally, adjust ret */
+		ret += width > realsz ? width : realsz;
+
+		FLUSH ();	/* copy out the I/O vectors */
+
+                if (malloc_buf != NULL) {
+			_free_r (data, malloc_buf);
+			malloc_buf = NULL;
+		}
+	}
+done:
+	FLUSH ();
+error:
+	if (malloc_buf != NULL)
+		_free_r (data, malloc_buf);
+#ifndef STRING_ONLY
+	_funlockfile (fp);
+#endif
+	return (__sferror (fp) ? EOF : ret);
+	/* NOTREACHED */
+}
+
+#ifdef FLOATING_POINT
+
+/* Using reentrant DATA, convert finite VALUE into a string of digits
+   with no decimal point, using NDIGITS precision and FLAGS as guides
+   to whether trailing zeros must be included.  Set *SIGN to nonzero
+   if VALUE was negative.  Set *DECPT to the exponent plus one.  Set
+   *LENGTH to the length of the returned string.  CH must be one of
+   [aAeEfFgG]; different from vfprintf.c:cvt(), the return string
+   lives in BUF regardless of CH.  LEN is the length of BUF, except
+   when CH is [aA], in which case LEN is not in use.  If BUF is not
+   large enough for the converted string, only the first LEN number
+   of characters will be returned in BUF, but *LENGTH will be set to
+   the full length of the string before the truncation.  */
+static wchar_t *
+wcvt(struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
+     wchar_t *sign, int *decpt, int ch, int *length, wchar_t *buf, int len)
+{
+	int mode, dsgn;
+# ifdef _NO_LONGDBL
+	union double_union tmp;
+
+	tmp.d = value;
+	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
+		value = -value;
+		*sign = L'-';
+	} else
+		*sign = L'\0';
+# else /* !_NO_LONGDBL */
+	union
+	{
+	  struct ldieee ieee;
+	  _LONG_DOUBLE val;
+	} ld;
+
+	ld.val = value;
+	if (ld.ieee.sign) { /* this will check for < 0 and -0.0 */
+		value = -value;
+		*sign = L'-';
+	} else
+		*sign = L'\0';
+# endif /* !_NO_LONGDBL */
+
+# ifdef _WANT_IO_C99_FORMATS
+	if (ch == L'a' || ch == L'A') {
+		wchar_t *digits, *bp, *rve;
+		/* This code assumes FLT_RADIX is a power of 2.  The initial
+		   division ensures the digit before the decimal will be less
+		   than FLT_RADIX (unless it is rounded later).	 There is no
+		   loss of precision in these calculations.  */
+		value = FREXP (value, decpt) / 8;
+		if (!value)
+			*decpt = 1;
+		digits = ch == L'a' ? L"0123456789abcdef" : L"0123456789ABCDEF";
+		bp = buf;
+		do {
+			value *= 16;
+			mode = (int) value;
+			value -= mode;
+			*bp++ = digits[mode];
+		} while (ndigits-- && value);
+		if (value > 0.5 || (value == 0.5 && mode & 1)) {
+			/* round to even */
+			rve = bp;
+			while (*--rve == digits[0xf]) {
+				*rve = L'0';
+			}
+			*rve = *rve == L'9' ? digits[0xa] : *rve + 1;
+		} else {
+			while (ndigits-- >= 0) {
+				*bp++ = L'0';
+			}
+		}
+		*length = bp - buf;
+		return buf;
+	}
+# endif /* _WANT_IO_C99_FORMATS */
+	if (ch == L'f' || ch == L'F') {
+		mode = 3;		/* ndigits after the decimal point */
+	} else {
+		/* To obtain ndigits after the decimal point for the 'e'
+		 * and 'E' formats, round to ndigits + 1 significant
+		 * figures.
+		 */
+		if (ch == L'e' || ch == L'E') {
+			ndigits++;
+		}
+		mode = 2;		/* ndigits significant digits */
+	}
+
+	{
+	  char *digits, *bp, *rve;
+#ifndef _MB_CAPABLE
+	  int i;
+#endif
+
+	  digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
+
+	  if ((ch != L'g' && ch != L'G') || flags & ALT) {	/* Print trailing zeros */
+		bp = digits + ndigits;
+		if (ch == L'f' || ch == L'F') {
+			if (*digits == L'0' && value)
+				*decpt = -ndigits + 1;
+			bp += *decpt;
+		}
+		if (value == 0)	/* kludge for __dtoa irregularity */
+			rve = bp;
+		while (rve < bp)
+			*rve++ = '0';
+	  }
+
+	  *length = rve - digits; /* full length of the string */
+#ifdef _MB_CAPABLE
+	  _mbsnrtowcs_r (data, buf, (const char **) &digits, *length,
+			 len, NULL);
+#else
+	  for (i = 0; i < *length && i < len; ++i)
+	    buf[i] = (wchar_t) digits[i];
+#endif
+	  return buf;
+	}
+}
+
+static int
+wexponent(wchar_t *p0, int exp, int fmtch)
+{
+	register wchar_t *p, *t;
+	wchar_t expbuf[MAXEXPLEN];
+# ifdef _WANT_IO_C99_FORMATS
+	int isa = fmtch == L'a' || fmtch == L'A';
+# else
+#  define isa 0
+# endif
+
+	p = p0;
+	*p++ = isa ? L'p' - L'a' + fmtch : fmtch;
+	if (exp < 0) {
+		exp = -exp;
+		*p++ = L'-';
+	}
+	else
+		*p++ = L'+';
+	t = expbuf + MAXEXPLEN;
+	if (exp > 9) {
+		do {
+			*--t = to_char (exp % 10);
+		} while ((exp /= 10) > 9);
+		*--t = to_char (exp);
+		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
+	}
+	else {
+		if (!isa)
+			*p++ = L'0';
+		*p++ = to_char (exp);
+	}
+	return (p - p0);
+}
+#endif /* FLOATING_POINT */
+
+
+#ifndef _NO_POS_ARGS
+
+/* Positional argument support.
+   Written by Jeff Johnston
+
+   Copyright (c) 2002 Red Hat Incorporated.
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+      Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+      Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+      The name of Red Hat Incorporated may not be used to endorse
+      or promote products derived from this software without specific
+      prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL RED HAT INCORPORATED BE LIABLE FOR ANY
+   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
+
+/* function to get positional parameter N where n = N - 1 */
+static union arg_val *
+_DEFUN(get_arg, (data, n, fmt, ap, numargs_p, args, arg_type, last_fmt),
+       struct _reent *data _AND
+       int n               _AND
+       wchar_t *fmt        _AND
+       va_list *ap         _AND
+       int *numargs_p      _AND
+       union arg_val *args _AND
+       int *arg_type       _AND
+       wchar_t **last_fmt)
+{
+  wchar_t ch;
+  int number, flags;
+  int spec_type;
+  int numargs = *numargs_p;
+  __CH_CLASS chtype;
+  __STATE state, next_state;
+  __ACTION action;
+  int pos, last_arg;
+  int max_pos_arg = n;
+  /* Only need types that can be reached via vararg promotions.  */
+  enum types { INT, LONG_INT, QUAD_INT, CHAR_PTR, DOUBLE, LONG_DOUBLE, WIDE_CHAR };
+
+  /* if this isn't the first call, pick up where we left off last time */
+  if (*last_fmt != NULL)
+    fmt = *last_fmt;
+
+  /* we need to process either to end of fmt string or until we have actually
+     read the desired parameter from the vararg list. */
+  while (*fmt && n >= numargs)
+    {
+      while (*fmt != L'\0' && *fmt != L'%')
+				fmt += 1;
+
+      if (*fmt == L'\0')
+				break;
+      state = START;
+      flags = 0;
+      pos = -1;
+      number = 0;
+      spec_type = INT;
+
+      /* Use state/action table to process format specifiers.  We ignore invalid
+         formats and we are only interested in information that tells us how to
+         read the vararg list. */
+      while (state != DONE)
+	{
+	  ch = *fmt++;
+	  chtype = ch < (wchar_t) 256 ? __chclass[ch] : OTHER;
+	  next_state = __state_table[state][chtype];
+	  action = __action_table[state][chtype];
+	  state = next_state;
+
+	  switch (action)
+	    {
+	    case GETMOD:  /* we have format modifier */
+	      switch (ch)
+		{
+		case L'h':
+		  /* No flag needed, since short and char promote to int.  */
+		  break;
+		case L'L':
+		  flags |= LONGDBL;
+		  break;
+		case L'q':
+		  flags |= QUADINT;
+		  break;
+# ifdef _WANT_IO_C99_FORMATS
+		case L'j':
+		  if (sizeof (intmax_t) == sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    flags |= QUADINT;
+		  break;
+		case L'z':
+		  if (sizeof (size_t) <= sizeof (int))
+		    /* no flag needed */;
+		  else if (sizeof (size_t) <= sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    /* POSIX states that at least one programming
+		       environment must support size_t no wider than
+		       long, but that means other environments can
+		       have size_t as wide as long long.  */
+		    flags |= QUADINT;
+		  break;
+		case L't':
+		  if (sizeof (ptrdiff_t) <= sizeof (int))
+		    /* no flag needed */;
+		  else if (sizeof (ptrdiff_t) <= sizeof (long))
+		    flags |= LONGINT;
+		  else
+		    /* POSIX states that at least one programming
+		       environment must support ptrdiff_t no wider than
+		       long, but that means other environments can
+		       have ptrdiff_t as wide as long long.  */
+		    flags |= QUADINT;
+		  break;
+# endif /* _WANT_IO_C99_FORMATS */
+		case L'l':
+		default:
+# if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
+		  if (*fmt == L'l')
+		    {
+		      flags |= QUADINT;
+		      ++fmt;
+		    }
+		  else
+# endif
+		    flags |= LONGINT;
+		  break;
+		}
+	      break;
+	    case GETARG: /* we have format specifier */
+	      {
+		numargs &= (MAX_POS_ARGS - 1);
+		/* process the specifier and translate it to a type to fetch from varargs */
+		switch (ch)
+		  {
+		  case L'd':
+		  case L'i':
+		  case L'o':
+		  case L'x':
+		  case L'X':
+		  case L'u':
+		    if (flags & LONGINT)
+		      spec_type = LONG_INT;
+# ifndef _NO_LONGLONG
+		    else if (flags & QUADINT)
+		      spec_type = QUAD_INT;
+# endif
+		    else
+		      spec_type = INT;
+		    break;
+# ifdef _WANT_IO_C99_FORMATS
+		  case L'a':
+		  case L'A':
+		  case L'F':
+# endif
+		  case L'f':
+		  case L'g':
+		  case L'G':
+		  case L'E':
+		  case L'e':
+# ifndef _NO_LONGDBL
+		    if (flags & LONGDBL)
+		      spec_type = LONG_DOUBLE;
+		    else
+# endif
+		      spec_type = DOUBLE;
+		    break;
+		  case L's':
+# ifdef _WANT_IO_C99_FORMATS
+		  case L'S':	/* POSIX extension */
+# endif
+		  case L'p':
+		  case L'n':
+		    spec_type = CHAR_PTR;
+		    break;
+		  case L'c':
+# ifdef _WANT_IO_C99_FORMATS
+		    if (flags & LONGINT)
+		      spec_type = WIDE_CHAR;
+		    else
+# endif
+		      spec_type = INT;
+		    break;
+# ifdef _WANT_IO_C99_FORMATS
+		  case L'C':	/* POSIX extension */
+		    spec_type = WIDE_CHAR;
+		    break;
+# endif
+		  }
+
+		/* if we have a positional parameter, just store the type, otherwise
+		   fetch the parameter from the vararg list */
+		if (pos != -1)
+		  arg_type[pos] = spec_type;
+		else
+		  {
+		    switch (spec_type)
+		      {
+		      case LONG_INT:
+			args[numargs++].val_long = va_arg (*ap, long);
+			break;
+		      case QUAD_INT:
+			args[numargs++].val_quad_t = va_arg (*ap, quad_t);
+			break;
+		      case WIDE_CHAR:
+			args[numargs++].val_wint_t = va_arg (*ap, wint_t);
+			break;
+		      case INT:
+			args[numargs++].val_int = va_arg (*ap, int);
+			break;
+		      case CHAR_PTR:
+			args[numargs++].val_wchar_ptr_t = va_arg (*ap, wchar_t *);
+			break;
+		      case DOUBLE:
+			args[numargs++].val_double = va_arg (*ap, double);
+			break;
+		      case LONG_DOUBLE:
+			args[numargs++].val__LONG_DOUBLE = va_arg (*ap, _LONG_DOUBLE);
+			break;
+		      }
+		  }
+	      }
+	      break;
+	    case GETPOS: /* we have positional specifier */
+	      if (arg_type[0] == -1)
+		memset (arg_type, 0, sizeof (int) * MAX_POS_ARGS);
+	      pos = number - 1;
+	      max_pos_arg = (max_pos_arg > pos ? max_pos_arg : pos);
+	      break;
+	    case PWPOS:  /* we have positional specifier for width or precision */
+	      if (arg_type[0] == -1)
+		memset (arg_type, 0, sizeof (int) * MAX_POS_ARGS);
+	      number -= 1;
+	      arg_type[number] = INT;
+	      max_pos_arg = (max_pos_arg > number ? max_pos_arg : number);
+	      break;
+	    case GETPWB: /* we require format pushback */
+	      --fmt;
+	      /* fallthrough */
+	    case GETPW:  /* we have a variable precision or width to acquire */
+	      args[numargs++].val_int = va_arg (*ap, int);
+	      break;
+	    case NUMBER: /* we have a number to process */
+	      number = (ch - '0');
+	      while ((ch = *fmt) != '\0' && is_digit (ch))
+		{
+		  number = number * 10 + (ch - '0');
+		  ++fmt;
+		}
+	      break;
+	    case SKIPNUM: /* we have a number to skip */
+	      while ((ch = *fmt) != '\0' && is_digit (ch))
+		++fmt;
+	      break;
+	    case NOOP:
+	    default:
+	      break; /* do nothing */
+	    }
+	}
+    }
+
+  /* process all arguments up to at least the one we are looking for and if we
+     have seen the end of the string, then process up to the max argument needed */
+  if (*fmt == '\0')
+    last_arg = max_pos_arg;
+  else
+    last_arg = n;
+
+  while (numargs <= last_arg)
+    {
+      switch (arg_type[numargs])
+	{
+	case LONG_INT:
+	  args[numargs++].val_long = va_arg (*ap, long);
+	  break;
+	case QUAD_INT:
+	  args[numargs++].val_quad_t = va_arg (*ap, quad_t);
+	  break;
+	case CHAR_PTR:
+	  args[numargs++].val_wchar_ptr_t = va_arg (*ap, wchar_t *);
+	  break;
+	case DOUBLE:
+	  args[numargs++].val_double = va_arg (*ap, double);
+	  break;
+	case LONG_DOUBLE:
+	  args[numargs++].val__LONG_DOUBLE = va_arg (*ap, _LONG_DOUBLE);
+	  break;
+	case WIDE_CHAR:
+	  args[numargs++].val_wint_t = va_arg (*ap, wint_t);
+	  break;
+	case INT:
+	default:
+	  args[numargs++].val_int = va_arg (*ap, int);
+	  break;
+	}
+    }
+
+  /* alter the global numargs value and keep a reference to the last bit of the fmt
+     string we processed here because the caller will continue processing where we started */
+  *numargs_p = numargs;
+  *last_fmt = fmt;
+  return &args[n];
+}
+#endif /* !_NO_POS_ARGS */
diff --git a/msys/rt/src/newlib/libc/stdlib/Makefile.in b/msys/rt/src/newlib/libc/stdlib/Makefile.in
index c04f990..a30cc49 100644
--- a/msys/rt/src/newlib/libc/stdlib/Makefile.in
+++ b/msys/rt/src/newlib/libc/stdlib/Makefile.in
@@ -167,7 +167,10 @@ lib_a_SOURCES = \
 	mbsrtowcs.c	\
 	wcrtomb.c	\
 	wcsnrtombs.c	\
-	wcsrtombs.c
+	wcsrtombs.c \
+	btowc.c		\
+	wcstoul.c	\
+	wcstoull.c
 
 
 lib_a_LIBADD = mallocr.o freer.o reallocr.o callocr.o cfreer.o malignr.o \
@@ -208,7 +211,9 @@ CHEWOUT_FILES = \
 	strtoul.def 	\
 	system.def	\
 	wcstombs.def	\
-	wctomb.def	
+	wctomb.def	\
+	wcstoul.def	\
+	wcstoull.def	
 
 
 SUFFIXES = .def
@@ -241,7 +246,7 @@ qsort.o rand.o rand48.o rand_r.o realloc.o seed48.o setenv.o setenv_r.o \
 srand48.o strdup.o strdup_r.o strtod.o strtol.o strtoul.o system.o \
 valloc.o wcstombs.o wcstombs_r.o wctob.o wctomb.o wctomb_r.o mbrlen.o \
 mbrtowc.o mbsinit.o mbsnrtowcs.o mbsrtowcs.o wcrtomb.o wcsnrtombs.o \
-wcsrtombs.o
+wcsrtombs.o btowc.o wcstoul.o wcstoull.o
 
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
diff --git a/msys/rt/src/newlib/libc/stdlib/btowc.c b/msys/rt/src/newlib/libc/stdlib/btowc.c
new file mode 100644
index 0000000..ec6c291
--- /dev/null
+++ b/msys/rt/src/newlib/libc/stdlib/btowc.c
@@ -0,0 +1,32 @@
+#include <wchar.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <reent.h>
+#include <string.h>
+#include "local.h"
+
+wint_t
+btowc (int c)
+{
+  mbstate_t mbs;
+  int retval = 0;
+  wchar_t pwc;
+  unsigned char b;
+
+  if (c == EOF)
+    return WEOF;
+
+  b = (unsigned char)c;
+
+  /* Put mbs in initial state. */
+  memset (&mbs, '\0', sizeof (mbs));
+
+  _REENT_CHECK_MISC(_REENT);
+
+  retval = __mbtowc (_REENT, &pwc, &b, 1, __locale_charset (), &mbs);
+
+  if (retval != 0 && retval != 1)
+    return WEOF;
+
+  return (wint_t)pwc;
+}
diff --git a/msys/rt/src/newlib/libc/string/Makefile.in b/msys/rt/src/newlib/libc/string/Makefile.in
index 79fd00c..36d1a64 100644
--- a/msys/rt/src/newlib/libc/string/Makefile.in
+++ b/msys/rt/src/newlib/libc/string/Makefile.in
@@ -142,7 +142,9 @@ lib_a_SOURCES = \
 	wmemcmp.c \
 	wmemcpy.c \
 	wmemmove.c \
-	wmemset.c
+	wmemset.c \
+	wcslcpy.c \
+	wcsxfrm.c
 
 CHEWOUT_FILES = \
 bcmp.def	memcpy.def	strcmp.def	strncat.def strstr.def \
@@ -178,7 +180,7 @@ strncat.o strncmp.o strncasecmp.o strncpy.o strpbrk.o strrchr.o \
 strspn.o strtok.o strtok_r.o strupr.o strxfrm.o strstr.o swab.o u_strerr.o \
 wcscasecmp.o wcschr.o wcscoll.o wcsdup.o wcsncasecmp.o wcsncmp.o wcsrchr.o \
 wcwidth.o wcscat.o wcscmp.o wcscpy.o wcslen.o wcsncat.o wcsncpy.o wcswidth.o \
-wmemchr.o wmemcmp.o wmemcpy.o wmemmove.o wmemset.o
+wmemchr.o wmemcmp.o wmemcpy.o wmemmove.o wmemset.o wcslcpy.o wcsxfrm.o
 
 
 CFLAGS = @CFLAGS@
diff --git a/msys/rt/src/newlib/libc/string/wcslcpy.c b/msys/rt/src/newlib/libc/string/wcslcpy.c
new file mode 100644
index 0000000..21c030b
--- /dev/null
+++ b/msys/rt/src/newlib/libc/string/wcslcpy.c
@@ -0,0 +1,102 @@
+/*
+FUNCTION
+	<<wcslcpy>>---copy a wide-character string to specified length
+
+ANSI_SYNOPSIS
+	#include <wchar.h>
+	size_t wcslcpy(wchar_t *<[dst]>, const wchar_t *<[src]>, size_t <[siz]>);
+
+TRAD_SYNOPSIS
+	#include <wchar.h>
+	size_t wcslcpy(<[dst]>, <[src]>, <[siz]>)
+	wchar_t *<[dst]>;
+	const wchar_t *<[src]>;
+	size_t <[siz]>;
+
+DESCRIPTION
+	<<wcslcpy>> copies wide characters from <[src]> to <[dst]>
+	such that up to <[siz]> - 1 characters are copied.  A
+	terminating null is appended to the result, unless <[siz]>
+	is zero.
+
+RETURNS
+	<<wcslcpy>> returns the number of wide characters in <[src]>,
+	not including the terminating null wide character.  If the
+	return value is greater than or equal to <[siz]>, then
+	not all wide characters were copied from <[src]> and truncation
+	occurred.
+
+PORTABILITY
+No supporting OS subroutines are required.
+*/
+
+/*	$NetBSD: wcslcpy.c,v 1.1 2000/12/23 23:14:36 itojun Exp $	*/
+/*	from OpenBSD: strlcpy.c,v 1.4 1999/05/01 18:56:41 millert Exp 	*/
+
+/*
+ * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <_ansi.h>
+#include <wchar.h>
+
+/*
+ * Copy src to string dst of size siz.  At most siz-1 characters
+ * will be copied.  Always NUL terminates (unless siz == 0).
+ * Returns wcslen(src); if retval >= siz, truncation occurred.
+ */
+size_t
+_DEFUN (wcslcpy, (dst, src, siz),
+	wchar_t * dst _AND
+	_CONST wchar_t * src _AND
+	size_t siz)
+{
+  wchar_t *d = dst;
+  _CONST wchar_t *s = src;
+  size_t n = siz;
+
+  /* Copy as many bytes as will fit */
+  if (n != 0 && --n != 0)
+    {
+      do
+	{
+	  if ((*d++ = *s++) == 0)
+	    break;
+	}
+      while (--n != 0);
+    }
+
+  /* Not enough room in dst, add NUL and traverse rest of src */
+  if (n == 0)
+    {
+      if (siz != 0)
+	*d = '\0';		/* NUL-terminate dst */
+      while (*s++)
+	;
+    }
+
+  return (s - src - 1);		/* count does not include NUL */
+}
diff --git a/msys/rt/src/newlib/libc/string/wcsxfrm.c b/msys/rt/src/newlib/libc/string/wcsxfrm.c
new file mode 100644
index 0000000..439bdd0
--- /dev/null
+++ b/msys/rt/src/newlib/libc/string/wcsxfrm.c
@@ -0,0 +1,52 @@
+/*
+FUNCTION
+	<<wcsxfrm>>---locale-specific wide-character string transformation
+	
+INDEX
+	wcsxfrm
+
+ANSI_SYNOPSIS
+	#include <wchar.h>
+	int wcsxfrm(wchar_t *<[stra]>, const wchar_t * <[strb]>, size_t <[n]>);
+
+TRAD_SYNOPSIS
+	#include <wchar.h>
+	size_t wcsxfrm(<[stra]>, <[strb]>, <[n]>)
+	wchar_t *<[stra]>;
+	wchar_t *<[strb]>;
+	size_t   <[n]>
+
+DESCRIPTION
+	<<wcsxfrm>> transforms the wide-character string pointed to by
+	<[strb]> to the wide-character string pointed to by <[stra]>,
+	Comparing two transformed wide strings with <<wcscmp>> should return
+	the same result as comparing the original strings with <<wcscoll>>.
+	No more than <[n]> wide characters are transformed, including the
+	trailing null character.
+
+	If <[n]> is 0, <[stra]> may be a NULL pointer.
+
+	The current implementation of <<wcsxfrm>> simply uses <<wcslcpy>>
+	and does not support any language-specific transformations.
+
+RETURNS
+	<<wcsxfrm>> returns the length of the transformed wide character
+	string.  if the return value is greater or equal to <[n]>, the
+	content of <[stra]> is undefined.
+
+PORTABILITY
+<<wcsxfrm>> is ISO/IEC 9899/AMD1:1995 (ISO C).
+*/
+
+#include <_ansi.h>
+#include <wchar.h>
+
+size_t
+_DEFUN (wcsxfrm, (a, b, n),
+	wchar_t *a _AND
+	_CONST wchar_t *b _AND
+	size_t n)
+
+{
+  return wcslcpy (a, b, n);
+}
diff --git a/msys/rt/src/newlib/libc/time/Makefile.in b/msys/rt/src/newlib/libc/time/Makefile.in
index 6c553b1..d3c6684 100644
--- a/msys/rt/src/newlib/libc/time/Makefile.in
+++ b/msys/rt/src/newlib/libc/time/Makefile.in
@@ -101,7 +101,10 @@ lib_a_SOURCES = \
 	lcltime_r.c	\
 	mktime.c	\
 	strftime.c  	\
-	time.c
+	time.c      \
+	tzlock.c    \
+	gettzinfo.c \
+	wcsftime.c
 
 
 CHEWOUT_FILES = \
@@ -113,7 +116,10 @@ CHEWOUT_FILES = \
 	lcltime.def	\
 	mktime.def	\
 	strftime.def	\
-	time.def
+	time.def    \
+	tzlock.def  \
+	gettzinfo.def   \
+	wcsftime.def
 
 
 SUFFIXES = .def
@@ -135,7 +141,7 @@ LIBS = @LIBS@
 lib_a_LIBADD = 
 lib_a_OBJECTS =  asctime.o asctime_r.o clock.o ctime.o ctime_r.o \
 difftime.o gmtime.o gmtime_r.o lcltime.o lcltime_r.o mktime.o \
-strftime.o time.o
+strftime.o time.o gettzinfo.o tzlock.o wcsftime.o
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
diff --git a/msys/rt/src/newlib/libc/time/gettzinfo.c b/msys/rt/src/newlib/libc/time/gettzinfo.c
new file mode 100644
index 0000000..54c9bc2
--- /dev/null
+++ b/msys/rt/src/newlib/libc/time/gettzinfo.c
@@ -0,0 +1,15 @@
+#include <sys/types.h>
+#include <local.h>
+
+/* Shared timezone information for libc/time functions.  */
+static __tzinfo_type tzinfo = {1, 0,
+    { {'J', 0, 0, 0, 0, (time_t)0, 0L },
+      {'J', 0, 0, 0, 0, (time_t)0, 0L } 
+    } 
+};
+
+__tzinfo_type *
+__gettzinfo (void)
+{
+  return &tzinfo;
+}
diff --git a/msys/rt/src/newlib/libc/time/local.h b/msys/rt/src/newlib/libc/time/local.h
new file mode 100644
index 0000000..9d9ef87
--- /dev/null
+++ b/msys/rt/src/newlib/libc/time/local.h
@@ -0,0 +1,36 @@
+/* local header used by libc/time routines */
+#include <_ansi.h>
+#include <time.h>
+
+#define SECSPERMIN	60L
+#define MINSPERHOUR	60L
+#define HOURSPERDAY	24L
+#define SECSPERHOUR	(SECSPERMIN * MINSPERHOUR)
+#define SECSPERDAY	(SECSPERHOUR * HOURSPERDAY)
+#define DAYSPERWEEK	7
+#define MONSPERYEAR	12
+
+#define YEAR_BASE	1900
+#define EPOCH_YEAR      1970
+#define EPOCH_WDAY      4
+#define EPOCH_YEARS_SINCE_LEAP 2
+#define EPOCH_YEARS_SINCE_CENTURY 70
+#define EPOCH_YEARS_SINCE_LEAP_CENTURY 370
+
+#define isleap(y) ((((y) % 4) == 0 && ((y) % 100) != 0) || ((y) % 400) == 0)
+
+struct tm * _EXFUN (_mktm_r, (_CONST time_t *, struct tm *, int __is_gmtime));
+int         _EXFUN (__tzcalc_limits, (int __year));
+
+/* locks for multi-threading */
+#ifdef __SINGLE_THREAD__
+#define TZ_LOCK
+#define TZ_UNLOCK
+#else
+#define TZ_LOCK __tz_lock()
+#define TZ_UNLOCK __tz_unlock()
+#endif
+
+void _EXFUN(__tz_lock,(_VOID));
+void _EXFUN(__tz_unlock,(_VOID));
+
diff --git a/msys/rt/src/newlib/libc/time/strftime.c b/msys/rt/src/newlib/libc/time/strftime.c
index 1e6154f..056e724 100644
--- a/msys/rt/src/newlib/libc/time/strftime.c
+++ b/msys/rt/src/newlib/libc/time/strftime.c
@@ -1,6 +1,11 @@
+/* NOTE:  This file defines both strftime() and wcsftime().  Take care when
+ * making changes.  See also wcsftime.c, and note the (small) overlap in the
+ * manual description, taking care to edit both as needed.  */
 /*
  * strftime.c
  * Original Author:	G. Haley
+ * Additions from:	Eric Blake
+ * Changes to allow dual use as wcstime, also:	Craig Howland
  *
  * Places characters into the array pointed to by s as controlled by the string
  * pointed to by format. If the total number of resulting characters including
@@ -12,7 +17,7 @@
 
 /*
 FUNCTION
-<<strftime>>---flexible calendar time formatter
+<<strftime>>---convert date and time to a formatted string
 
 INDEX
 	strftime
@@ -32,92 +37,199 @@ TRAD_SYNOPSIS
 
 DESCRIPTION
 <<strftime>> converts a <<struct tm>> representation of the time (at
-<[timp]>) into a string, starting at <[s]> and occupying no more than
-<[maxsize]> characters.
+<[timp]>) into a null-terminated string, starting at <[s]> and occupying
+no more than <[maxsize]> characters.
 
 You control the format of the output using the string at <[format]>.
 <<*<[format]>>> can contain two kinds of specifications: text to be
 copied literally into the formatted string, and time conversion
-specifications.  Time conversion specifications are two-character
-sequences beginning with `<<%>>' (use `<<%%>>' to include a percent
-sign in the output).  Each defined conversion specification selects a
-field of calendar time data from <<*<[timp]>>>, and converts it to a
-string in one of the following ways:
+specifications.  Time conversion specifications are two- and
+three-character sequences beginning with `<<%>>' (use `<<%%>>' to
+include a percent sign in the output).  Each defined conversion
+specification selects only the specified field(s) of calendar time
+data from <<*<[timp]>>>, and converts it to a string in one of the
+following ways:
 
 o+
 o %a
-An abbreviation for the day of the week.
+The abbreviated weekday name according to the current locale. [tm_wday]
 
 o %A
-The full name for the day of the week.
+The full weekday name according to the current locale.
+In the default "C" locale, one of `<<Sunday>>', `<<Monday>>', `<<Tuesday>>',
+`<<Wednesday>>', `<<Thursday>>', `<<Friday>>', `<<Saturday>>'. [tm_wday]
 
 o %b
-An abbreviation for the month name.
+The abbreviated month name according to the current locale. [tm_mon]
 
 o %B
-The full name of the month.
+The full month name according to the current locale.
+In the default "C" locale, one of `<<January>>', `<<February>>',
+`<<March>>', `<<April>>', `<<May>>', `<<June>>', `<<July>>',
+`<<August>>', `<<September>>', `<<October>>', `<<November>>',
+`<<December>>'. [tm_mon]
 
 o %c
-A string representing the complete date and time, in the form
-. Mon Apr 01 13:13:13 1992
+The preferred date and time representation for the current locale.
+[tm_sec, tm_min, tm_hour, tm_mday, tm_mon, tm_year, tm_wday]
 
+o %C
+The century, that is, the year divided by 100 then truncated.  For
+4-digit years, the result is zero-padded and exactly two characters;
+but for other years, there may a negative sign or more digits.  In
+this way, `<<%C%y>>' is equivalent to `<<%Y>>'. [tm_year]
+ 
 o %d
-The day of the month, formatted with two digits.
+The day of the month, formatted with two digits (from `<<01>>' to
+`<<31>>'). [tm_mday]
+
+o %D
+A string representing the date, in the form `<<"%m/%d/%y">>'.
+[tm_mday, tm_mon, tm_year]
+
+o %e
+The day of the month, formatted with leading space if single digit
+(from `<<1>>' to `<<31>>'). [tm_mday]
+
+o %E<<x>>
+In some locales, the E modifier selects alternative representations of
+certain modifiers <<x>>.  In newlib, it is ignored, and treated as %<<x>>.
+
+o %F
+A string representing the ISO 8601:2000 date format, in the form
+`<<"%Y-%m-%d">>'. [tm_mday, tm_mon, tm_year]
+
+o %g
+The last two digits of the week-based year, see specifier %G (from
+`<<00>>' to `<<99>>'). [tm_year, tm_wday, tm_yday]
+
+o %G
+The week-based year. In the ISO 8601:2000 calendar, week 1 of the year
+includes January 4th, and begin on Mondays. Therefore, if January 1st,
+2nd, or 3rd falls on a Sunday, that day and earlier belong to the last
+week of the previous year; and if December 29th, 30th, or 31st falls
+on Monday, that day and later belong to week 1 of the next year.  For
+consistency with %Y, it always has at least four characters. 
+Example: "%G" for Saturday 2nd January 1999 gives "1998", and for
+Tuesday 30th December 1997 gives "1998". [tm_year, tm_wday, tm_yday]
+
+o %h
+Synonym for "%b". [tm_mon]
 
 o %H
-The hour (on a 24-hour clock), formatted with two digits.
+The hour (on a 24-hour clock), formatted with two digits (from
+`<<00>>' to `<<23>>'). [tm_hour]
 
 o %I
-The hour (on a 12-hour clock), formatted with two digits.
+The hour (on a 12-hour clock), formatted with two digits (from
+`<<01>>' to `<<12>>'). [tm_hour]
 
 o %j
 The count of days in the year, formatted with three digits
-(from `<<001>>' to `<<366>>').
+(from `<<001>>' to `<<366>>'). [tm_yday]
+
+o %k
+The hour (on a 24-hour clock), formatted with leading space if single
+digit (from `<<0>>' to `<<23>>'). Non-POSIX extension (c.p. %I). [tm_hour]
+
+o %l
+The hour (on a 12-hour clock), formatted with leading space if single
+digit (from `<<1>>' to `<<12>>'). Non-POSIX extension (c.p. %H). [tm_hour]
 
 o %m
-The month number, formatted with two digits.
+The month number, formatted with two digits (from `<<01>>' to `<<12>>').
+[tm_mon]
 
 o %M
-The minute, formatted with two digits.
+The minute, formatted with two digits (from `<<00>>' to `<<59>>'). [tm_min]
+
+o %n
+A newline character (`<<\n>>').
+
+o %O<<x>>
+In some locales, the O modifier selects alternative digit characters
+for certain modifiers <<x>>.  In newlib, it is ignored, and treated as %<<x>>.
 
 o %p
-Either `<<AM>>' or `<<PM>>' as appropriate.
+Either `<<AM>>' or `<<PM>>' as appropriate, or the corresponding strings for
+the current locale. [tm_hour]
+
+o %P
+Same as '<<%p>>', but in lowercase.  This is a GNU extension. [tm_hour]
+
+o %r
+Replaced by the time in a.m. and p.m. notation.  In the "C" locale this
+is equivalent to "%I:%M:%S %p".  In locales which don't define a.m./p.m.
+notations, the result is an empty string. [tm_sec, tm_min, tm_hour]
+
+o %R
+The 24-hour time, to the minute.  Equivalent to "%H:%M". [tm_min, tm_hour]
 
 o %S
-The second, formatted with two digits.
+The second, formatted with two digits (from `<<00>>' to `<<60>>').  The
+value 60 accounts for the occasional leap second. [tm_sec]
+
+o %t
+A tab character (`<<\t>>').
+
+o %T
+The 24-hour time, to the second.  Equivalent to "%H:%M:%S". [tm_sec,
+tm_min, tm_hour]
+
+o %u
+The weekday as a number, 1-based from Monday (from `<<1>>' to
+`<<7>>'). [tm_wday]
 
 o %U
-The week number, formatted with two digits (from `<<00>>' to `<<53>>';
-week number 1 is taken as beginning with the first Sunday in a year).
-See also <<%W>>.
+The week number, where weeks start on Sunday, week 1 contains the first
+Sunday in a year, and earlier days are in week 0.  Formatted with two
+digits (from `<<00>>' to `<<53>>').  See also <<%W>>. [tm_wday, tm_yday]
+
+o %V
+The week number, where weeks start on Monday, week 1 contains January 4th,
+and earlier days are in the previous year.  Formatted with two digits
+(from `<<01>>' to `<<53>>').  See also <<%G>>. [tm_year, tm_wday, tm_yday]
 
 o %w
-A single digit representing the day of the week: Sunday is day <<0>>.
+The weekday as a number, 0-based from Sunday (from `<<0>>' to `<<6>>').
+[tm_wday]
 
 o %W
-Another version of the week number: like `<<%U>>', but counting week 1
-as beginning with the first Monday in a year.
+The week number, where weeks start on Monday, week 1 contains the first
+Monday in a year, and earlier days are in week 0.  Formatted with two
+digits (from `<<00>>' to `<<53>>'). [tm_wday, tm_yday]
 
-o
 o %x
-A string representing the complete date, in a format like
-. Mon Apr 01 1992
+Replaced by the preferred date representation in the current locale.
+In the "C" locale this is equivalent to "%m/%d/%y".
+[tm_mon, tm_mday, tm_year]
 
 o %X
-A string representing the full time of day (hours, minutes, and
-seconds), in a format like
-. 13:13:13
+Replaced by the preferred time representation in the current locale.
+In the "C" locale this is equivalent to "%H:%M:%S". [tm_sec, tm_min, tm_hour]
 
 o %y
-The last two digits of the year.
+The last two digits of the year (from `<<00>>' to `<<99>>'). [tm_year]
+(Implementation interpretation:  always positive, even for negative years.)
 
 o %Y
-The full year, formatted with four digits to include the century.
+The full year, equivalent to <<%C%y>>.  It will always have at least four
+characters, but may have more.  The year is accurate even when tm_year
+added to the offset of 1900 overflows an int. [tm_year]
+
+o %z
+The offset from UTC.  The format consists of a sign (negative is west of
+Greewich), two characters for hour, then two characters for minutes
+(-hhmm or +hhmm).  If tm_isdst is negative, the offset is unknown and no
+output is generated; if it is zero, the offset is the standard offset for
+the current time zone; and if it is positive, the offset is the daylight
+savings offset for the current timezone. The offset is determined from
+the TZ environment variable, as if by calling tzset(). [tm_isdst]
 
 o %Z
-Defined by ANSI C as eliciting the time zone if available; it is not
-available in this implementation (which accepts `<<%Z>>' but generates
-no output for it).
+The time zone name.  If tm_isdst is negative, no output is generated.
+Otherwise, the time zone name is based on the TZ environment variable,
+as if by calling tzset(). [tm_isdst]
 
 o %%
 A single character, `<<%>>'.
@@ -134,311 +246,1544 @@ parts of <<*<[format]>>> that could be completely filled in within the
 PORTABILITY
 ANSI C requires <<strftime>>, but does not specify the contents of
 <<*<[s]>>> when the formatted string would require more than
-<[maxsize]> characters.
+<[maxsize]> characters.  Unrecognized specifiers and fields of
+<<timp>> that are out of range cause undefined results.  Since some
+formats expand to 0 bytes, it is wise to set <<*<[s]>>> to a nonzero
+value beforehand to distinguish between failure and an empty string.
+This implementation does not support <<s>> being NULL, nor overlapping
+<<s>> and <<format>>.
 
 <<strftime>> requires no supporting OS subroutines.
+
+BUGS
+<<strftime>> ignores the LC_TIME category of the current locale, hard-coding
+the "C" locale settings.
 */
 
+#include <newlib.h>
+#include <sys/config.h>
 #include <stddef.h>
 #include <stdio.h>
 #include <time.h>
+#include <string.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <ctype.h>
+#include <wctype.h>
+#include "local.h"
+#include "../locale/timelocal.h"
+ 
+/* Defines to make the file dual use for either strftime() or wcsftime().
+ * To get wcsftime, define MAKE_WCSFTIME.
+ * To get strftime, do not define MAKE_WCSFTIME.
+ * Names are kept friendly to strftime() usage.  The biggest ugliness is the
+ * use of the CQ() macro to make either regular character constants and
+ * string literals or wide-character constants and wide-character-string
+ * literals, as appropriate.  */
+#if !defined(MAKE_WCSFTIME)
+#  define CHAR		char		/* string type basis */
+#  define CQ(a)		a		/* character constant qualifier */
+#  define SFLG				/* %s flag (null for normal char) */
+#  define _ctloc(x) (ctloclen = strlen (ctloc = _CurrentTimeLocale->x), ctloc)
+#  define snprintf	sniprintf	/* avoid to pull in FP functions. */
+#  define TOLOWER(c)	tolower((int)(unsigned char)(c))
+#  define STRTOUL(c,p,b) strtoul((c),(p),(b))
+#  define STRCPY(a,b)	strcpy((a),(b))
+#  define STRCHR(a,b)	strchr((a),(b))
+#  define STRLEN(a)	strlen(a)
+# else
+#  define strftime	wcsftime	/* Alternate function name */
+#  define CHAR		wchar_t		/* string type basis */
+#  define CQ(a)		L##a		/* character constant qualifier */
+#  define snprintf	swprintf	/* wide-char equivalent function name */
+#  define strncmp	wcsncmp		/* wide-char equivalent function name */
+#  define TOLOWER(c)	towlower((wint_t)(c))
+#  define STRTOUL(c,p,b) wcstoul((c),(p),(b))
+#  define STRCPY(a,b)	wcscpy((a),(b))
+#  define STRCHR(a,b)	wcschr((a),(b))
+#  define STRLEN(a)	wcslen(a)
+#  define SFLG		"l"		/* %s flag (l for wide char) */
+#  ifdef __HAVE_LOCALE_INFO_EXTENDED__
+#   define _ctloc(x) (ctloclen = wcslen (ctloc = _CurrentTimeLocale->w##x), \
+		      ctloc)
+#  else
+#   define CTLOCBUFLEN   256		/* Arbitrary big buffer size */
+    const wchar_t *
+    __ctloc (wchar_t *buf, const char *elem, size_t *len_ret)
+    {
+      buf[CTLOCBUFLEN - 1] = L'\0';
+      *len_ret = mbstowcs (buf, elem, CTLOCBUFLEN - 1);
+      if (*len_ret == (size_t) -1 )
+	*len_ret = 0;
+      return buf;
+    }
+#   define _ctloc(x) (ctloc = __ctloc (ctlocbuf, _CurrentTimeLocale->x, \
+		      &ctloclen))
+#  endif
+#endif  /* MAKE_WCSFTIME */
+
+#define CHECK_LENGTH()	if (len < 0 || (count += len) >= maxsize) \
+			  return 0
+
+/* Enforce the coding assumptions that YEAR_BASE is positive.  (%C, %Y, etc.) */
+#if YEAR_BASE < 0
+#  error "YEAR_BASE < 0"
+#endif
 
 static _CONST int dname_len[7] =
 {6, 6, 7, 9, 8, 6, 8};
 
-static _CONST char *_CONST dname[7] =
-{"Sunday", "Monday", "Tuesday", "Wednesday",
- "Thursday", "Friday", "Saturday"};
+/* Using the tm_year, tm_wday, and tm_yday components of TIM_P, return
+   -1, 0, or 1 as the adjustment to add to the year for the ISO week
+   numbering used in "%g%G%V", avoiding overflow.  */
+static int
+_DEFUN (iso_year_adjust, (tim_p),
+	_CONST struct tm *tim_p)
+{
+  /* Account for fact that tm_year==0 is year 1900.  */
+  int leap = isleap (tim_p->tm_year + (YEAR_BASE
+				       - (tim_p->tm_year < 0 ? 0 : 2000)));
+
+  /* Pack the yday, wday, and leap year into a single int since there are so
+     many disparate cases.  */
+#define PACK(yd, wd, lp) (((yd) << 4) + (wd << 1) + (lp))
+  switch (PACK (tim_p->tm_yday, tim_p->tm_wday, leap))
+    {
+    case PACK (0, 5, 0): /* Jan 1 is Fri, not leap.  */
+    case PACK (0, 6, 0): /* Jan 1 is Sat, not leap.  */
+    case PACK (0, 0, 0): /* Jan 1 is Sun, not leap.  */
+    case PACK (0, 5, 1): /* Jan 1 is Fri, leap year.  */
+    case PACK (0, 6, 1): /* Jan 1 is Sat, leap year.  */
+    case PACK (0, 0, 1): /* Jan 1 is Sun, leap year.  */
+    case PACK (1, 6, 0): /* Jan 2 is Sat, not leap.  */
+    case PACK (1, 0, 0): /* Jan 2 is Sun, not leap.  */
+    case PACK (1, 6, 1): /* Jan 2 is Sat, leap year.  */
+    case PACK (1, 0, 1): /* Jan 2 is Sun, leap year.  */
+    case PACK (2, 0, 0): /* Jan 3 is Sun, not leap.  */
+    case PACK (2, 0, 1): /* Jan 3 is Sun, leap year.  */
+      return -1; /* Belongs to last week of previous year.  */
+    case PACK (362, 1, 0): /* Dec 29 is Mon, not leap.  */
+    case PACK (363, 1, 1): /* Dec 29 is Mon, leap year.  */
+    case PACK (363, 1, 0): /* Dec 30 is Mon, not leap.  */
+    case PACK (363, 2, 0): /* Dec 30 is Tue, not leap.  */
+    case PACK (364, 1, 1): /* Dec 30 is Mon, leap year.  */
+    case PACK (364, 2, 1): /* Dec 30 is Tue, leap year.  */
+    case PACK (364, 1, 0): /* Dec 31 is Mon, not leap.  */
+    case PACK (364, 2, 0): /* Dec 31 is Tue, not leap.  */
+    case PACK (364, 3, 0): /* Dec 31 is Wed, not leap.  */
+    case PACK (365, 1, 1): /* Dec 31 is Mon, leap year.  */
+    case PACK (365, 2, 1): /* Dec 31 is Tue, leap year.  */
+    case PACK (365, 3, 1): /* Dec 31 is Wed, leap year.  */
+      return 1; /* Belongs to first week of next year.  */
+    }
+  return 0; /* Belongs to specified year.  */
+#undef PACK
+}
+
+#ifdef _WANT_C99_TIME_FORMATS
+typedef struct {
+  int   year;
+  CHAR *era_C;
+  CHAR *era_Y;
+} era_info_t;
+
+static era_info_t *
+#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
+get_era_info (const struct tm *tim_p, const wchar_t *era)
+#else
+get_era_info (const struct tm *tim_p, const char *era)
+#endif
+{
+#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
+  wchar_t *c;
+  const wchar_t *dir;
+# define ERA_STRCHR(a,b)	wcschr((a),(b))
+# define ERA_STRNCPY(a,b,c)	wcsncpy((a),(b),(c))
+# define ERA_STRTOL(a,b,c)	wcstol((a),(b),(c))
+#else
+  char *c;
+  const char *dir;
+# define ERA_STRCHR(a,b)	strchr((a),(b))
+# define ERA_STRNCPY(a,b,c)	strncpy((a),(b),(c))
+# define ERA_STRTOL(a,b,c)	strtol((a),(b),(c))
+#endif
+  long offset;
+  struct tm stm, etm;
+  era_info_t *ei;
+
+  ei = (era_info_t *) calloc (1, sizeof (era_info_t));
+  if (!ei)
+    return NULL;
+
+  stm.tm_isdst = etm.tm_isdst = 0;
+  while (era)
+    {
+      dir = era;
+      era += 2;
+      offset = ERA_STRTOL (era, &c, 10);
+      era = c + 1;
+      stm.tm_year = ERA_STRTOL (era, &c, 10) - YEAR_BASE;
+      /* Adjust offset for negative gregorian dates. */
+      if (stm.tm_year <= -YEAR_BASE)
+      	++stm.tm_year;
+      stm.tm_mon = ERA_STRTOL (c + 1, &c, 10) - 1;
+      stm.tm_mday = ERA_STRTOL (c + 1, &c, 10);
+      stm.tm_hour = stm.tm_min = stm.tm_sec = 0;
+      era = c + 1;
+      if (era[0] == '-' && era[1] == '*')
+      	{
+	  etm = stm;
+	  stm.tm_year = INT_MIN;
+	  stm.tm_mon = stm.tm_mday = stm.tm_hour = stm.tm_min = stm.tm_sec = 0;
+	  era += 3;
+	}
+      else if (era[0] == '+' && era[1] == '*')
+	{
+	  etm.tm_year = INT_MAX;
+	  etm.tm_mon = 11;
+	  etm.tm_mday = 31;
+	  etm.tm_hour = 23;
+	  etm.tm_min = etm.tm_sec = 59;
+	  era += 3;
+	}
+      else
+      	{
+	  etm.tm_year = ERA_STRTOL (era, &c, 10) - YEAR_BASE;
+	  /* Adjust offset for negative gregorian dates. */
+	  if (etm.tm_year <= -YEAR_BASE)
+	    ++etm.tm_year;
+	  etm.tm_mon = ERA_STRTOL (c + 1, &c, 10) - 1;
+	  etm.tm_mday = ERA_STRTOL (c + 1, &c, 10);
+	  etm.tm_mday = 31;
+	  etm.tm_hour = 23;
+	  etm.tm_min = etm.tm_sec = 59;
+	  era = c + 1;
+	}
+      if ((tim_p->tm_year > stm.tm_year
+	   || (tim_p->tm_year == stm.tm_year
+	       && (tim_p->tm_mon > stm.tm_mon
+		   || (tim_p->tm_mon == stm.tm_mon
+		       && tim_p->tm_mday >= stm.tm_mday))))
+	  && (tim_p->tm_year < etm.tm_year
+	      || (tim_p->tm_year == etm.tm_year
+		  && (tim_p->tm_mon < etm.tm_mon
+		      || (tim_p->tm_mon == etm.tm_mon
+			  && tim_p->tm_mday <= etm.tm_mday)))))
+	{
+	  /* Gotcha */
+	  size_t len;
+
+	  /* year */
+	  if (*dir == '+' && stm.tm_year != INT_MIN)
+	    ei->year = tim_p->tm_year - stm.tm_year + offset;
+	  else
+	    ei->year = etm.tm_year - tim_p->tm_year + offset;
+	  /* era_C */
+	  c = ERA_STRCHR (era, ':');
+#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
+	  len = mbsnrtowcs (NULL, &era, c - era, 0, NULL);
+	  if (len == (size_t) -1)
+	    {
+	      free (ei);
+	      return NULL;
+	    }
+#else
+	  len = c - era;
+#endif
+	  ei->era_C = (CHAR *) malloc ((len + 1) * sizeof (CHAR));
+	  if (!ei->era_C)
+	    {
+	      free (ei);
+	      return NULL;
+	    }
+#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
+	  len = mbsnrtowcs (ei->era_C, &era, c - era, len + 1, NULL);
+#else
+	  ERA_STRNCPY (ei->era_C, era, len);
+	  era += len;
+#endif
+	  ei->era_C[len] = CQ('\0');
+	  /* era_Y */
+	  ++era;
+	  c = ERA_STRCHR (era, ';');
+	  if (!c)
+	    c = ERA_STRCHR (era, '\0');
+#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
+	  len = mbsnrtowcs (NULL, &era, c - era, 0, NULL);
+	  if (len == (size_t) -1)
+	    {
+	      free (ei->era_C);
+	      free (ei);
+	      return NULL;
+	    }
+#else
+	  len = c - era;
+#endif
+	  ei->era_Y = (CHAR *) malloc ((len + 1) * sizeof (CHAR));
+	  if (!ei->era_Y)
+	    {
+	      free (ei->era_C);
+	      free (ei);
+	      return NULL;
+	    }
+#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
+	  len = mbsnrtowcs (ei->era_Y, &era, c - era, len + 1, NULL);
+#else
+	  ERA_STRNCPY (ei->era_Y, era, len);
+	  era += len;
+#endif
+	  ei->era_Y[len] = CQ('\0');
+	  return ei;
+	}
+      else
+	era = ERA_STRCHR (era, ';');
+      if (era)
+	++era;
+    }
+  return NULL;
+}
+
+static void
+free_era_info (era_info_t *ei)
+{
+  free (ei->era_C);
+  free (ei->era_Y);
+  free (ei);
+}
+
+typedef struct {
+  size_t num;
+  CHAR **digit;
+  CHAR *buffer;
+} alt_digits_t;
+
+static alt_digits_t *
+#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
+get_alt_digits (const wchar_t *alt_digits)
+#else
+get_alt_digits (const char *alt_digits)
+#endif
+{
+  alt_digits_t *adi;
+#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
+  const wchar_t *a, *e;
+# define ALT_STRCHR(a,b)	wcschr((a),(b))
+# define ALT_STRCPY(a,b)	wcscpy((a),(b))
+# define ALT_STRLEN(a)		wcslen(a)
+#else
+  const char *a, *e;
+# define ALT_STRCHR(a,b)	strchr((a),(b))
+# define ALT_STRCPY(a,b)	strcpy((a),(b))
+# define ALT_STRLEN(a)		strlen(a)
+#endif
+  CHAR *aa, *ae;
+  size_t len;
 
-static _CONST int mname_len[12] =
-{7, 8, 5, 5, 3, 4, 4, 6, 9, 7, 8, 8};
+  adi = (alt_digits_t *) calloc (1, sizeof (alt_digits_t));
+  if (!adi)
+    return NULL;
 
-static _CONST char *_CONST mname[12] =
-{"January", "February", "March", "April",
- "May", "June", "July", "August", "September", "October", "November",
- "December"};
+  /* Compute number of alt_digits. */
+  adi->num = 1;
+  for (a = alt_digits; (e = ALT_STRCHR (a, ';')) != NULL; a = e + 1)
+      ++adi->num;
+  /* Allocate the `digit' array, which is an array of `num' pointers into
+     `buffer'. */
+  adi->digit = (CHAR **) calloc (adi->num, sizeof (CHAR **));
+  if (!adi->digit)
+    {
+      free (adi);
+      return NULL;
+    }
+  /* Compute memory required for `buffer'. */
+#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
+  len = mbstowcs (NULL, alt_digits, 0);
+  if (len == (size_t) -1)
+    {
+      free (adi->digit);
+      free (adi);
+      return NULL;
+    }
+#else
+  len = ALT_STRLEN (alt_digits);
+#endif
+  /* Allocate it. */
+  adi->buffer = (CHAR *) malloc ((len + 1) * sizeof (CHAR));
+  if (!adi->buffer)
+    {
+      free (adi->digit);
+      free (adi);
+      return NULL;
+    }
+  /* Store digits in it. */
+#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
+  mbstowcs (adi->buffer, alt_digits, len + 1);
+#else
+  ALT_STRCPY (adi->buffer, alt_digits);
+#endif
+  /* Store the pointers into `buffer' into the appropriate `digit' slot. */
+  for (len = 0, aa = adi->buffer; (ae = STRCHR (aa, CQ(';'))) != NULL;
+       ++len, aa = ae + 1)
+    {
+      *ae = '\0';
+      adi->digit[len] = aa;
+    }
+  adi->digit[len] = aa;
+  return adi;
+}
+
+static void
+free_alt_digits (alt_digits_t *adi)
+{
+  free (adi->digit);
+  free (adi->buffer);
+  free (adi);
+}
+
+/* Return 0 if no alt_digit is available for a number.
+   Return -1 if buffer size isn't sufficient to hold alternative digit.
+   Return length of new digit otherwise. */
+static int
+conv_to_alt_digits (CHAR *buf, size_t bufsiz, unsigned num, alt_digits_t *adi)
+{
+  if (num < adi->num)
+    {
+      size_t len = STRLEN (adi->digit[num]);
+      if (bufsiz < len)
+      	return -1;
+      STRCPY (buf, adi->digit[num]);
+      return (int) len;
+    }
+  return 0;
+}
+
+static size_t __strftime (CHAR *, size_t, const CHAR *, const struct tm *,
+			  era_info_t **, alt_digits_t **);
 
 size_t
 _DEFUN (strftime, (s, maxsize, format, tim_p),
-	char *s _AND
+	CHAR *s _AND
 	size_t maxsize _AND
-	_CONST char *format _AND
+	_CONST CHAR *format _AND
 	_CONST struct tm *tim_p)
 {
+  era_info_t *era_info = NULL;
+  alt_digits_t *alt_digits = NULL;
+  size_t ret = __strftime (s, maxsize, format, tim_p, &era_info, &alt_digits);
+  if (era_info)
+    free_era_info (era_info);
+  if (alt_digits)
+    free_alt_digits (alt_digits);
+  return ret;
+}
+
+static size_t
+__strftime (CHAR *s, size_t maxsize, const CHAR *format,
+	    const struct tm *tim_p, era_info_t **era_info,
+	    alt_digits_t **alt_digits)
+#else /* !_WANT_C99_TIME_FORMATS */
+# define __strftime(s,m,f,t,e,a)	strftime((s),(m),(f),(t))
+
+size_t
+_DEFUN (strftime, (s, maxsize, format, tim_p),
+	CHAR *s _AND
+	size_t maxsize _AND
+	_CONST CHAR *format _AND
+	_CONST struct tm *tim_p)
+#endif /* !_WANT_C99_TIME_FORMATS */
+{
   size_t count = 0;
-  int i;
+  int i, len;
+  const CHAR *ctloc;
+#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
+  CHAR ctlocbuf[CTLOCBUFLEN];
+#endif
+  size_t ctloclen;
+  CHAR alt;
+  CHAR pad;
+  unsigned long width;
 
+  struct lc_time_T *_CurrentTimeLocale = __get_current_time_locale ();
   for (;;)
     {
-      while (*format && *format != '%')
+      while (*format && *format != CQ('%'))
 	{
 	  if (count < maxsize - 1)
 	    s[count++] = *format++;
 	  else
 	    return 0;
 	}
-
-      if (*format == '\0')
+      if (*format == CQ('\0'))
 	break;
-
       format++;
+      pad = '\0';
+      width = 0;
+
+      /* POSIX-1.2008 feature: '0' and '+' modifiers require 0-padding with
+         slightly different semantics. */
+      if (*format == CQ('0') || *format == CQ('+'))
+	pad = *format++;
+
+      /* POSIX-1.2008 feature: A minimum field width can be specified. */
+      if (*format >= CQ('1') && *format <= CQ('9'))
+      	{
+	  CHAR *fp;
+	  width = STRTOUL (format, &fp, 10);
+	  format = fp;
+	}
+
+      alt = CQ('\0');
+      if (*format == CQ('E'))
+	{
+	  alt = *format++;
+#ifdef _WANT_C99_TIME_FORMATS      
+#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
+	  if (!*era_info && *_CurrentTimeLocale->wera)
+	    *era_info = get_era_info (tim_p, _CurrentTimeLocale->wera);
+#else
+	  if (!*era_info && *_CurrentTimeLocale->era)
+	    *era_info = get_era_info (tim_p, _CurrentTimeLocale->era);
+#endif
+#endif /* _WANT_C99_TIME_FORMATS */
+	}
+      else if (*format == CQ('O'))
+	{
+	  alt = *format++;
+#ifdef _WANT_C99_TIME_FORMATS      
+#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
+	  if (!*alt_digits && *_CurrentTimeLocale->walt_digits)
+	    *alt_digits = get_alt_digits (_CurrentTimeLocale->walt_digits);
+#else
+	  if (!*alt_digits && *_CurrentTimeLocale->alt_digits)
+	    *alt_digits = get_alt_digits (_CurrentTimeLocale->alt_digits);
+#endif
+#endif /* _WANT_C99_TIME_FORMATS */
+	}
+
       switch (*format)
 	{
-	case 'a':
-	  for (i = 0; i < 3; i++)
+	case CQ('a'):
+	  _ctloc (wday[tim_p->tm_wday]);
+	  for (i = 0; i < ctloclen; i++)
 	    {
 	      if (count < maxsize - 1)
-		s[count++] =
-		  dname[tim_p->tm_wday][i];
+		s[count++] = ctloc[i];
 	      else
 		return 0;
 	    }
 	  break;
-	case 'A':
-	  for (i = 0; i < dname_len[tim_p->tm_wday]; i++)
+	case CQ('A'):
+	  _ctloc (weekday[tim_p->tm_wday]);
+	  for (i = 0; i < ctloclen; i++)
 	    {
 	      if (count < maxsize - 1)
-		s[count++] =
-		  dname[tim_p->tm_wday][i];
+		s[count++] = ctloc[i];
 	      else
 		return 0;
 	    }
 	  break;
-	case 'b':
-	  for (i = 0; i < 3; i++)
+	case CQ('b'):
+	case CQ('h'):
+	  _ctloc (mon[tim_p->tm_mon]);
+	  for (i = 0; i < ctloclen; i++)
 	    {
 	      if (count < maxsize - 1)
-		s[count++] =
-		  mname[tim_p->tm_mon][i];
+		s[count++] = ctloc[i];
 	      else
 		return 0;
 	    }
 	  break;
-	case 'B':
-	  for (i = 0; i < mname_len[tim_p->tm_mon]; i++)
+	case CQ('B'):
+	  _ctloc (month[tim_p->tm_mon]);
+	  for (i = 0; i < ctloclen; i++)
 	    {
 	      if (count < maxsize - 1)
-		s[count++] =
-		  mname[tim_p->tm_mon][i];
+		s[count++] = ctloc[i];
 	      else
 		return 0;
 	    }
 	  break;
-	case 'c':
-	  if (count < maxsize - 24)
-	    {
-	      for (i = 0; i < 3; i++)
-		s[count++] =
-		  dname[tim_p->tm_wday][i];
-	      s[count++] = ' ';
-	      for (i = 0; i < 3; i++)
-		s[count++] =
-		  mname[tim_p->tm_mon][i];
-
-	      sprintf (&s[count],
-		       " %.2d %2.2d:%2.2d:%2.2d %.4d",
-		       tim_p->tm_mday, tim_p->tm_hour,
-		       tim_p->tm_min,
-		       tim_p->tm_sec, 1900 +
-		       tim_p->tm_year);
-	      count += 17;
-	    }
+	case CQ('c'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt == 'E' && *era_info && *_CurrentTimeLocale->era_d_t_fmt)
+	    _ctloc (era_d_t_fmt);
 	  else
-	    return 0;
-	  break;
-	case 'd':
-	  if (count < maxsize - 2)
-	    {
-	      sprintf (&s[count], "%.2d",
-		       tim_p->tm_mday);
-	      count += 2;
-	    }
+#endif /* _WANT_C99_TIME_FORMATS */
+	    _ctloc (c_fmt);
+	  goto recurse;
+	case CQ('r'):
+	  _ctloc (ampm_fmt);
+	  goto recurse;
+	case CQ('x'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt == 'E' && *era_info && *_CurrentTimeLocale->era_d_fmt)
+	    _ctloc (era_d_fmt);
 	  else
-	    return 0;
-	  break;
-	case 'H':
-	  if (count < maxsize - 2)
-	    {
-	      sprintf (&s[count], "%2.2d",
-		       tim_p->tm_hour);
-	      count += 2;
-	    }
+#endif /* _WANT_C99_TIME_FORMATS */
+	    _ctloc (x_fmt);
+	  goto recurse;
+	case CQ('X'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt == 'E' && *era_info && *_CurrentTimeLocale->era_t_fmt)
+	    _ctloc (era_t_fmt);
 	  else
-	    return 0;
-	  break;
-	case 'I':
-	  if (count < maxsize - 2)
+#endif /* _WANT_C99_TIME_FORMATS */
+	    _ctloc (X_fmt);
+recurse:
+	  if (*ctloc)
 	    {
-	      if (tim_p->tm_hour == 0 ||
-		  tim_p->tm_hour == 12)
-		{
-		  s[count++] = '1';
-		  s[count++] = '2';
-		}
+	      /* Recurse to avoid need to replicate %Y formation. */
+	      len = __strftime (&s[count], maxsize - count, ctloc, tim_p,
+				era_info, alt_digits);
+	      if (len > 0)
+		count += len;
 	      else
-		{
-		  sprintf (&s[count], "%.2d",
-			   tim_p->tm_hour % 12);
-		  count += 2;
-		}
+		return 0;
 	    }
-	  else
-	    return 0;
 	  break;
-	case 'j':
-	  if (count < maxsize - 3)
-	    {
-	      sprintf (&s[count], "%.3d",
-		       tim_p->tm_yday + 1);
-	      count += 3;
-	    }
-	  else
-	    return 0;
+	case CQ('C'):
+	  {
+	    /* Examples of (tm_year + YEAR_BASE) that show how %Y == %C%y
+	       with 32-bit int.
+	       %Y		%C		%y
+	       2147485547	21474855	47
+	       10000		100		00
+	       9999		99		99
+	       0999		09		99
+	       0099		00		99
+	       0001		00		01
+	       0000		00		00
+	       -001		-0		01
+	       -099		-0		99
+	       -999		-9		99
+	       -1000		-10		00
+	       -10000		-100		00
+	       -2147481748	-21474817	48
+
+	       Be careful of both overflow and sign adjustment due to the
+	       asymmetric range of years.
+	    */
+#ifdef _WANT_C99_TIME_FORMATS
+	    if (alt == 'E' && *era_info)
+	      len = snprintf (&s[count], maxsize - count, CQ("%" SFLG "s"),
+			      (*era_info)->era_C);
+	    else
+#endif /* _WANT_C99_TIME_FORMATS */
+	      {
+		CHAR *fmt = CQ("%s%.*d");
+		char *pos = "";
+		int neg = tim_p->tm_year < -YEAR_BASE;
+		int century = tim_p->tm_year >= 0
+		  ? tim_p->tm_year / 100 + YEAR_BASE / 100
+		  : abs (tim_p->tm_year + YEAR_BASE) / 100;
+		if (pad) /* '0' or '+' */
+		  {
+		    fmt = CQ("%s%0.*d");
+		    if (century >= 100 && pad == CQ('+'))
+		      pos = "+";
+		  }
+		if (width < 2)
+		  width = 2;
+		len = snprintf (&s[count], maxsize - count, fmt,
+				neg ? "-" : pos, width - neg, century);
+	      }
+            CHECK_LENGTH ();
+	  }
 	  break;
-	case 'm':
-	  if (count < maxsize - 2)
+	case CQ('d'):
+	case CQ('e'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt == CQ('O') && *alt_digits)
 	    {
-	      sprintf (&s[count], "%.2d",
-		       tim_p->tm_mon + 1);
-	      count += 2;
+	      if (tim_p->tm_mday < 10)
+	      	{
+		  if (*format == CQ('d'))
+		    {
+		      if (maxsize - count < 2) return 0;
+		      len = conv_to_alt_digits (&s[count], maxsize - count,
+						0, *alt_digits);
+		      CHECK_LENGTH ();
+		    }
+		  if (*format == CQ('e') || len == 0)
+		    s[count++] = CQ(' ');
+		}
+	      len = conv_to_alt_digits (&s[count], maxsize - count,
+					tim_p->tm_mday, *alt_digits);
+	      CHECK_LENGTH ();
+	      if (len > 0)
+		break;
 	    }
-	  else
-	    return 0;
+#endif /* _WANT_C99_TIME_FORMATS */
+	  len = snprintf (&s[count], maxsize - count,
+			  *format == CQ('d') ? CQ("%.2d") : CQ("%2d"),
+			  tim_p->tm_mday);
+	  CHECK_LENGTH ();
+	  break;
+	case CQ('D'):
+	  /* %m/%d/%y */
+	  len = snprintf (&s[count], maxsize - count,
+			  CQ("%.2d/%.2d/%.2d"),
+			  tim_p->tm_mon + 1, tim_p->tm_mday,
+			  tim_p->tm_year >= 0 ? tim_p->tm_year % 100
+			  : abs (tim_p->tm_year + YEAR_BASE) % 100);
+          CHECK_LENGTH ();
 	  break;
-	case 'M':
-	  if (count < maxsize - 2)
+	case CQ('F'):
+	  { /* %F is equivalent to "%+4Y-%m-%d", flags and width can change
+	       that.  Recurse to avoid need to replicate %Y formation. */
+	    CHAR fmtbuf[32], *fmt = fmtbuf;
+	    
+	    *fmt++ = CQ('%');
+	    if (pad) /* '0' or '+' */
+	      *fmt++ = pad;
+	    else
+	      *fmt++ = '+';
+	    if (!pad)
+	      width = 10;
+	    if (width < 6)
+	      width = 6;
+	    width -= 6;
+	    if (width)
+	      {
+		len = snprintf (fmt, fmtbuf + 32 - fmt, CQ("%lu"), width);
+		if (len > 0)
+		  fmt += len;
+	      }
+	    STRCPY (fmt, CQ("Y-%m-%d"));
+	    len = __strftime (&s[count], maxsize - count, fmtbuf, tim_p,
+			      era_info, alt_digits);
+	    if (len > 0)
+	      count += len;
+	    else
+	      return 0;
+	  }
+          break;
+	case CQ('g'):
+	  /* Be careful of both overflow and negative years, thanks to
+		 the asymmetric range of years.  */
+	  {
+	    int adjust = iso_year_adjust (tim_p);
+	    int year = tim_p->tm_year >= 0 ? tim_p->tm_year % 100
+		: abs (tim_p->tm_year + YEAR_BASE) % 100;
+	    if (adjust < 0 && tim_p->tm_year <= -YEAR_BASE)
+		adjust = 1;
+	    else if (adjust > 0 && tim_p->tm_year < -YEAR_BASE)
+		adjust = -1;
+	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
+			    ((year + adjust) % 100 + 100) % 100);
+            CHECK_LENGTH ();
+	  }
+          break;
+	case CQ('G'):
+	  {
+	    /* See the comments for 'C' and 'Y'; this is a variable length
+	       field.  Although there is no requirement for a minimum number
+	       of digits, we use 4 for consistency with 'Y'.  */
+	    int sign = tim_p->tm_year < -YEAR_BASE;
+	    int adjust = iso_year_adjust (tim_p);
+	    int century = tim_p->tm_year >= 0
+	      ? tim_p->tm_year / 100 + YEAR_BASE / 100
+	      : abs (tim_p->tm_year + YEAR_BASE) / 100;
+	    int year = tim_p->tm_year >= 0 ? tim_p->tm_year % 100
+	      : abs (tim_p->tm_year + YEAR_BASE) % 100;
+            CHAR fmtbuf[10], *fmt = fmtbuf;
+            /* int potentially overflows, so use unsigned instead.  */
+            unsigned p_year;
+	    if (adjust < 0 && tim_p->tm_year <= -YEAR_BASE)
+	      sign = adjust = 1;
+	    else if (adjust > 0 && sign)
+	      adjust = -1;
+	    year += adjust;
+	    if (year == -1)
+	      {
+		year = 99;
+		--century;
+	      }
+	    else if (year == 100)
+	      {
+		year = 0;
+		++century;
+	      }
+	    p_year = century * 100 + year;
+	    if (sign)
+	      *fmt++ = CQ('-');
+	    else if (pad == CQ('+') && p_year >= 10000)
+	      {
+		*fmt++ = CQ('+');
+		sign = 1;
+	      }
+	    if (width && sign)
+	      --width;
+	    *fmt++ = CQ('%');
+	    if (pad)
+	      *fmt++ = CQ('0');
+	    STRCPY (fmt, CQ(".*u"));
+	    len = snprintf (&s[count], maxsize - count, fmtbuf, width, p_year);
+            if (len < 0  ||  (count+=len) >= maxsize)
+              return 0;
+	  }
+          break;
+	case CQ('H'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt == CQ('O') && *alt_digits)
 	    {
-	      sprintf (&s[count], "%2.2d",
-		       tim_p->tm_min);
-	      count += 2;
+	      len = conv_to_alt_digits (&s[count], maxsize - count,
+					tim_p->tm_hour, *alt_digits);
+	      CHECK_LENGTH ();
+	      if (len > 0)
+		break;
 	    }
+#endif /* _WANT_C99_TIME_FORMATS */
+	  /*FALLTHRU*/
+	case CQ('k'):	/* newlib extension */
+	  len = snprintf (&s[count], maxsize - count,
+			  *format == CQ('k') ? CQ("%2d") : CQ("%.2d"),
+			  tim_p->tm_hour);
+          CHECK_LENGTH ();
+	  break;
+	case CQ('l'):	/* newlib extension */
+	  if (alt == CQ('O'))
+	    alt = CQ('\0');
+	  /*FALLTHRU*/
+	case CQ('I'):
+	  {
+	    register int  h12;
+	    h12 = (tim_p->tm_hour == 0 || tim_p->tm_hour == 12)  ?
+						12  :  tim_p->tm_hour % 12;
+#ifdef _WANT_C99_TIME_FORMATS
+	    if (alt != CQ('O') || !*alt_digits
+		|| !(len = conv_to_alt_digits (&s[count], maxsize - count,
+					       h12, *alt_digits)))
+#endif /* _WANT_C99_TIME_FORMATS */
+	      len = snprintf (&s[count], maxsize - count,
+			      *format == CQ('I') ? CQ("%.2d") : CQ("%2d"), h12);
+	    CHECK_LENGTH ();
+	  }
+	  break;
+	case CQ('j'):
+	  len = snprintf (&s[count], maxsize - count, CQ("%.3d"),
+			  tim_p->tm_yday + 1);
+          CHECK_LENGTH ();
+	  break;
+	case CQ('m'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt != CQ('O') || !*alt_digits
+	      || !(len = conv_to_alt_digits (&s[count], maxsize - count,
+					     tim_p->tm_mon + 1, *alt_digits)))
+#endif /* _WANT_C99_TIME_FORMATS */
+	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
+			    tim_p->tm_mon + 1);
+          CHECK_LENGTH ();
+	  break;
+	case CQ('M'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt != CQ('O') || !*alt_digits
+	      || !(len = conv_to_alt_digits (&s[count], maxsize - count,
+					     tim_p->tm_min, *alt_digits)))
+#endif /* _WANT_C99_TIME_FORMATS */
+	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
+			    tim_p->tm_min);
+          CHECK_LENGTH ();
+	  break;
+	case CQ('n'):
+	  if (count < maxsize - 1)
+	    s[count++] = CQ('\n');
 	  else
 	    return 0;
 	  break;
-	case 'p':
-	  if (count < maxsize - 2)
+	case CQ('p'):
+	case CQ('P'):
+	  _ctloc (am_pm[tim_p->tm_hour < 12 ? 0 : 1]);
+	  for (i = 0; i < ctloclen; i++)
 	    {
-	      if (tim_p->tm_hour < 12)
-		s[count++] = 'A';
+	      if (count < maxsize - 1)
+		s[count++] = (*format == CQ('P') ? TOLOWER (ctloc[i])
+						 : ctloc[i]);
 	      else
-		s[count++] = 'P';
-
-	      s[count++] = 'M';
+		return 0;
 	    }
-	  else
-	    return 0;
 	  break;
-	case 'S':
-	  if (count < maxsize - 2)
-	    {
-	      sprintf (&s[count], "%2.2d",
-		       tim_p->tm_sec);
-	      count += 2;
-	    }
-	  else
-	    return 0;
+	case CQ('R'):
+          len = snprintf (&s[count], maxsize - count, CQ("%.2d:%.2d"),
+			  tim_p->tm_hour, tim_p->tm_min);
+          CHECK_LENGTH ();
+          break;
+	case CQ('S'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt != CQ('O') || !*alt_digits
+	      || !(len = conv_to_alt_digits (&s[count], maxsize - count,
+					     tim_p->tm_sec, *alt_digits)))
+#endif /* _WANT_C99_TIME_FORMATS */
+	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
+			    tim_p->tm_sec);
+          CHECK_LENGTH ();
 	  break;
-	case 'U':
-	  if (count < maxsize - 2)
-	    {
-	      sprintf (&s[count], "%2.2d",
-		       (tim_p->tm_yday + 7 -
-			tim_p->tm_wday) / 7);
-	      count += 2;
-	    }
+	case CQ('t'):
+	  if (count < maxsize - 1)
+	    s[count++] = CQ('\t');
 	  else
 	    return 0;
 	  break;
-	case 'w':
-	  if (count < maxsize - 1)
+	case CQ('T'):
+          len = snprintf (&s[count], maxsize - count, CQ("%.2d:%.2d:%.2d"),
+			  tim_p->tm_hour, tim_p->tm_min, tim_p->tm_sec);
+          CHECK_LENGTH ();
+          break;
+	case CQ('u'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt == CQ('O') && *alt_digits)
 	    {
-	      sprintf (&s[count], "%1.1d",
-		       tim_p->tm_wday);
-	      count++;
+	      len = conv_to_alt_digits (&s[count], maxsize - count,
+					tim_p->tm_wday == 0 ? 7
+							    : tim_p->tm_wday,
+					*alt_digits);
+	      CHECK_LENGTH ();
+	      if (len > 0)
+		break;
 	    }
-	  else
-	    return 0;
+#endif /* _WANT_C99_TIME_FORMATS */
+          if (count < maxsize - 1)
+            {
+              if (tim_p->tm_wday == 0)
+                s[count++] = CQ('7');
+              else
+                s[count++] = CQ('0') + tim_p->tm_wday;
+            }
+          else
+            return 0;
+          break;
+	case CQ('U'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt != CQ('O') || !*alt_digits
+	      || !(len = conv_to_alt_digits (&s[count], maxsize - count,
+					     (tim_p->tm_yday + 7 -
+					      tim_p->tm_wday) / 7,
+					     *alt_digits)))
+#endif /* _WANT_C99_TIME_FORMATS */
+	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
+			 (tim_p->tm_yday + 7 -
+			  tim_p->tm_wday) / 7);
+          CHECK_LENGTH ();
 	  break;
-	case 'W':
-	  if (count < maxsize - 2)
+	case CQ('V'):
+	  {
+	    int adjust = iso_year_adjust (tim_p);
+	    int wday = (tim_p->tm_wday) ? tim_p->tm_wday - 1 : 6;
+	    int week = (tim_p->tm_yday + 10 - wday) / 7;
+	    if (adjust > 0)
+		week = 1;
+	    else if (adjust < 0)
+		/* Previous year has 53 weeks if current year starts on
+		   Fri, and also if current year starts on Sat and
+		   previous year was leap year.  */
+		week = 52 + (4 >= (wday - tim_p->tm_yday
+				   - isleap (tim_p->tm_year
+					     + (YEAR_BASE - 1
+						- (tim_p->tm_year < 0
+						   ? 0 : 2000)))));
+#ifdef _WANT_C99_TIME_FORMATS
+	    if (alt != CQ('O') || !*alt_digits
+		|| !(len = conv_to_alt_digits (&s[count], maxsize - count,
+					       week, *alt_digits)))
+#endif /* _WANT_C99_TIME_FORMATS */
+	      len = snprintf (&s[count], maxsize - count, CQ("%.2d"), week);
+            CHECK_LENGTH ();
+	  }
+          break;
+	case CQ('w'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt == CQ('O') && *alt_digits)
 	    {
-	      sprintf (&s[count], "%2.2d",
-		       (tim_p->tm_yday + ((8 -
-					   tim_p->tm_wday) % 7)) / 7);
-	      count += 2;
+	      len = conv_to_alt_digits (&s[count], maxsize - count,
+					tim_p->tm_wday, *alt_digits);
+	      CHECK_LENGTH ();
+	      if (len > 0)
+		break;
 	    }
+#endif /* _WANT_C99_TIME_FORMATS */
+	  if (count < maxsize - 1)
+            s[count++] = CQ('0') + tim_p->tm_wday;
 	  else
 	    return 0;
 	  break;
-	case 'x':
-	  if (count < maxsize - 15)
+	case CQ('W'):
+	  {
+	    int wday = (tim_p->tm_wday) ? tim_p->tm_wday - 1 : 6;
+	    wday = (tim_p->tm_yday + 7 - wday) / 7;
+#ifdef _WANT_C99_TIME_FORMATS
+	    if (alt != CQ('O') || !*alt_digits
+		|| !(len = conv_to_alt_digits (&s[count], maxsize - count,
+					       wday, *alt_digits)))
+#endif /* _WANT_C99_TIME_FORMATS */
+	      len = snprintf (&s[count], maxsize - count, CQ("%.2d"), wday);
+            CHECK_LENGTH ();
+	  }
+	  break;
+	case CQ('y'):
 	    {
-	      for (i = 0; i < 3; i++)
-		s[count++] =
-		  dname[tim_p->tm_wday][i];
-	      s[count++] = ' ';
-	      for (i = 0; i < 3; i++)
-		s[count++] =
-		  mname[tim_p->tm_mon][i];
-
-	      sprintf (&s[count],
-		       " %.2d %.4d", tim_p->tm_mday,
-		       1900 + tim_p->tm_year);
-	      count += 8;
+#ifdef _WANT_C99_TIME_FORMATS
+	      if (alt == 'E' && *era_info)
+		len = snprintf (&s[count], maxsize - count, CQ("%d"),
+				(*era_info)->year);
+	      else
+#endif /* _WANT_C99_TIME_FORMATS */
+		{
+		  /* Be careful of both overflow and negative years, thanks to
+		     the asymmetric range of years.  */
+		  int year = tim_p->tm_year >= 0 ? tim_p->tm_year % 100
+			     : abs (tim_p->tm_year + YEAR_BASE) % 100;
+#ifdef _WANT_C99_TIME_FORMATS
+		  if (alt != CQ('O') || !*alt_digits
+		      || !(len = conv_to_alt_digits (&s[count], maxsize - count,
+						     year, *alt_digits)))
+#endif /* _WANT_C99_TIME_FORMATS */
+		    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
+				    year);
+		}
+              CHECK_LENGTH ();
 	    }
-	  else
-	    return 0;
 	  break;
-	case 'X':
-	  if (count < maxsize - 8)
+	case CQ('Y'):
+#ifdef _WANT_C99_TIME_FORMATS
+	  if (alt == 'E' && *era_info)
 	    {
-	      sprintf (&s[count],
-		       "%2.2d:%2.2d:%2.2d",
-		       tim_p->tm_hour, tim_p->tm_min,
-		       tim_p->tm_sec);
-	      count += 8;
+	      ctloc = (*era_info)->era_Y;
+	      goto recurse;
 	    }
 	  else
-	    return 0;
-	  break;
-	case 'y':
-	  if (count < maxsize - 2)
+#endif /* _WANT_C99_TIME_FORMATS */
 	    {
-	      /* The year could be greater than 100, so we need the value
-		 modulo 100.  The year could be negative, so we need to
-		 correct for a possible negative remainder.  */
-	      sprintf (&s[count], "%2.2d",
-		       (tim_p->tm_year % 100 + 100) % 100);
-	      count += 2;
+	      CHAR fmtbuf[10], *fmt = fmtbuf;
+	      int sign = tim_p->tm_year < -YEAR_BASE;
+	      /* int potentially overflows, so use unsigned instead.  */
+	      register unsigned year = (unsigned) tim_p->tm_year
+				       + (unsigned) YEAR_BASE;
+	      if (sign)
+		{
+		  *fmt++ = CQ('-');
+		  year = UINT_MAX - year + 1;
+		}
+	      else if (pad == CQ('+') && year >= 10000)
+		{
+		  *fmt++ = CQ('+');
+		  sign = 1;
+		}
+	      if (width && sign)
+		--width;
+	      *fmt++ = CQ('%');
+	      if (pad)
+		*fmt++ = CQ('0');
+	      STRCPY (fmt, CQ(".*u"));
+	      len = snprintf (&s[count], maxsize - count, fmtbuf, width,
+			      year);
+	      CHECK_LENGTH ();
 	    }
-	  else
-	    return 0;
 	  break;
-	case 'Y':
-	  if (count < maxsize - 4)
+	case CQ('z'):
+          if (tim_p->tm_isdst >= 0)
+            {
+	      long offset;
+	      __tzinfo_type *tz = __gettzinfo ();
+	      TZ_LOCK;
+	      /* The sign of this is exactly opposite the envvar TZ.  We
+	         could directly use the global _timezone for tm_isdst==0,
+	         but have to use __tzrule for daylight savings.  */
+	      offset = -tz->__tzrule[tim_p->tm_isdst > 0].offset;
+	      TZ_UNLOCK;
+	      len = snprintf (&s[count], maxsize - count, CQ("%+03ld%.2ld"),
+			      offset / SECSPERHOUR,
+			      labs (offset / SECSPERMIN) % 60L);
+              CHECK_LENGTH ();
+            }
+          break;
+	case CQ('Z'):
+	  if (tim_p->tm_isdst >= 0)
 	    {
-	      sprintf (&s[count], "%.4d",
-		       1900 + tim_p->tm_year);
-	      count += 4;
+	      int size;
+	      TZ_LOCK;
+	      size = strlen(_tzname[tim_p->tm_isdst > 0]);
+	      for (i = 0; i < size; i++)
+		{
+		  if (count < maxsize - 1)
+		    s[count++] = _tzname[tim_p->tm_isdst > 0][i];
+		  else
+		    {
+		      TZ_UNLOCK;
+		      return 0;
+		    }
+		}
+	      TZ_UNLOCK;
 	    }
-	  else
-	    return 0;
 	  break;
-	case 'Z':
-	  break;
-	case '%':
+	case CQ('%'):
 	  if (count < maxsize - 1)
-	    s[count++] = '%';
+	    s[count++] = CQ('%');
 	  else
 	    return 0;
 	  break;
+	default:
+	  return 0;
 	}
       if (*format)
 	format++;
       else
 	break;
     }
-  s[count] = '\0';
+  if (maxsize)
+    s[count] = CQ('\0');
 
   return count;
 }
+
+/* The remainder of this file can serve as a regression test.  Compile
+ *  with -D_REGRESSION_TEST.  */
+#if defined(_REGRESSION_TEST)	/* [Test code:  */
+ 
+/* This test code relies on ANSI C features, in particular on the ability
+ * of adjacent strings to be pasted together into one string.  */
+ 
+/* Test output buffer size (should be larger than all expected results) */
+#define OUTSIZE	256
+ 
+struct test {
+	CHAR  *fmt;	/* Testing format */
+	size_t  max;	/* Testing maxsize */
+	size_t	ret;	/* Expected return value */
+	CHAR  *out;	/* Expected output string */
+	};
+struct list {
+	const struct tm  *tms;	/* Time used for these vectors */
+	const struct test *vec;	/* Test vectors */
+	int  cnt;		/* Number of vectors */
+	};
+ 
+const char  TZ[]="TZ=EST5EDT";
+ 
+/* Define list of test inputs and expected outputs, for the given time zone
+ * and time.  */
+const struct tm  tm0 = {
+	/* Tue Dec 30 10:53:47 EST 2008 (time_t=1230648827) */
+	.tm_sec 	= 47,
+	.tm_min 	= 53,
+	.tm_hour	= 9,
+	.tm_mday	= 30,
+	.tm_mon 	= 11,
+	.tm_year	= 108,
+	.tm_wday	= 2,
+	.tm_yday	= 364,
+	.tm_isdst	= 0
+	};
+const struct test  Vec0[] = {
+	/* Testing fields one at a time, expecting to pass, using exact
+	 * allowed length as what is needed.  */
+	/* Using tm0 for time: */
+	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
+	{ CQ("%a"), 3+1, EXP(CQ("Tue")) },
+	{ CQ("%A"), 7+1, EXP(CQ("Tuesday")) },
+	{ CQ("%b"), 3+1, EXP(CQ("Dec")) },
+	{ CQ("%B"), 8+1, EXP(CQ("December")) },
+	{ CQ("%c"), 24+1, EXP(CQ("Tue Dec 30 09:53:47 2008")) },
+	{ CQ("%C"), 2+1, EXP(CQ("20")) },
+	{ CQ("%d"), 2+1, EXP(CQ("30")) },
+	{ CQ("%D"), 8+1, EXP(CQ("12/30/08")) },
+	{ CQ("%e"), 2+1, EXP(CQ("30")) },
+	{ CQ("%F"), 10+1, EXP(CQ("2008-12-30")) },
+	{ CQ("%g"), 2+1, EXP(CQ("09")) },
+	{ CQ("%G"), 4+1, EXP(CQ("2009")) },
+	{ CQ("%h"), 3+1, EXP(CQ("Dec")) },
+	{ CQ("%H"), 2+1, EXP(CQ("09")) },
+	{ CQ("%I"), 2+1, EXP(CQ("09")) },
+	{ CQ("%j"), 3+1, EXP(CQ("365")) },
+	{ CQ("%k"), 2+1, EXP(CQ(" 9")) },
+	{ CQ("%l"), 2+1, EXP(CQ(" 9")) },
+	{ CQ("%m"), 2+1, EXP(CQ("12")) },
+	{ CQ("%M"), 2+1, EXP(CQ("53")) },
+	{ CQ("%n"), 1+1, EXP(CQ("\n")) },
+	{ CQ("%p"), 2+1, EXP(CQ("AM")) },
+	{ CQ("%r"), 11+1, EXP(CQ("09:53:47 AM")) },
+	{ CQ("%R"), 5+1, EXP(CQ("09:53")) },
+	{ CQ("%S"), 2+1, EXP(CQ("47")) },
+	{ CQ("%t"), 1+1, EXP(CQ("\t")) },
+	{ CQ("%T"), 8+1, EXP(CQ("09:53:47")) },
+	{ CQ("%u"), 1+1, EXP(CQ("2")) },
+	{ CQ("%U"), 2+1, EXP(CQ("52")) },
+	{ CQ("%V"), 2+1, EXP(CQ("01")) },
+	{ CQ("%w"), 1+1, EXP(CQ("2")) },
+	{ CQ("%W"), 2+1, EXP(CQ("52")) },
+	{ CQ("%x"), 8+1, EXP(CQ("12/30/08")) },
+	{ CQ("%X"), 8+1, EXP(CQ("09:53:47")) },
+	{ CQ("%y"), 2+1, EXP(CQ("08")) },
+	{ CQ("%Y"), 4+1, EXP(CQ("2008")) },
+	{ CQ("%z"), 5+1, EXP(CQ("-0500")) },
+	{ CQ("%Z"), 3+1, EXP(CQ("EST")) },
+	{ CQ("%%"), 1+1, EXP(CQ("%")) },
+	#undef EXP
+	};
+/* Define list of test inputs and expected outputs, for the given time zone
+ * and time.  */
+const struct tm  tm1 = {
+	/* Wed Jul  2 23:01:13 EDT 2008 (time_t=1215054073) */
+	.tm_sec 	= 13,
+	.tm_min 	= 1,
+	.tm_hour	= 23,
+	.tm_mday	= 2,
+	.tm_mon 	= 6,
+	.tm_year	= 108,
+	.tm_wday	= 3,
+	.tm_yday	= 183,
+	.tm_isdst	= 1
+	};
+const struct test  Vec1[] = {
+	/* Testing fields one at a time, expecting to pass, using exact
+	 * allowed length as what is needed.  */
+	/* Using tm1 for time: */
+	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
+	{ CQ("%a"), 3+1, EXP(CQ("Wed")) },
+	{ CQ("%A"), 9+1, EXP(CQ("Wednesday")) },
+	{ CQ("%b"), 3+1, EXP(CQ("Jul")) },
+	{ CQ("%B"), 4+1, EXP(CQ("July")) },
+	{ CQ("%c"), 24+1, EXP(CQ("Wed Jul  2 23:01:13 2008")) },
+	{ CQ("%C"), 2+1, EXP(CQ("20")) },
+	{ CQ("%d"), 2+1, EXP(CQ("02")) },
+	{ CQ("%D"), 8+1, EXP(CQ("07/02/08")) },
+	{ CQ("%e"), 2+1, EXP(CQ(" 2")) },
+	{ CQ("%F"), 10+1, EXP(CQ("2008-07-02")) },
+	{ CQ("%g"), 2+1, EXP(CQ("08")) },
+	{ CQ("%G"), 4+1, EXP(CQ("2008")) },
+	{ CQ("%h"), 3+1, EXP(CQ("Jul")) },
+	{ CQ("%H"), 2+1, EXP(CQ("23")) },
+	{ CQ("%I"), 2+1, EXP(CQ("11")) },
+	{ CQ("%j"), 3+1, EXP(CQ("184")) },
+	{ CQ("%k"), 2+1, EXP(CQ("23")) },
+	{ CQ("%l"), 2+1, EXP(CQ("11")) },
+	{ CQ("%m"), 2+1, EXP(CQ("07")) },
+	{ CQ("%M"), 2+1, EXP(CQ("01")) },
+	{ CQ("%n"), 1+1, EXP(CQ("\n")) },
+	{ CQ("%p"), 2+1, EXP(CQ("PM")) },
+	{ CQ("%r"), 11+1, EXP(CQ("11:01:13 PM")) },
+	{ CQ("%R"), 5+1, EXP(CQ("23:01")) },
+	{ CQ("%S"), 2+1, EXP(CQ("13")) },
+	{ CQ("%t"), 1+1, EXP(CQ("\t")) },
+	{ CQ("%T"), 8+1, EXP(CQ("23:01:13")) },
+	{ CQ("%u"), 1+1, EXP(CQ("3")) },
+	{ CQ("%U"), 2+1, EXP(CQ("26")) },
+	{ CQ("%V"), 2+1, EXP(CQ("27")) },
+	{ CQ("%w"), 1+1, EXP(CQ("3")) },
+	{ CQ("%W"), 2+1, EXP(CQ("26")) },
+	{ CQ("%x"), 8+1, EXP(CQ("07/02/08")) },
+	{ CQ("%X"), 8+1, EXP(CQ("23:01:13")) },
+	{ CQ("%y"), 2+1, EXP(CQ("08")) },
+	{ CQ("%Y"), 4+1, EXP(CQ("2008")) },
+	{ CQ("%z"), 5+1, EXP(CQ("-0400")) },
+	{ CQ("%Z"), 3+1, EXP(CQ("EDT")) },
+	{ CQ("%%"), 1+1, EXP(CQ("%")) },
+	#undef EXP
+	#define VEC(s)	s, sizeof(s)/sizeof(CHAR), sizeof(s)/sizeof(CHAR)-1, s
+	#define EXP(s)	sizeof(s)/sizeof(CHAR), sizeof(s)/sizeof(CHAR)-1, s
+	{ VEC(CQ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")) },
+	{ CQ("0123456789%%%h:`~"), EXP(CQ("0123456789%Jul:`~")) },
+	{ CQ("%R%h:`~ %x %w"), EXP(CQ("23:01Jul:`~ 07/02/08 3")) },
+	#undef VEC
+	#undef EXP
+	};
+ 
+#if YEAR_BASE == 1900  /* ( */
+/* Checks for very large years.  YEAR_BASE value relied upon so that the
+ * answer strings can be predetermined.
+ * Years more than 4 digits are not mentioned in the standard for %C, so the
+ * test for those cases are based on the design intent (which is to print the
+ * whole number, being the century).  */
+const struct tm  tmyr0 = {
+	/* Wed Jul  2 23:01:13 EDT [HUGE#] */
+	.tm_sec 	= 13,
+	.tm_min 	= 1,
+	.tm_hour	= 23,
+	.tm_mday	= 2,
+	.tm_mon 	= 6,
+	.tm_year	= INT_MAX - YEAR_BASE/2,
+	.tm_wday	= 3,
+	.tm_yday	= 183,
+	.tm_isdst	= 1
+	};
+#if INT_MAX == 32767
+#  define YEAR	CQ("33717")		/* INT_MAX + YEAR_BASE/2 */
+#  define CENT	CQ("337")
+#  define Year	   CQ("17")
+# elif INT_MAX == 2147483647
+#  define YEAR	CQ("2147484597")
+#  define CENT	CQ("21474845")
+#  define Year	        CQ("97")
+# elif INT_MAX == 9223372036854775807
+#  define YEAR	CQ("9223372036854776757")
+#  define CENT	CQ("92233720368547777")
+#  define Year	                 CQ("57")
+# else
+#  error "Unrecognized INT_MAX value:  enhance me to recognize what you have"
+#endif
+const struct test  Vecyr0[] = {
+	/* Testing fields one at a time, expecting to pass, using a larger
+	 * allowed length than what is needed.  */
+	/* Using tmyr0 for time: */
+	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
+	{ CQ("%C"), OUTSIZE, EXP(CENT) },
+	{ CQ("%c"), OUTSIZE, EXP(CQ("Wed Jul  2 23:01:13 ")YEAR) },
+	{ CQ("%D"), OUTSIZE, EXP(CQ("07/02/")Year) },
+	{ CQ("%F"), OUTSIZE, EXP(YEAR CQ("-07-02")) },
+	{ CQ("%x"), OUTSIZE, EXP(CQ("07/02/")Year) },
+	{ CQ("%y"), OUTSIZE, EXP(Year) },
+	{ CQ("%Y"), OUTSIZE, EXP(YEAR) },
+	#undef EXP
+	};
+#undef YEAR
+#undef CENT
+#undef Year
+/* Checks for very large negative years.  YEAR_BASE value relied upon so that
+ * the answer strings can be predetermined.  */
+const struct tm  tmyr1 = {
+	/* Wed Jul  2 23:01:13 EDT [HUGE#] */
+	.tm_sec 	= 13,
+	.tm_min 	= 1,
+	.tm_hour	= 23,
+	.tm_mday	= 2,
+	.tm_mon 	= 6,
+	.tm_year	= INT_MIN,
+	.tm_wday	= 3,
+	.tm_yday	= 183,
+	.tm_isdst	= 1
+	};
+#if INT_MAX == 32767
+#  define YEAR	CQ("-30868")		/* INT_MIN + YEAR_BASE */
+#  define CENT	CQ("-308")
+#  define Year	    CQ("68")
+# elif INT_MAX == 2147483647
+#  define YEAR	CQ("-2147481748")
+#  define CENT	CQ("-21474817")
+#  define Year	         CQ("48")
+# elif INT_MAX == 9223372036854775807
+#  define YEAR	CQ("-9223372036854773908")
+#  define CENT	CQ("-92233720368547739")
+#  define Year	                  CQ("08")
+# else
+#  error "Unrecognized INT_MAX value:  enhance me to recognize what you have"
+#endif
+const struct test  Vecyr1[] = {
+	/* Testing fields one at a time, expecting to pass, using a larger
+	 * allowed length than what is needed.  */
+	/* Using tmyr1 for time: */
+	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
+	{ CQ("%C"), OUTSIZE, EXP(CENT) },
+	{ CQ("%c"), OUTSIZE, EXP(CQ("Wed Jul  2 23:01:13 ")YEAR) },
+	{ CQ("%D"), OUTSIZE, EXP(CQ("07/02/")Year) },
+	{ CQ("%F"), OUTSIZE, EXP(YEAR CQ("-07-02")) },
+	{ CQ("%x"), OUTSIZE, EXP(CQ("07/02/")Year) },
+	{ CQ("%y"), OUTSIZE, EXP(Year) },
+	{ CQ("%Y"), OUTSIZE, EXP(YEAR) },
+	#undef EXP
+	};
+#undef YEAR
+#undef CENT
+#undef Year
+#endif /* YEAR_BASE ) */
+ 
+/* Checks for years just over zero (also test for s=60).
+ * Years less than 4 digits are not mentioned for %Y in the standard, so the
+ * test for that case is based on the design intent.  */
+const struct tm  tmyrzp = {
+	/* Wed Jul  2 23:01:60 EDT 0007 */
+	.tm_sec 	= 60,
+	.tm_min 	= 1,
+	.tm_hour	= 23,
+	.tm_mday	= 2,
+	.tm_mon 	= 6,
+	.tm_year	= 7-YEAR_BASE,
+	.tm_wday	= 3,
+	.tm_yday	= 183,
+	.tm_isdst	= 1
+	};
+#define YEAR	CQ("0007")	/* Design intent:  %Y=%C%y */
+#define CENT	CQ("00")
+#define Year	  CQ("07")
+const struct test  Vecyrzp[] = {
+	/* Testing fields one at a time, expecting to pass, using a larger
+	 * allowed length than what is needed.  */
+	/* Using tmyrzp for time: */
+	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
+	{ CQ("%C"), OUTSIZE, EXP(CENT) },
+	{ CQ("%c"), OUTSIZE, EXP(CQ("Wed Jul  2 23:01:60 ")YEAR) },
+	{ CQ("%D"), OUTSIZE, EXP(CQ("07/02/")Year) },
+	{ CQ("%F"), OUTSIZE, EXP(YEAR CQ("-07-02")) },
+	{ CQ("%x"), OUTSIZE, EXP(CQ("07/02/")Year) },
+	{ CQ("%y"), OUTSIZE, EXP(Year) },
+	{ CQ("%Y"), OUTSIZE, EXP(YEAR) },
+	#undef EXP
+	};
+#undef YEAR
+#undef CENT
+#undef Year
+/* Checks for years just under zero.
+ * Negative years are not handled by the standard, so the vectors here are
+ * verifying the chosen implemtation.  */
+const struct tm  tmyrzn = {
+	/* Wed Jul  2 23:01:00 EDT -004 */
+	.tm_sec 	= 00,
+	.tm_min 	= 1,
+	.tm_hour	= 23,
+	.tm_mday	= 2,
+	.tm_mon 	= 6,
+	.tm_year	= -4-YEAR_BASE,
+	.tm_wday	= 3,
+	.tm_yday	= 183,
+	.tm_isdst	= 1
+	};
+#define YEAR	CQ("-004")
+#define CENT	CQ("-0")
+#define Year	  CQ("04")
+const struct test  Vecyrzn[] = {
+	/* Testing fields one at a time, expecting to pass, using a larger
+	 * allowed length than what is needed.  */
+	/* Using tmyrzn for time: */
+	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
+	{ CQ("%C"), OUTSIZE, EXP(CENT) },
+	{ CQ("%c"), OUTSIZE, EXP(CQ("Wed Jul  2 23:01:00 ")YEAR) },
+	{ CQ("%D"), OUTSIZE, EXP(CQ("07/02/")Year) },
+	{ CQ("%F"), OUTSIZE, EXP(YEAR CQ("-07-02")) },
+	{ CQ("%x"), OUTSIZE, EXP(CQ("07/02/")Year) },
+	{ CQ("%y"), OUTSIZE, EXP(Year) },
+	{ CQ("%Y"), OUTSIZE, EXP(YEAR) },
+	#undef EXP
+	};
+#undef YEAR
+#undef CENT
+#undef Year
+ 
+const struct list  ListYr[] = {
+	{ &tmyrzp, Vecyrzp, sizeof(Vecyrzp)/sizeof(Vecyrzp[0]) },
+	{ &tmyrzn, Vecyrzn, sizeof(Vecyrzn)/sizeof(Vecyrzn[0]) },
+	#if YEAR_BASE == 1900
+	{ &tmyr0, Vecyr0, sizeof(Vecyr0)/sizeof(Vecyr0[0]) },
+	{ &tmyr1, Vecyr1, sizeof(Vecyr1)/sizeof(Vecyr1[0]) },
+	#endif
+	};
+ 
+ 
+/* List of tests to be run */
+const struct list  List[] = {
+	{ &tm0, Vec0, sizeof(Vec0)/sizeof(Vec0[0]) },
+	{ &tm1, Vec1, sizeof(Vec1)/sizeof(Vec1[0]) },
+	};
+ 
+#if defined(STUB_getenv_r)
+char *
+_getenv_r(struct _reent *p, const char *cp) { return getenv(cp); }
+#endif
+ 
+int
+main(void)
+{
+int  i, l, errr=0, erro=0, tot=0;
+const char  *cp;
+CHAR  out[OUTSIZE];
+size_t  ret;
+ 
+/* Set timezone so that %z and %Z tests come out right */
+cp = TZ;
+if((i=putenv(cp)))  {
+    printf( "putenv(%s) FAILED, ret %d\n", cp, i);
+    return(-1);
+    }
+if(strcmp(getenv("TZ"),strchr(TZ,'=')+1))  {
+    printf( "TZ not set properly in environment\n");
+    return(-2);
+    }
+tzset();
+ 
+#if defined(VERBOSE)
+printf("_timezone=%d, _daylight=%d, _tzname[0]=%s, _tzname[1]=%s\n", _timezone, _daylight, _tzname[0], _tzname[1]);
+{
+long offset;
+__tzinfo_type *tz = __gettzinfo ();
+/* The sign of this is exactly opposite the envvar TZ.  We
+   could directly use the global _timezone for tm_isdst==0,
+   but have to use __tzrule for daylight savings.  */
+printf("tz->__tzrule[0].offset=%d, tz->__tzrule[1].offset=%d\n", tz->__tzrule[0].offset, tz->__tzrule[1].offset);
+}
+#endif
+ 
+/* Run all of the exact-length tests as-given--results should match */
+for(l=0; l<sizeof(List)/sizeof(List[0]); l++)  {
+    const struct list  *test = &List[l];
+    for(i=0; i<test->cnt; i++)  {
+	tot++;	/* Keep track of number of tests */
+	ret = strftime(out, test->vec[i].max, test->vec[i].fmt, test->tms);
+	if(ret != test->vec[i].ret)  {
+	    errr++;
+	    fprintf(stderr,
+		"ERROR:  return %d != %d expected for List[%d].vec[%d]\n",
+						ret, test->vec[i].ret, l, i);
+	    }
+	if(strncmp(out, test->vec[i].out, test->vec[i].max-1))  {
+	    erro++;
+	    fprintf(stderr,
+		"ERROR:  \"%"SFLG"s\" != \"%"SFLG"s\" expected for List[%d].vec[%d]\n",
+						out, test->vec[i].out, l, i);
+	    }
+	}
+    }
+ 
+/* Run all of the exact-length tests with the length made too short--expect to
+ * fail.  */
+for(l=0; l<sizeof(List)/sizeof(List[0]); l++)  {
+    const struct list  *test = &List[l];
+    for(i=0; i<test->cnt; i++)  {
+	tot++;	/* Keep track of number of tests */
+	ret = strftime(out, test->vec[i].max-1, test->vec[i].fmt, test->tms);
+	if(ret != 0)  {
+	    errr++;
+	    fprintf(stderr,
+		"ERROR:  return %d != %d expected for List[%d].vec[%d]\n",
+						ret, 0, l, i);
+	    }
+	/* Almost every conversion puts out as many characters as possible, so
+	 * go ahead and test the output even though have failed.  (The test
+	 * times chosen happen to not hit any of the cases that fail this, so it
+	 * works.)  */
+	if(strncmp(out, test->vec[i].out, test->vec[i].max-1-1))  {
+	    erro++;
+	    fprintf(stderr,
+		"ERROR:  \"%"SFLG"s\" != \"%"SFLG"s\" expected for List[%d].vec[%d]\n",
+						out, test->vec[i].out, l, i);
+	    }
+	}
+    }
+ 
+/* Run all of the special year test cases */
+for(l=0; l<sizeof(ListYr)/sizeof(ListYr[0]); l++)  {
+    const struct list  *test = &ListYr[l];
+    for(i=0; i<test->cnt; i++)  {
+	tot++;	/* Keep track of number of tests */
+	ret = strftime(out, test->vec[i].max, test->vec[i].fmt, test->tms);
+	if(ret != test->vec[i].ret)  {
+	    errr++;
+	    fprintf(stderr,
+		"ERROR:  return %d != %d expected for ListYr[%d].vec[%d]\n",
+						ret, test->vec[i].ret, l, i);
+	    }
+	if(strncmp(out, test->vec[i].out, test->vec[i].max-1))  {
+	    erro++;
+	    fprintf(stderr,
+		"ERROR:  \"%"SFLG"s\" != \"%"SFLG"s\" expected for ListYr[%d].vec[%d]\n",
+						out, test->vec[i].out, l, i);
+	    }
+	}
+    }
+ 
+#define STRIZE(f)	#f
+#define NAME(f)	STRIZE(f)
+printf(NAME(strftime) "() test ");
+if(errr || erro)  printf("FAILED %d/%d of", errr, erro);
+  else    printf("passed");
+printf(" %d test cases.\n", tot);
+ 
+return(errr || erro);
+}
+#endif /* defined(_REGRESSION_TEST) ] */
diff --git a/msys/rt/src/newlib/libc/time/tzlock.c b/msys/rt/src/newlib/libc/time/tzlock.c
new file mode 100644
index 0000000..ccfef78
--- /dev/null
+++ b/msys/rt/src/newlib/libc/time/tzlock.c
@@ -0,0 +1,56 @@
+/*
+FUNCTION
+<<__tz_lock>>, <<__tz_unlock>>---lock time zone global variables
+
+INDEX
+	__tz_lock
+INDEX
+	__tz_unlock
+
+ANSI_SYNOPSIS
+	#include "local.h"
+	void __tz_lock (void);
+	void __tz_unlock (void);
+
+TRAD_SYNOPSIS
+	void __tz_lock();
+	void __tz_unlock();
+
+DESCRIPTION
+The <<tzset>> facility functions call these functions when they need to
+ensure the values of global variables.  The version of these routines
+supplied in the library use the lock API defined in sys/lock.h.  If multiple
+threads of execution can call the time functions and give up scheduling in
+the middle, then you you need to define your own versions of these functions
+in order to safely lock the time zone variables during a call.  If you do
+not, the results of <<localtime>>, <<mktime>>, <<ctime>>, and <<strftime>>
+are undefined.
+
+The lock <<__tz_lock>> may not be called recursively; that is,
+a call <<__tz_lock>> will always lock all subsequent <<__tz_lock>> calls
+until the corresponding <<__tz_unlock>> call on the same thread is made.
+*/
+
+#include <_ansi.h>
+#include "local.h"
+#include <sys/lock.h>
+
+#ifndef __SINGLE_THREAD__
+__LOCK_INIT(static, __tz_lock_object);
+#endif
+
+_VOID
+_DEFUN_VOID (__tz_lock)
+{
+#ifndef __SINGLE_THREAD__
+  __lock_acquire(__tz_lock_object);
+#endif
+}
+
+_VOID
+_DEFUN_VOID (__tz_unlock)
+{
+#ifndef __SINGLE_THREAD__
+  __lock_release(__tz_lock_object);
+#endif
+}
diff --git a/msys/rt/src/newlib/libc/time/wcsftime.c b/msys/rt/src/newlib/libc/time/wcsftime.c
new file mode 100644
index 0000000..ac71a09
--- /dev/null
+++ b/msys/rt/src/newlib/libc/time/wcsftime.c
@@ -0,0 +1,68 @@
+/*
+ * wcsftime.c
+ * Original Author:	Craig Howland, for Newlib
+ *
+ * Source actually uses strftime.c.
+ * Documentation for wcsftime() here, with minimal overlap.
+ */
+
+/*
+FUNCTION
+<<wcsftime>>--convert date and time to a formatted wide-character string
+
+INDEX
+	wcsftime
+
+ANSI_SYNOPSIS
+	#include <time.h>
+	#include <wchar.h>
+	size_t wcsftime(wchar_t *<[s]>, size_t <[maxsize]>,
+			const wchar_t *<[format]>, const struct tm *<[timp]>);
+
+DESCRIPTION
+<<wcsftime>> is equivalent to <<strftime>>, except that:
+ 
+O+
+o The argument s points to the initial element of an array of wide characters
+into which the generated output is to be placed.
+ 
+o The argument maxsize indicates the limiting number of wide characters.
+ 
+o The argument format is a wide-character string and the conversion specifiers
+are replaced by corresponding sequences of wide characters.
+ 
+o The return value indicates the number of wide characters.
+O-
+(The difference in all of the above being wide characters versus regular
+characters.)
+ 
+See <<strftime>> for the details of the format specifiers.
+
+RETURNS
+When the formatted time takes up no more than <[maxsize]> wide characters,
+the result is the length of the formatted wide string.  Otherwise, if the
+formatting operation was abandoned due to lack of room, the result is
+<<0>>, and the wide-character string starting at <[s]> corresponds to just those
+parts of <<*<[format]>>> that could be completely filled in within the
+<[maxsize]> limit.
+
+PORTABILITY
+C99 and POSIX require <<wcsftime>>, but do not specify the contents of
+<<*<[s]>>> when the formatted string would require more than
+<[maxsize]> characters.  Unrecognized specifiers and fields of
+<<timp>> that are out of range cause undefined results.  Since some
+formats expand to 0 bytes, it is wise to set <<*<[s]>>> to a nonzero
+value beforehand to distinguish between failure and an empty string.
+This implementation does not support <<s>> being NULL, nor overlapping
+<<s>> and <<format>>.
+
+<<wcsftime>> requires no supporting OS subroutines.
+
+SEEALSO
+<<strftime>>
+*/
+
+#include <time.h>
+#include <wchar.h>
+#define MAKE_WCSFTIME
+#include "../time/strftime.c"
diff --git a/msys/rt/src/winsup/cygwin/cygwin.din b/msys/rt/src/winsup/cygwin/cygwin.din
index 7a8e419..1221eb0 100644
--- a/msys/rt/src/winsup/cygwin/cygwin.din
+++ b/msys/rt/src/winsup/cygwin/cygwin.din
@@ -1267,3 +1267,17 @@ towlower
 towupper
 wctrans
 wctype
+fgetwc
+fgetws
+fputwc
+fputws
+fwide
+getwc
+getwchar
+putwc
+putwchar
+ungetwc
+wcslcpy
+wcsxfrm
+wcsftime
+btowc
-- 
2.0.0.msysgit.0

